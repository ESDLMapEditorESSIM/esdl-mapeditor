#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sun Jan 27 12:24:47 2019 by generateDS.py version 2.30.1.
# Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)]
#
# Command line options:
#   ('--subclass-suffix', '')
#   ('--no-namespace-defs', '')
#   ('-o', 'esdl_sup.py')
#   ('-s', 'esdl_sub.py')
#   ('--root-element', 'EnergySystem')
#   ('--export', 'write etree')
#
# Command line arguments:
#   esdlXML.xsd
#
# Command line:
#   C:\Users\matthijssenef\AppData\Local\Programs\Python\Python37\Scripts\generateDS-2-30-1-Edwin.py --subclass-suffix "" --no-namespace-defs -o "esdl_sup.py" -s "esdl_sub.py" --root-element="EnergySystem" --export="write etree" esdlXML.xsd
#
# Current working directory (os.getcwd()):
#   model_20190126
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
    # Edwin %e to %f
            return '%f' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class AdditionalHeatingSourceTypeEnum(object):
    NONE='NONE'
    ELECTRIC='ELECTRIC'
    GAS='GAS'


class AggrTypeEnum(object):
    UNDEFINED='UNDEFINED'
    NOT_AGGREGATED='NOT_AGGREGATED'
    PER_COMMODITY='PER_COMMODITY'
    TOTAL_ENERGY='TOTAL_ENERGY'
    TOTAL_CAPABILITY='TOTAL_CAPABILITY'
    PER_CAPIBILITY='PER_CAPIBILITY'


class AreaScopeEnum(object):
    UNDEFINED='UNDEFINED'
    BUILDING='BUILDING'
    STREET='STREET'
    ZIPCODE='ZIPCODE'
    NEIGHBOURHOOD='NEIGHBOURHOOD'
    DISTRICT='DISTRICT'
    VILLAGE='VILLAGE'
    CITY='CITY'
    MUNICIPALITY='MUNICIPALITY'
    REGION='REGION'
    PROVINCE='PROVINCE'
    STATE='STATE'
    COUNTRY='COUNTRY'
    CONTINENT='CONTINENT'


class AreaTypeEnum(object):
    UNDEFINED='UNDEFINED'
    ROAD='ROAD'
    RAILWAY='RAILWAY'
    TERRAIN='TERRAIN'
    RURAL_AREA='RURAL_AREA'
    BUILT='BUILT'
    WATER='WATER'
    SEA='SEA'
    RIVER='RIVER'
    CANAL='CANAL'
    LAKE='LAKE'
    LAND='LAND'
    PARCEL='PARCEL'


class BiomassHeaterTypeEnum(object):
    UNDEFINED='UNDEFINED'
    FULLY_AUTOMATD='FULLY_AUTOMATD'
    SEMI_AUTOMATED='SEMI_AUTOMATED'
    PELLET_FIRED='PELLET_FIRED'
    CHP='CHP'


class BuildingTypeEnum(object):
    UNDEFINED='UNDEFINED'
    RESIDENTIAL='RESIDENTIAL'
    GATHERING='GATHERING'
    PRISON='PRISON'
    HEALTHCARE='HEALTHCARE'
    INDUSTRY='INDUSTRY'
    OFFICE='OFFICE'
    EDUCATION='EDUCATION'
    SPORTS='SPORTS'
    SHOPPING='SHOPPING'
    GREENHOUSE='GREENHOUSE'
    OTHER='OTHER'
    UTILITY='UTILITY'


class CHPTypeEnum(object):
    UNDEFINED='UNDEFINED'
    STEG='STEG'
    GAS_TURBINE='GAS_TURBINE'
    GAS_MOTOR='GAS_MOTOR'


class CommodityEnum(object):
    UNDEFINED='UNDEFINED'
    ELECTRICITY='ELECTRICITY'
    GAS='GAS'
    HEAT='HEAT'
    H_2='H2'
    BIOGAS='BIOGAS'
    CO_2='CO2'
    ENERGY='ENERGY'


class ConsTypeEnum(object):
    PRIMARY='PRIMARY'
    FINAL='FINAL'


class CoolingDeviceType(object):
    UNDEFINED='UNDEFINED'
    FLOOR_COOLING='FLOOR_COOLING'
    AIR_CONDITIONING='AIR_CONDITIONING'


class CostUnitEnum(object):
    UNDEFINED='UNDEFINED'
    MONEY_IN_EUR='MONEY_IN_EUR'
    MONEY_IN_KEUR='MONEY_IN_KEUR'
    MONEY_IN_MEUR='MONEY_IN_MEUR'
    MONEY_IN_EUR_PER_KW='MONEY_IN_EUR_PER_KW'
    MONEY_IN_EUR_PER_KWH='MONEY_IN_EUR_PER_KWH'


class DurationUnitEnum(object):
    SECOND='SECOND'
    MINUTE='MINUTE'
    HOUR='HOUR'
    DAY='DAY'
    WEEK='WEEK'
    MONTH='MONTH'
    YEAR='YEAR'


class EnergyLabelEnum(object):
    UNDEFINED='UNDEFINED'
    LABEL_G='LABEL_G'
    LABEL_F='LABEL_F'
    LABEL_E='LABEL_E'
    LABEL_D='LABEL_D'
    LABEL_C='LABEL_C'
    LABEL_B='LABEL_B'
    LABEL_A='LABEL_A'
    LABEL_AP='LABEL_AP'
    LABEL_APP='LABEL_APP'
    LABEL_APPP='LABEL_APPP'
    LABEL_APPPP='LABEL_APPPP'


class GasConversionTypeEnum(object):
    UNDEFINED='UNDEFINED'
    SMR='SMR'
    ATR='ATR'


class GasHeaterTypeEnum(object):
    UNDEFINED='UNDEFINED'
    CR='CR'
    VR='VR'
    HR_100='HR100'
    HR_104='HR104'
    HR_107='HR107'
    HRE='HRE'
    HRWW='HRWW'


class GeothermalPotentialEnum(object):
    UNKNOWN='UNKNOWN'
    POSSIBLE='POSSIBLE'
    GOOD='GOOD'


class GeothermalPowerEnum(object):
    UNKNOWN='UNKNOWN'
    POSSIBLE_GT_5_MWTH='POSSIBLE_GT5MWTH'
    GOOD_GT_5_MWTH='GOOD_GT5MWTH'
    GOOD_GT_7_P_5_MWTH='GOOD_GT7P5MWTH'
    GOOD_GT_10_MWTH='GOOD_GT10MWTH'


class GeothermalSourceTypeEnum(object):
    UNDEFINED='UNDEFINED'
    HEAT='HEAT'
    ELECTRICITY='ELECTRICITY'


class GlasTypeEnum(object):
    UNDEFINED='UNDEFINED'
    ENKEL_GLAS='ENKEL_GLAS'
    DUBBEL_GLAS='DUBBEL_GLAS'
    HR_GLAS='HR_GLAS'
    HRP_GLAS='HRP_GLAS'
    HRPP_GLAS='HRPP_GLAS'
    HRPPP_GLAS='HRPPP_GLAS'


class HeatDemandTypeEnum(object):
    UNDEFINED='UNDEFINED'
    SPACE_HEATING='SPACE_HEATING'
    HOT_TAPWATER='HOT_TAPWATER'
    SH_AND_HTW='SH_AND_HTW'
    OTHER='OTHER'


class HeatRadiationDeviceTypeEnum(object):
    UNDEFINED='UNDEFINED'
    HT_RADIATOR='HT_RADIATOR'
    LT_RADIATOR='LT_RADIATOR'
    FLOOR_HEATING='FLOOR_HEATING'
    WALL_HEATING='WALL_HEATING'
    INFRARED_PANEL='INFRARED_PANEL'


class HousingTypeEnum(object):
    UNDEFINED='UNDEFINED'
    OWNER_OCCUPIED_PROPERTY='OWNER_OCCUPIED_PROPERTY'
    PRIVATE_RENTAL='PRIVATE_RENTAL'
    HOUSING_ASSOCIATION='HOUSING_ASSOCIATION'


class InhabitantsTypeEnum(object):
    UNDEFINED='UNDEFINED'
    ALLEENSTAAND='ALLEENSTAAND'
    TWEEVERDIENERS='TWEEVERDIENERS'
    GEZIN_MET_KINDEREN='GEZIN_MET_KINDEREN'
    BEJAARD_ECHTPAAR='BEJAARD_ECHTPAAR'


class InterpolationMethodEnum(object):
    UNDEFINED='UNDEFINED'
    NONE='NONE'
    LINEAR='LINEAR'
    CUBIC='CUBIC'
    NEAREST='NEAREST'
    PREVIOUS='PREVIOUS'
    NEXT='NEXT'
    OTHER='OTHER'


class MobilityFuelTypeEnum(object):
    UNDEFINED='UNDEFINED'
    PETROL='PETROL'
    DIESEL='DIESEL'
    HYDROGEN='HYDROGEN'
    LPG='LPG'
    BIOFUEL='BIOFUEL'
    ELECTRICITY='ELECTRICITY'
    OIL='OIL'
    LNG='LNG'
    KEROSENE='KEROSENE'


class MultiplierEnum(object):
    NONE='NONE'
    KILO='KILO'
    MEGA='MEGA'
    GIGA='GIGA'
    TERRA='TERRA'
    PETA='PETA'
    MILLI='MILLI'
    MICRO='MICRO'
    NANO='NANO'
    PICO='PICO'


class PVInstallationTypeEnum(object):
    UNDEFINED='UNDEFINED'
    ROOFTOP_PV='ROOFTOP_PV'
    BUILDING_INTEGRATED_PV='BUILDING_INTEGRATED_PV'
    WINDOW='WINDOW'
    ROAD='ROAD'
    FIELD='FIELD'
    WATER='WATER'


class PhysicalQuantityEnum(object):
    UNDEFINED='UNDEFINED'
    ENERGY='ENERGY'
    POWER='POWER'
    VOLTAGE='VOLTAGE'
    PRESSURE='PRESSURE'
    TEMPERATURE='TEMPERATURE'
    EMISSION='EMISSION'
    COST='COST'
    TIME='TIME'
    LENGTH='LENGTH'
    DISTANCE='DISTANCE'
    IRRADIANCE='IRRADIANCE'
    SPEED='SPEED'
    STATE_OF_CHARGE='STATE_OF_CHARGE'
    VOLUME='VOLUME'
    AREA='AREA'


class PowerPlantFuelEnum(object):
    UNDEFINED='UNDEFINED'
    COAL='COAL'
    BLAST_FURNACE_GAS='BLAST_FURNACE_GAS'
    NATURAL_GAS='NATURAL_GAS'
    URANIUM='URANIUM'
    HYDROGEN='HYDROGEN'


class ProfileTypeEnum(object):
    UNDEFINED='UNDEFINED'
    SOLARIRRADIANCE_IN_W_PER_M_2='SOLARIRRADIANCE_IN_W_PER_M2'
    WINDSPEED_IN_M_PER_S='WINDSPEED_IN_M_PER_S'
    STATEOFCHARGE_IN_WS='STATEOFCHARGE_IN_WS'
    ENERGY_IN_WH='ENERGY_IN_WH'
    ENERGY_IN_KWH='ENERGY_IN_KWH'
    ENERGY_IN_MWH='ENERGY_IN_MWH'
    ENERGY_IN_GWH='ENERGY_IN_GWH'
    ENERGY_IN_J='ENERGY_IN_J'
    ENERGY_IN_KJ='ENERGY_IN_KJ'
    ENERGY_IN_MJ='ENERGY_IN_MJ'
    ENERGY_IN_GJ='ENERGY_IN_GJ'
    ENERGY_IN_TJ='ENERGY_IN_TJ'
    ENERGY_IN_PJ='ENERGY_IN_PJ'
    TEMPERATURE_IN_C='TEMPERATURE_IN_C'
    TEMPERATURE_IN_K='TEMPERATURE_IN_K'
    POWER_IN_W='POWER_IN_W'
    POWER_IN_KW='POWER_IN_KW'
    POWER_IN_MW='POWER_IN_MW'
    POWER_IN_GW='POWER_IN_GW'
    POWER_IN_TW='POWER_IN_TW'
    MONEY_IN_EUR='MONEY_IN_EUR'
    MONEY_IN_KEUR='MONEY_IN_KEUR'
    MONEY_IN_MEUR='MONEY_IN_MEUR'
    PERCENTAGE='PERCENTAGE'
    MONEY_IN_EUR_PER_KW='MONEY_IN_EUR_PER_KW'
    MONEY_IN_EUR_PER_KWH='MONEY_IN_EUR_PER_KWH'
    VOLUME_IN_M_3='VOLUME_IN_M3'
    VOLUME_IN_LITERS='VOLUME_IN_LITERS'


class RenewableTypeEnum(object):
    UNDEFINED='UNDEFINED'
    RENEWABLE='RENEWABLE'
    FOSSIL='FOSSIL'


class ResidentialBuildingTypeEnum(object):
    UNDEFINED='UNDEFINED'
    VRIJSTAANDE_WONING='VRIJSTAANDE_WONING'
    TWEE_ONDER_EEN_KAP_WONING='TWEE_ONDER_EEN_KAP_WONING'
    RIJWONING='RIJWONING'
    MAISONNETTEWONING='MAISONNETTEWONING'
    GALERIJWONING='GALERIJWONING'
    PORTIEKWONING='PORTIEKWONING'
    FLATWONING='FLATWONING'
    TUSSENWONING='TUSSENWONING'
    HOEKWONING='HOEKWONING'
    GALERIJCOMPLEX='GALERIJCOMPLEX'
    APPARTEMENTENCOMPLEX='APPARTEMENTENCOMPLEX'


class ResidualHeatSourceTypeEnum(object):
    UNDEFINED='UNDEFINED'
    INDUSTRIAL='INDUSTRIAL'
    DATACENTER='DATACENTER'
    COOLING_HOUSE='COOLING_HOUSE'
    OTHER='OTHER'


class RoofTypeEnum(object):
    UNDEFINED='UNDEFINED'
    FLATROOF='FLATROOF'
    SLANTEDROOF='SLANTEDROOF'
    COMBINATION='COMBINATION'


class RoomHeaterTypeEnum(object):
    UNDEFINED='UNDEFINED'
    GAS_STOVE='GAS_STOVE'
    WOOD_STOVE='WOOD_STOVE'
    ELECTRIC='ELECTRIC'
    INFRARED_PANEL='INFRARED_PANEL'


class SectorEnum(object):
    UNDEFINED='UNDEFINED'
    GEBOUWDE_OMGEVING='GEBOUWDE_OMGEVING'
    ZAKELIJKE_DIENSTVERLENING='ZAKELIJKE_DIENSTVERLENING'
    INDUSTRIE='INDUSTRIE'
    AGRO_TUINBOUW='AGRO_TUINBOUW'


class SolarCollectorTypeEnum(object):
    UNDEFINED='UNDEFINED'
    ROOFTOP='ROOFTOP'
    BUILDING_INTEGRATED_SC='BUILDING_INTEGRATED_SC'
    ROAD='ROAD'
    FIELD='FIELD'
    WATER='WATER'


class SourceTypeEnum(object):
    UNDEFINED='UNDEFINED'
    AIR='AIR'
    SUB_SURFACE='SUB_SURFACE'
    AQUIFER='AQUIFER'
    SURFACE_WATER='SURFACE_WATER'
    HEAT_NETWORK='HEAT_NETWORK'


class StateOfMatterEnum(object):
    UNDEFINED='UNDEFINED'
    SOLID='SOLID'
    LIQUID='LIQUID'
    GASEOUS='GASEOUS'


class TimeUnit(object):
    NONE='NONE'
    SECOND='SECOND'
    MINUTE='MINUTE'
    QUARTER='QUARTER'
    HOUR='HOUR'
    DAY='DAY'
    WEEK='WEEK'
    MONTH='MONTH'
    YEAR='YEAR'


class UTESPotentialTypeEnum(object):
    UNDEFINED='UNDEFINED'
    HEAT_OPEN='HEAT_OPEN'
    HEAT_CLOSED='HEAT_CLOSED'
    COLD_OPEN='COLD_OPEN'
    COLD_CLOSED='COLD_CLOSED'


class UTESTypeEnum(object):
    UNDEFINED='UNDEFINED'
    AQUIFER_TES='AQUIFER_TES'
    BOREHOLE_TES='BOREHOLE_TES'
    CAVERN_TES='CAVERN_TES'
    OTHER='OTHER'


class UnitEnum(object):
    NONE='NONE'
    JOULE='JOULE'
    WATTHOUR='WATTHOUR'
    WATT='WATT'
    VOLT='VOLT'
    BAR='BAR'
    PSI='PSI'
    DEGREES_CELSIUS='DEGREES_CELSIUS'
    KELVIN='KELVIN'
    GRAM='GRAM'
    EURO='EURO'
    DOLLAR='DOLLAR'
    SECOND='SECOND'
    MINUTE='MINUTE'
    QUARTER='QUARTER'
    HOUR='HOUR'
    DAY='DAY'
    WEEK='WEEK'
    MONTH='MONTH'
    YEAR='YEAR'
    METRE='METRE'
    SQUARE_METRE='SQUARE_METRE'
    CUBIC_METRE='CUBIC_METRE'
    LITRE='LITRE'
    WATTSECOND='WATTSECOND'
    ARE='ARE'
    HECTARE='HECTARE'
    PERCENT='PERCENT'


class VehicleTypeEnum(object):
    UNDEFINED='UNDEFINED'
    CAR='CAR'
    TRUCK='TRUCK'
    VAN='VAN'
    BUS='BUS'
    METRO='METRO'
    TRAM='TRAM'
    TRAIN='TRAIN'
    PASSENGER_TRAIN='PASSENGER_TRAIN'
    FREIGHT_TRAIN='FREIGHT_TRAIN'
    SCOOTER='SCOOTER'
    MOTOR_CYCLE='MOTOR_CYCLE'
    NONROAD_VEHICLE='NONROAD_VEHICLE'
    AGRARIAN_VEHICLE='AGRARIAN_VEHICLE'
    BARGE='BARGE'
    INTERNATIONAL_SHIPPING='INTERNATIONAL_SHIPPING'
    AIRCRAFT='AIRCRAFT'
    OTHER='OTHER'
    TOTAL='TOTAL'


class VentilationTypeEnum(object):
    UNDEFINED='UNDEFINED'
    NATURAL='NATURAL'
    MECHANIC_IN='MECHANIC_IN'
    MECHANIC_OUT='MECHANIC_OUT'
    MECHANIC_INOUT='MECHANIC_INOUT'
    BALANCED='BALANCED'
    BALANCED_WITH_HEATRECUPERATION='BALANCED_WITH_HEATRECUPERATION'


class WaterToPowerTypeEnum(object):
    UNDEFINED='UNDEFINED'
    HYDRO_POWER='HYDRO_POWER'
    WAVE_POWER='WAVE_POWER'
    TIDAL_POWER='TIDAL_POWER'
    OSMOTIC_POWER='OSMOTIC_POWER'


class WindTurbineTypeEnum(object):
    UNDEFINED='UNDEFINED'
    WIND_ON_LAND='WIND_ON_LAND'
    WIND_AT_SEA='WIND_AT_SEA'
    WIND_ON_COAST='WIND_ON_COAST'
    WIND_ON_BUILDING='WIND_ON_BUILDING'


class EnergySystem(GeneratedsSuper):
    """This is the entry class to describe an EnergySystem in ESDL"""
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, geographicalScope=None, id=None, sector=None, measures=None, instance=None, energySystemInformation=None, parties=None, services=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.geographicalScope = _cast(None, geographicalScope)
        self.id = _cast(None, id)
        if sector is None:
            self.sector = []
        else:
            self.sector = sector
        self.measures = measures
        if instance is None:
            self.instance = []
        else:
            self.instance = instance
        self.energySystemInformation = energySystemInformation
        self.parties = parties
        self.services = services
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergySystem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergySystem.subclass:
            return EnergySystem.subclass(*args_, **kwargs_)
        else:
            return EnergySystem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sector(self):
        return self.sector
    def set_sector(self, sector):
        self.sector = sector
    def add_sector(self, value):
        self.sector.append(value)
    def add_sector(self, value):
        self.sector.append(value)
    def insert_sector_at(self, index, value):
        self.sector.insert(index, value)
    def replace_sector_at(self, index, value):
        self.sector[index] = value
    def get_measures(self):
        return self.measures
    def set_measures(self, measures):
        self.measures = measures
    def get_instance(self):
        return self.instance
    def set_instance(self, instance):
        self.instance = instance
    def add_instance(self, value):
        self.instance.append(value)
    def add_instance(self, value):
        self.instance.append(value)
    def insert_instance_at(self, index, value):
        self.instance.insert(index, value)
    def replace_instance_at(self, index, value):
        self.instance[index] = value
    def get_energySystemInformation(self):
        return self.energySystemInformation
    def set_energySystemInformation(self, energySystemInformation):
        self.energySystemInformation = energySystemInformation
    def get_parties(self):
        return self.parties
    def set_parties(self, parties):
        self.parties = parties
    def get_services(self):
        return self.services
    def set_services(self, services):
        self.services = services
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_geographicalScope(self):
        return self.geographicalScope
    def set_geographicalScope(self, geographicalScope):
        self.geographicalScope = geographicalScope
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def validate_SectorEnum(self, value):
        # Validate type SectorEnum, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNDEFINED', 'GEBOUWDE_OMGEVING', 'ZAKELIJKE_DIENSTVERLENING', 'INDUSTRIE', 'AGRO_TUINBOUW']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SectorEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.sector or
            self.measures is not None or
            self.instance or
            self.energySystemInformation is not None or
            self.parties is not None or
            self.services is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergySystem', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergySystem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergySystem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergySystem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergySystem'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.geographicalScope is not None and 'geographicalScope' not in already_processed:
            already_processed.add('geographicalScope')
            outfile.write(' geographicalScope=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geographicalScope), input_name='geographicalScope')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergySystem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sector_ in self.sector:
            sector_.export(outfile, level, namespaceprefix_, name_='sector', pretty_print=pretty_print)
        if self.measures is not None:
            self.measures.export(outfile, level, namespaceprefix_, name_='measures', pretty_print=pretty_print)
        for instance_ in self.instance:
            instance_.export(outfile, level, namespaceprefix_, name_='instance', pretty_print=pretty_print)
        if self.energySystemInformation is not None:
            self.energySystemInformation.export(outfile, level, namespaceprefix_, name_='energySystemInformation', pretty_print=pretty_print)
        if self.parties is not None:
            self.parties.export(outfile, level, namespaceprefix_, name_='parties', pretty_print=pretty_print)
        if self.services is not None:
            self.services.export(outfile, level, namespaceprefix_, name_='services', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergySystem', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.geographicalScope is not None:
            element.set('geographicalScope', self.gds_format_string(self.geographicalScope))
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for sector_ in self.sector:
            sector_.to_etree(element, name_='sector', mapping_=mapping_)
        if self.measures is not None:
            measures_ = self.measures
            measures_.to_etree(element, name_='measures', mapping_=mapping_)
        for instance_ in self.instance:
            instance_.to_etree(element, name_='instance', mapping_=mapping_)
        if self.energySystemInformation is not None:
            energySystemInformation_ = self.energySystemInformation
            energySystemInformation_.to_etree(element, name_='energySystemInformation', mapping_=mapping_)
        if self.parties is not None:
            parties_ = self.parties
            parties_.to_etree(element, name_='parties', mapping_=mapping_)
        if self.services is not None:
            services_ = self.services
            services_.to_etree(element, name_='services', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('geographicalScope', node)
        if value is not None and 'geographicalScope' not in already_processed:
            already_processed.add('geographicalScope')
            self.geographicalScope = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sector':
            obj_ = None
            self.sector.append(obj_)
            obj_.original_tagname_ = 'sector'
            # validate type SectorEnum
            self.validate_SectorEnum(self.sector[-1])
        elif nodeName_ == 'measures':
            obj_ = Measures.factory(parent_object_=self)
            obj_.build(child_)
            self.measures = obj_
            obj_.original_tagname_ = 'measures'
        elif nodeName_ == 'instance':
            obj_ = Instance.factory(parent_object_=self)
            obj_.build(child_)
            self.instance.append(obj_)
            obj_.original_tagname_ = 'instance'
        elif nodeName_ == 'energySystemInformation':
            obj_ = EnergySystemInformation.factory(parent_object_=self)
            obj_.build(child_)
            self.energySystemInformation = obj_
            obj_.original_tagname_ = 'energySystemInformation'
        elif nodeName_ == 'parties':
            obj_ = Parties.factory(parent_object_=self)
            obj_.build(child_)
            self.parties = obj_
            obj_.original_tagname_ = 'parties'
        elif nodeName_ == 'services':
            obj_ = Services.factory(parent_object_=self)
            obj_.build(child_)
            self.services = obj_
            obj_.original_tagname_ = 'services'
# end class EnergySystem


class Area(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, scope='UNDEFINED', type_=None, geometryReference=None, buildingDensity=None, containingArea=None, isOwnedBy=None, location=None, contour=None, socialProperties=None, economicProperties=None, asset=None, area=None, mobilityProperties=None, KPIs=None, potential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.scope = _cast(None, scope)
        self.type_ = _cast(None, type_)
        self.geometryReference = _cast(None, geometryReference)
        self.buildingDensity = _cast(float, buildingDensity)
        self.containingArea = _cast(None, containingArea)
        self.isOwnedBy = _cast(None, isOwnedBy)
        self.location = location
        self.contour = contour
        self.socialProperties = socialProperties
        self.economicProperties = economicProperties
        if asset is None:
            self.asset = []
        else:
            self.asset = asset
        if area is None:
            self.area = []
        else:
            self.area = area
        self.mobilityProperties = mobilityProperties
        self.KPIs = KPIs
        if potential is None:
            self.potential = []
        else:
            self.potential = potential
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Area)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Area.subclass:
            return Area.subclass(*args_, **kwargs_)
        else:
            return Area(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self):
        return self.location
    def set_location(self, location):
        self.location = location
    def get_contour(self):
        return self.contour
    def set_contour(self, contour):
        self.contour = contour
    def get_socialProperties(self):
        return self.socialProperties
    def set_socialProperties(self, socialProperties):
        self.socialProperties = socialProperties
    def get_economicProperties(self):
        return self.economicProperties
    def set_economicProperties(self, economicProperties):
        self.economicProperties = economicProperties
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def add_asset(self, value):
        self.asset.append(value)
    def add_asset_with_type(self, value):
        self.asset.append(value)
        value.original_tagname_ = 'asset'
        value.extensiontype_ = value.__class__.__name__
    def insert_asset_at(self, index, value):
        self.asset.insert(index, value)
    def replace_asset_at(self, index, value):
        self.asset[index] = value
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def add_area(self, value):
        self.area.append(value)
    def add_area(self, value):
        self.area.append(value)
    def insert_area_at(self, index, value):
        self.area.insert(index, value)
    def replace_area_at(self, index, value):
        self.area[index] = value
    def get_mobilityProperties(self):
        return self.mobilityProperties
    def set_mobilityProperties(self, mobilityProperties):
        self.mobilityProperties = mobilityProperties
    def get_KPIs(self):
        return self.KPIs
    def set_KPIs(self, KPIs):
        self.KPIs = KPIs
    def get_potential(self):
        return self.potential
    def set_potential(self, potential):
        self.potential = potential
    def add_potential(self, value):
        self.potential.append(value)
    def add_potential_with_type(self, value):
        self.potential.append(value)
        value.original_tagname_ = 'potential'
        value.extensiontype_ = value.__class__.__name__
    def insert_potential_at(self, index, value):
        self.potential.insert(index, value)
    def replace_potential_at(self, index, value):
        self.potential[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_geometryReference(self):
        return self.geometryReference
    def set_geometryReference(self, geometryReference):
        self.geometryReference = geometryReference
    def get_buildingDensity(self):
        return self.buildingDensity
    def set_buildingDensity(self, buildingDensity):
        self.buildingDensity = buildingDensity
    def get_containingArea(self):
        return self.containingArea
    def set_containingArea(self, containingArea):
        self.containingArea = containingArea
    def get_isOwnedBy(self):
        return self.isOwnedBy
    def set_isOwnedBy(self, isOwnedBy):
        self.isOwnedBy = isOwnedBy
    def hasContent_(self):
        if (
            self.location is not None or
            self.contour is not None or
            self.socialProperties is not None or
            self.economicProperties is not None or
            self.asset or
            self.area or
            self.mobilityProperties is not None or
            self.KPIs is not None or
            self.potential
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Area', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Area')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Area')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Area', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Area'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.scope != "UNDEFINED" and 'scope' not in already_processed:
            already_processed.add('scope')
            outfile.write(' scope=%s' % (quote_attrib(self.scope), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.geometryReference is not None and 'geometryReference' not in already_processed:
            already_processed.add('geometryReference')
            outfile.write(' geometryReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geometryReference), input_name='geometryReference')), ))
        if self.buildingDensity is not None and 'buildingDensity' not in already_processed:
            already_processed.add('buildingDensity')
            outfile.write(' buildingDensity="%s"' % self.gds_format_double(self.buildingDensity, input_name='buildingDensity'))
        if self.containingArea is not None and 'containingArea' not in already_processed:
            already_processed.add('containingArea')
            outfile.write(' containingArea=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.containingArea), input_name='containingArea')), ))
        if self.isOwnedBy is not None and 'isOwnedBy' not in already_processed:
            already_processed.add('isOwnedBy')
            outfile.write(' isOwnedBy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isOwnedBy), input_name='isOwnedBy')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Area', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.location is not None:
            self.location.export(outfile, level, namespaceprefix_, name_='location', pretty_print=pretty_print)
        if self.contour is not None:
            self.contour.export(outfile, level, namespaceprefix_, name_='contour', pretty_print=pretty_print)
        if self.socialProperties is not None:
            self.socialProperties.export(outfile, level, namespaceprefix_, name_='socialProperties', pretty_print=pretty_print)
        if self.economicProperties is not None:
            self.economicProperties.export(outfile, level, namespaceprefix_, name_='economicProperties', pretty_print=pretty_print)
        for asset_ in self.asset:
            asset_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        for area_ in self.area:
            area_.export(outfile, level, namespaceprefix_, name_='area', pretty_print=pretty_print)
        if self.mobilityProperties is not None:
            self.mobilityProperties.export(outfile, level, namespaceprefix_, name_='mobilityProperties', pretty_print=pretty_print)
        if self.KPIs is not None:
            self.KPIs.export(outfile, level, namespaceprefix_, name_='KPIs', pretty_print=pretty_print)
        for potential_ in self.potential:
            potential_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Area', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.scope is not None:
            element.set('scope', self.scope)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.geometryReference is not None:
            element.set('geometryReference', self.gds_format_string(self.geometryReference))
        if self.buildingDensity is not None:
            element.set('buildingDensity', self.gds_format_double(self.buildingDensity))
        if self.containingArea is not None:
            element.set('containingArea', self.gds_format_string(self.containingArea))
        if self.isOwnedBy is not None:
            element.set('isOwnedBy', self.gds_format_string(self.isOwnedBy))
        if self.location is not None:
            location_ = self.location
            location_.to_etree(element, name_='location', mapping_=mapping_)
        if self.contour is not None:
            contour_ = self.contour
            contour_.to_etree(element, name_='contour', mapping_=mapping_)
        if self.socialProperties is not None:
            socialProperties_ = self.socialProperties
            socialProperties_.to_etree(element, name_='socialProperties', mapping_=mapping_)
        if self.economicProperties is not None:
            economicProperties_ = self.economicProperties
            economicProperties_.to_etree(element, name_='economicProperties', mapping_=mapping_)
        for asset_ in self.asset:
            asset_.to_etree(element, name_='asset', mapping_=mapping_)
        for area_ in self.area:
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.mobilityProperties is not None:
            mobilityProperties_ = self.mobilityProperties
            mobilityProperties_.to_etree(element, name_='mobilityProperties', mapping_=mapping_)
        if self.KPIs is not None:
            KPIs_ = self.KPIs
            KPIs_.to_etree(element, name_='KPIs', mapping_=mapping_)
        for potential_ in self.potential:
            potential_.to_etree(element, name_='potential', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('scope', node)
        if value is not None and 'scope' not in already_processed:
            already_processed.add('scope')
            self.scope = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('geometryReference', node)
        if value is not None and 'geometryReference' not in already_processed:
            already_processed.add('geometryReference')
            self.geometryReference = value
        value = find_attr_value_('buildingDensity', node)
        if value is not None and 'buildingDensity' not in already_processed:
            already_processed.add('buildingDensity')
            try:
                self.buildingDensity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (buildingDensity): %s' % exp)
        value = find_attr_value_('containingArea', node)
        if value is not None and 'containingArea' not in already_processed:
            already_processed.add('containingArea')
            self.containingArea = value
        value = find_attr_value_('isOwnedBy', node)
        if value is not None and 'isOwnedBy' not in already_processed:
            already_processed.add('isOwnedBy')
            self.isOwnedBy = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'location':
            obj_ = Point.factory(parent_object_=self)
            obj_.build(child_)
            self.location = obj_
            obj_.original_tagname_ = 'location'
        elif nodeName_ == 'contour':
            obj_ = Polygon.factory(parent_object_=self)
            obj_.build(child_)
            self.contour = obj_
            obj_.original_tagname_ = 'contour'
        elif nodeName_ == 'socialProperties':
            obj_ = SocialProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.socialProperties = obj_
            obj_.original_tagname_ = 'socialProperties'
        elif nodeName_ == 'economicProperties':
            obj_ = EconomicProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.economicProperties = obj_
            obj_.original_tagname_ = 'economicProperties'
        elif nodeName_ == 'asset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <asset> element')
            self.asset.append(obj_)
            obj_.original_tagname_ = 'asset'
        elif nodeName_ == 'area':
            obj_ = Area.factory(parent_object_=self)
            obj_.build(child_)
            self.area.append(obj_)
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'mobilityProperties':
            obj_ = MobilityProperties.factory(parent_object_=self)
            obj_.build(child_)
            self.mobilityProperties = obj_
            obj_.original_tagname_ = 'mobilityProperties'
        elif nodeName_ == 'KPIs':
            obj_ = KPIs.factory(parent_object_=self)
            obj_.build(child_)
            self.KPIs = obj_
            obj_.original_tagname_ = 'KPIs'
        elif nodeName_ == 'potential':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <potential> element')
            self.potential.append(obj_)
            obj_.original_tagname_ = 'potential'
# end class Area


class Port(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, maxPower=None, simultaneousPower=None, name=None, energyasset=None, carrier=None, profile=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.maxPower = _cast(float, maxPower)
        self.simultaneousPower = _cast(float, simultaneousPower)
        self.name = _cast(None, name)
        self.energyasset = _cast(None, energyasset)
        self.carrier = _cast(None, carrier)
        self.profile = profile
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Port)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Port.subclass:
            return Port.subclass(*args_, **kwargs_)
        else:
            return Port(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile(self):
        return self.profile
    def set_profile(self, profile):
        self.profile = profile
        profile.original_tagname_ = 'profile'
        profile.extensiontype_ = profile.__class__.__name__
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_maxPower(self):
        return self.maxPower
    def set_maxPower(self, maxPower):
        self.maxPower = maxPower
    def get_simultaneousPower(self):
        return self.simultaneousPower
    def set_simultaneousPower(self, simultaneousPower):
        self.simultaneousPower = simultaneousPower
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_energyasset(self):
        return self.energyasset
    def set_energyasset(self, energyasset):
        self.energyasset = energyasset
    def get_carrier(self):
        return self.carrier
    def set_carrier(self, carrier):
        self.carrier = carrier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.profile is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Port', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Port')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Port')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Port', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Port'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.maxPower is not None and 'maxPower' not in already_processed:
            already_processed.add('maxPower')
            outfile.write(' maxPower="%s"' % self.gds_format_double(self.maxPower, input_name='maxPower'))
        if self.simultaneousPower is not None and 'simultaneousPower' not in already_processed:
            already_processed.add('simultaneousPower')
            outfile.write(' simultaneousPower="%s"' % self.gds_format_double(self.simultaneousPower, input_name='simultaneousPower'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.energyasset is not None and 'energyasset' not in already_processed:
            already_processed.add('energyasset')
            outfile.write(' energyasset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.energyasset), input_name='energyasset')), ))
        if self.carrier is not None and 'carrier' not in already_processed:
            already_processed.add('carrier')
            outfile.write(' carrier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.carrier), input_name='carrier')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Port', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.profile is not None:
            self.profile.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Port', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.maxPower is not None:
            element.set('maxPower', self.gds_format_double(self.maxPower))
        if self.simultaneousPower is not None:
            element.set('simultaneousPower', self.gds_format_double(self.simultaneousPower))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.energyasset is not None:
            element.set('energyasset', self.gds_format_string(self.energyasset))
        if self.carrier is not None:
            element.set('carrier', self.gds_format_string(self.carrier))
        if self.profile is not None:
            profile_ = self.profile
            profile_.to_etree(element, name_='profile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('maxPower', node)
        if value is not None and 'maxPower' not in already_processed:
            already_processed.add('maxPower')
            try:
                self.maxPower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxPower): %s' % exp)
        value = find_attr_value_('simultaneousPower', node)
        if value is not None and 'simultaneousPower' not in already_processed:
            already_processed.add('simultaneousPower')
            try:
                self.simultaneousPower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (simultaneousPower): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('energyasset', node)
        if value is not None and 'energyasset' not in already_processed:
            already_processed.add('energyasset')
            self.energyasset = value
        value = find_attr_value_('carrier', node)
        if value is not None and 'carrier' not in already_processed:
            already_processed.add('carrier')
            self.carrier = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <profile> element')
            self.profile = obj_
            obj_.original_tagname_ = 'profile'
# end class Port


class InPort(Port):
    subclass = None
    superclass = Port
    def __init__(self, id=None, maxPower=None, simultaneousPower=None, name=None, energyasset=None, carrier=None, profile=None, connectedTo=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InPort, self).__init__(id, maxPower, simultaneousPower, name, energyasset, carrier, profile,  **kwargs_)
        self.connectedTo = _cast(None, connectedTo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InPort.subclass:
            return InPort.subclass(*args_, **kwargs_)
        else:
            return InPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectedTo(self):
        return self.connectedTo
    def set_connectedTo(self, connectedTo):
        self.connectedTo = connectedTo
    def hasContent_(self):
        if (
            super(InPort, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='InPort', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InPort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='InPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='InPort'):
        super(InPort, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InPort')
        if self.connectedTo is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            outfile.write(' connectedTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectedTo), input_name='connectedTo')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='InPort', fromsubclass_=False, pretty_print=True):
        super(InPort, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InPort', mapping_=None):
        element = super(InPort, self).to_etree(parent_element, name_, mapping_)
        if self.connectedTo is not None:
            element.set('connectedTo', self.gds_format_string(self.connectedTo))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connectedTo', node)
        if value is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            self.connectedTo = value
        super(InPort, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InPort, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InPort


class OutPort(Port):
    subclass = None
    superclass = Port
    def __init__(self, id=None, maxPower=None, simultaneousPower=None, name=None, energyasset=None, carrier=None, profile=None, connectedTo=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(OutPort, self).__init__(id, maxPower, simultaneousPower, name, energyasset, carrier, profile,  **kwargs_)
        self.connectedTo = _cast(None, connectedTo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OutPort)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OutPort.subclass:
            return OutPort.subclass(*args_, **kwargs_)
        else:
            return OutPort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectedTo(self):
        return self.connectedTo
    def set_connectedTo(self, connectedTo):
        self.connectedTo = connectedTo
    def hasContent_(self):
        if (
            super(OutPort, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='OutPort', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OutPort')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutPort')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='OutPort', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='OutPort'):
        super(OutPort, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OutPort')
        if self.connectedTo is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            outfile.write(' connectedTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.connectedTo), input_name='connectedTo')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='OutPort', fromsubclass_=False, pretty_print=True):
        super(OutPort, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='OutPort', mapping_=None):
        element = super(OutPort, self).to_etree(parent_element, name_, mapping_)
        if self.connectedTo is not None:
            element.set('connectedTo', self.gds_format_string(self.connectedTo))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connectedTo', node)
        if value is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            self.connectedTo = value
        super(OutPort, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(OutPort, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class OutPort


class EconomicProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, averageIncome=None, averageWOZvalue=None, percentageOwnerOccupiedProperties=None, percentageHousingAssociation=None, percentagePrivateRental=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.averageIncome = _cast(float, averageIncome)
        self.averageWOZvalue = _cast(float, averageWOZvalue)
        self.percentageOwnerOccupiedProperties = _cast(float, percentageOwnerOccupiedProperties)
        self.percentageHousingAssociation = _cast(float, percentageHousingAssociation)
        self.percentagePrivateRental = _cast(float, percentagePrivateRental)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EconomicProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EconomicProperties.subclass:
            return EconomicProperties.subclass(*args_, **kwargs_)
        else:
            return EconomicProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averageIncome(self):
        return self.averageIncome
    def set_averageIncome(self, averageIncome):
        self.averageIncome = averageIncome
    def get_averageWOZvalue(self):
        return self.averageWOZvalue
    def set_averageWOZvalue(self, averageWOZvalue):
        self.averageWOZvalue = averageWOZvalue
    def get_percentageOwnerOccupiedProperties(self):
        return self.percentageOwnerOccupiedProperties
    def set_percentageOwnerOccupiedProperties(self, percentageOwnerOccupiedProperties):
        self.percentageOwnerOccupiedProperties = percentageOwnerOccupiedProperties
    def get_percentageHousingAssociation(self):
        return self.percentageHousingAssociation
    def set_percentageHousingAssociation(self, percentageHousingAssociation):
        self.percentageHousingAssociation = percentageHousingAssociation
    def get_percentagePrivateRental(self):
        return self.percentagePrivateRental
    def set_percentagePrivateRental(self, percentagePrivateRental):
        self.percentagePrivateRental = percentagePrivateRental
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EconomicProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EconomicProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EconomicProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EconomicProperties', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EconomicProperties'):
        if self.averageIncome is not None and 'averageIncome' not in already_processed:
            already_processed.add('averageIncome')
            outfile.write(' averageIncome="%s"' % self.gds_format_double(self.averageIncome, input_name='averageIncome'))
        if self.averageWOZvalue is not None and 'averageWOZvalue' not in already_processed:
            already_processed.add('averageWOZvalue')
            outfile.write(' averageWOZvalue="%s"' % self.gds_format_double(self.averageWOZvalue, input_name='averageWOZvalue'))
        if self.percentageOwnerOccupiedProperties is not None and 'percentageOwnerOccupiedProperties' not in already_processed:
            already_processed.add('percentageOwnerOccupiedProperties')
            outfile.write(' percentageOwnerOccupiedProperties="%s"' % self.gds_format_double(self.percentageOwnerOccupiedProperties, input_name='percentageOwnerOccupiedProperties'))
        if self.percentageHousingAssociation is not None and 'percentageHousingAssociation' not in already_processed:
            already_processed.add('percentageHousingAssociation')
            outfile.write(' percentageHousingAssociation="%s"' % self.gds_format_double(self.percentageHousingAssociation, input_name='percentageHousingAssociation'))
        if self.percentagePrivateRental is not None and 'percentagePrivateRental' not in already_processed:
            already_processed.add('percentagePrivateRental')
            outfile.write(' percentagePrivateRental="%s"' % self.gds_format_double(self.percentagePrivateRental, input_name='percentagePrivateRental'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EconomicProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='EconomicProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.averageIncome is not None:
            element.set('averageIncome', self.gds_format_double(self.averageIncome))
        if self.averageWOZvalue is not None:
            element.set('averageWOZvalue', self.gds_format_double(self.averageWOZvalue))
        if self.percentageOwnerOccupiedProperties is not None:
            element.set('percentageOwnerOccupiedProperties', self.gds_format_double(self.percentageOwnerOccupiedProperties))
        if self.percentageHousingAssociation is not None:
            element.set('percentageHousingAssociation', self.gds_format_double(self.percentageHousingAssociation))
        if self.percentagePrivateRental is not None:
            element.set('percentagePrivateRental', self.gds_format_double(self.percentagePrivateRental))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('averageIncome', node)
        if value is not None and 'averageIncome' not in already_processed:
            already_processed.add('averageIncome')
            try:
                self.averageIncome = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (averageIncome): %s' % exp)
        value = find_attr_value_('averageWOZvalue', node)
        if value is not None and 'averageWOZvalue' not in already_processed:
            already_processed.add('averageWOZvalue')
            try:
                self.averageWOZvalue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (averageWOZvalue): %s' % exp)
        value = find_attr_value_('percentageOwnerOccupiedProperties', node)
        if value is not None and 'percentageOwnerOccupiedProperties' not in already_processed:
            already_processed.add('percentageOwnerOccupiedProperties')
            try:
                self.percentageOwnerOccupiedProperties = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentageOwnerOccupiedProperties): %s' % exp)
        value = find_attr_value_('percentageHousingAssociation', node)
        if value is not None and 'percentageHousingAssociation' not in already_processed:
            already_processed.add('percentageHousingAssociation')
            try:
                self.percentageHousingAssociation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentageHousingAssociation): %s' % exp)
        value = find_attr_value_('percentagePrivateRental', node)
        if value is not None and 'percentagePrivateRental' not in already_processed:
            already_processed.add('percentagePrivateRental')
            try:
                self.percentagePrivateRental = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentagePrivateRental): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EconomicProperties


class SocialProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, socialCohesion=None, populationDensity=None, numberOfInhabitants=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.socialCohesion = _cast(float, socialCohesion)
        self.populationDensity = _cast(int, populationDensity)
        self.numberOfInhabitants = _cast(int, numberOfInhabitants)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SocialProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SocialProperties.subclass:
            return SocialProperties.subclass(*args_, **kwargs_)
        else:
            return SocialProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_socialCohesion(self):
        return self.socialCohesion
    def set_socialCohesion(self, socialCohesion):
        self.socialCohesion = socialCohesion
    def get_populationDensity(self):
        return self.populationDensity
    def set_populationDensity(self, populationDensity):
        self.populationDensity = populationDensity
    def get_numberOfInhabitants(self):
        return self.numberOfInhabitants
    def set_numberOfInhabitants(self, numberOfInhabitants):
        self.numberOfInhabitants = numberOfInhabitants
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SocialProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SocialProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SocialProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SocialProperties', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SocialProperties'):
        if self.socialCohesion is not None and 'socialCohesion' not in already_processed:
            already_processed.add('socialCohesion')
            outfile.write(' socialCohesion="%s"' % self.gds_format_double(self.socialCohesion, input_name='socialCohesion'))
        if self.populationDensity is not None and 'populationDensity' not in already_processed:
            already_processed.add('populationDensity')
            outfile.write(' populationDensity="%s"' % self.gds_format_integer(self.populationDensity, input_name='populationDensity'))
        if self.numberOfInhabitants is not None and 'numberOfInhabitants' not in already_processed:
            already_processed.add('numberOfInhabitants')
            outfile.write(' numberOfInhabitants="%s"' % self.gds_format_integer(self.numberOfInhabitants, input_name='numberOfInhabitants'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SocialProperties', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='SocialProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.socialCohesion is not None:
            element.set('socialCohesion', self.gds_format_double(self.socialCohesion))
        if self.populationDensity is not None:
            element.set('populationDensity', self.gds_format_integer(self.populationDensity))
        if self.numberOfInhabitants is not None:
            element.set('numberOfInhabitants', self.gds_format_integer(self.numberOfInhabitants))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('socialCohesion', node)
        if value is not None and 'socialCohesion' not in already_processed:
            already_processed.add('socialCohesion')
            try:
                self.socialCohesion = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (socialCohesion): %s' % exp)
        value = find_attr_value_('populationDensity', node)
        if value is not None and 'populationDensity' not in already_processed:
            already_processed.add('populationDensity')
            try:
                self.populationDensity = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfInhabitants', node)
        if value is not None and 'numberOfInhabitants' not in already_processed:
            already_processed.add('numberOfInhabitants')
            try:
                self.numberOfInhabitants = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SocialProperties


class Item(GeneratedsSuper):
    """ID of item in the original data source. Can be used to make links to
    the original data"""
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.shortName = _cast(None, shortName)
        self.description = _cast(None, description)
        self.originalIdInSource = _cast(None, originalIdInSource)
        self.isOwnedBy = _cast(None, isOwnedBy)
        self.sector = _cast(None, sector)
        self.dataSource = dataSource
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Item.subclass:
            return Item.subclass(*args_, **kwargs_)
        else:
            return Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_originalIdInSource(self):
        return self.originalIdInSource
    def set_originalIdInSource(self, originalIdInSource):
        self.originalIdInSource = originalIdInSource
    def get_isOwnedBy(self):
        return self.isOwnedBy
    def set_isOwnedBy(self, isOwnedBy):
        self.isOwnedBy = isOwnedBy
    def get_sector(self):
        return self.sector
    def set_sector(self, sector):
        self.sector = sector
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Item', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Item', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Item'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.shortName is not None and 'shortName' not in already_processed:
            already_processed.add('shortName')
            outfile.write(' shortName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shortName), input_name='shortName')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.originalIdInSource is not None and 'originalIdInSource' not in already_processed:
            already_processed.add('originalIdInSource')
            outfile.write(' originalIdInSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.originalIdInSource), input_name='originalIdInSource')), ))
        if self.isOwnedBy is not None and 'isOwnedBy' not in already_processed:
            already_processed.add('isOwnedBy')
            outfile.write(' isOwnedBy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.isOwnedBy), input_name='isOwnedBy')), ))
        if self.sector is not None and 'sector' not in already_processed:
            already_processed.add('sector')
            outfile.write(' sector=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sector), input_name='sector')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Item', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Item', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.shortName is not None:
            element.set('shortName', self.gds_format_string(self.shortName))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.originalIdInSource is not None:
            element.set('originalIdInSource', self.gds_format_string(self.originalIdInSource))
        if self.isOwnedBy is not None:
            element.set('isOwnedBy', self.gds_format_string(self.isOwnedBy))
        if self.sector is not None:
            element.set('sector', self.gds_format_string(self.sector))
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('shortName', node)
        if value is not None and 'shortName' not in already_processed:
            already_processed.add('shortName')
            self.shortName = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('originalIdInSource', node)
        if value is not None and 'originalIdInSource' not in already_processed:
            already_processed.add('originalIdInSource')
            self.originalIdInSource = value
        value = find_attr_value_('isOwnedBy', node)
        if value is not None and 'isOwnedBy' not in already_processed:
            already_processed.add('isOwnedBy')
            self.isOwnedBy = value
        value = find_attr_value_('sector', node)
        if value is not None and 'sector' not in already_processed:
            already_processed.add('sector')
            self.sector = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class Item


class Measures(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, asset=None, measuresCollection=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if asset is None:
            self.asset = []
        else:
            self.asset = asset
        if measuresCollection is None:
            self.measuresCollection = []
        else:
            self.measuresCollection = measuresCollection
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Measures)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Measures.subclass:
            return Measures.subclass(*args_, **kwargs_)
        else:
            return Measures(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def add_asset(self, value):
        self.asset.append(value)
    def add_asset_with_type(self, value):
        self.asset.append(value)
        value.original_tagname_ = 'asset'
        value.extensiontype_ = value.__class__.__name__
    def insert_asset_at(self, index, value):
        self.asset.insert(index, value)
    def replace_asset_at(self, index, value):
        self.asset[index] = value
    def get_measuresCollection(self):
        return self.measuresCollection
    def set_measuresCollection(self, measuresCollection):
        self.measuresCollection = measuresCollection
    def add_measuresCollection(self, value):
        self.measuresCollection.append(value)
    def add_measuresCollection(self, value):
        self.measuresCollection.append(value)
    def insert_measuresCollection_at(self, index, value):
        self.measuresCollection.insert(index, value)
    def replace_measuresCollection_at(self, index, value):
        self.measuresCollection[index] = value
    def hasContent_(self):
        if (
            self.asset or
            self.measuresCollection
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Measures', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Measures')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Measures')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Measures', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Measures'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Measures', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asset_ in self.asset:
            asset_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        for measuresCollection_ in self.measuresCollection:
            measuresCollection_.export(outfile, level, namespaceprefix_, name_='measuresCollection', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Measures', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for asset_ in self.asset:
            asset_.to_etree(element, name_='asset', mapping_=mapping_)
        for measuresCollection_ in self.measuresCollection:
            measuresCollection_.to_etree(element, name_='measuresCollection', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <asset> element')
            self.asset.append(obj_)
            obj_.original_tagname_ = 'asset'
        elif nodeName_ == 'measuresCollection':
            obj_ = MeasuresCollection.factory(parent_object_=self)
            obj_.build(child_)
            self.measuresCollection.append(obj_)
            obj_.original_tagname_ = 'measuresCollection'
# end class Measures


class Instance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, description=None, detailLevel='UNDEFINED', aggrType=None, area=None, date=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.detailLevel = _cast(None, detailLevel)
        self.aggrType = _cast(None, aggrType)
        self.area = area
        self.date = date
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Instance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Instance.subclass:
            return Instance.subclass(*args_, **kwargs_)
        else:
            return Instance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_detailLevel(self):
        return self.detailLevel
    def set_detailLevel(self, detailLevel):
        self.detailLevel = detailLevel
    def get_aggrType(self):
        return self.aggrType
    def set_aggrType(self, aggrType):
        self.aggrType = aggrType
    def hasContent_(self):
        if (
            self.area is not None or
            self.date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Instance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Instance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Instance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Instance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Instance'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.detailLevel != "UNDEFINED" and 'detailLevel' not in already_processed:
            already_processed.add('detailLevel')
            outfile.write(' detailLevel=%s' % (quote_attrib(self.detailLevel), ))
        if self.aggrType is not None and 'aggrType' not in already_processed:
            already_processed.add('aggrType')
            outfile.write(' aggrType=%s' % (quote_attrib(self.aggrType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Instance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.area is not None:
            self.area.export(outfile, level, namespaceprefix_, name_='area', pretty_print=pretty_print)
        if self.date is not None:
            self.date.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Instance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.detailLevel is not None:
            element.set('detailLevel', self.detailLevel)
        if self.aggrType is not None:
            element.set('aggrType', self.aggrType)
        if self.area is not None:
            area_ = self.area
            area_.to_etree(element, name_='area', mapping_=mapping_)
        if self.date is not None:
            date_ = self.date
            date_.to_etree(element, name_='date', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('detailLevel', node)
        if value is not None and 'detailLevel' not in already_processed:
            already_processed.add('detailLevel')
            self.detailLevel = value
        value = find_attr_value_('aggrType', node)
        if value is not None and 'aggrType' not in already_processed:
            already_processed.add('aggrType')
            self.aggrType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'area':
            obj_ = Area.factory(parent_object_=self)
            obj_.build(child_)
            self.area = obj_
            obj_.original_tagname_ = 'area'
        elif nodeName_ == 'date':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <date> element')
            self.date = obj_
            obj_.original_tagname_ = 'date'
# end class Instance


class Service(Item):
    subclass = None
    superclass = Item
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Service, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Service)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Service.subclass:
            return Service.subclass(*args_, **kwargs_)
        else:
            return Service(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Service, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Service', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Service')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Service')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Service', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Service'):
        super(Service, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Service')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Service', fromsubclass_=False, pretty_print=True):
        super(Service, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Service', mapping_=None):
        element = super(Service, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Service, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Service, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Service


class Potential(Item):
    subclass = None
    superclass = Item
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Potential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, extensiontype_,  **kwargs_)
        self.geometryReference = _cast(None, geometryReference)
        self.aggregated = _cast(bool, aggregated)
        self.aggregationCount = _cast(int, aggregationCount)
        self.geometry = geometry
        self.quantityAndUnit = quantityAndUnit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Potential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Potential.subclass:
            return Potential.subclass(*args_, **kwargs_)
        else:
            return Potential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geometry(self):
        return self.geometry
    def set_geometry(self, geometry):
        self.geometry = geometry
    def get_quantityAndUnit(self):
        return self.quantityAndUnit
    def set_quantityAndUnit(self, quantityAndUnit):
        self.quantityAndUnit = quantityAndUnit
    def get_geometryReference(self):
        return self.geometryReference
    def set_geometryReference(self, geometryReference):
        self.geometryReference = geometryReference
    def get_aggregated(self):
        return self.aggregated
    def set_aggregated(self, aggregated):
        self.aggregated = aggregated
    def get_aggregationCount(self):
        return self.aggregationCount
    def set_aggregationCount(self, aggregationCount):
        self.aggregationCount = aggregationCount
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.geometry is not None or
            self.quantityAndUnit is not None or
            super(Potential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Potential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Potential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Potential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Potential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Potential'):
        super(Potential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Potential')
        if self.geometryReference is not None and 'geometryReference' not in already_processed:
            already_processed.add('geometryReference')
            outfile.write(' geometryReference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geometryReference), input_name='geometryReference')), ))
        if self.aggregated and 'aggregated' not in already_processed:
            already_processed.add('aggregated')
            outfile.write(' aggregated="%s"' % self.gds_format_boolean(self.aggregated, input_name='aggregated'))
        if self.aggregationCount != 1 and 'aggregationCount' not in already_processed:
            already_processed.add('aggregationCount')
            outfile.write(' aggregationCount="%s"' % self.gds_format_integer(self.aggregationCount, input_name='aggregationCount'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Potential', fromsubclass_=False, pretty_print=True):
        super(Potential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.quantityAndUnit is not None:
            self.quantityAndUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Potential', mapping_=None):
        element = super(Potential, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.geometryReference is not None:
            element.set('geometryReference', self.gds_format_string(self.geometryReference))
        if self.aggregated is not None:
            element.set('aggregated', self.gds_format_boolean(self.aggregated))
        if self.aggregationCount is not None:
            element.set('aggregationCount', self.gds_format_integer(self.aggregationCount))
        if self.geometry is not None:
            geometry_ = self.geometry
            geometry_.to_etree(element, name_='geometry', mapping_=mapping_)
        if self.quantityAndUnit is not None:
            quantityAndUnit_ = self.quantityAndUnit
            quantityAndUnit_.to_etree(element, name_='quantityAndUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('geometryReference', node)
        if value is not None and 'geometryReference' not in already_processed:
            already_processed.add('geometryReference')
            self.geometryReference = value
        value = find_attr_value_('aggregated', node)
        if value is not None and 'aggregated' not in already_processed:
            already_processed.add('aggregated')
            if value in ('true', '1'):
                self.aggregated = True
            elif value in ('false', '0'):
                self.aggregated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aggregationCount', node)
        if value is not None and 'aggregationCount' not in already_processed:
            already_processed.add('aggregationCount')
            try:
                self.aggregationCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Potential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometry':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <geometry> element')
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'quantityAndUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <quantityAndUnit> element')
            self.quantityAndUnit = obj_
            obj_.original_tagname_ = 'quantityAndUnit'
        super(Potential, self).buildChildren(child_, node, nodeName_, True)
# end class Potential


class WindPotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, value=None, height=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WindPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
        self.height = _cast(int, height)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindPotential.subclass:
            return WindPotential.subclass(*args_, **kwargs_)
        else:
            return WindPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def hasContent_(self):
        if (
            super(WindPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WindPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WindPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WindPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WindPotential'):
        super(WindPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindPotential')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WindPotential', fromsubclass_=False, pretty_print=True):
        super(WindPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='WindPotential', mapping_=None):
        element = super(WindPotential, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if self.height is not None:
            element.set('height', self.gds_format_integer(self.height))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(WindPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WindPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WindPotential


class Carriers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, carrier=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        if carrier is None:
            self.carrier = []
        else:
            self.carrier = carrier
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Carriers)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Carriers.subclass:
            return Carriers.subclass(*args_, **kwargs_)
        else:
            return Carriers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_carrier(self):
        return self.carrier
    def set_carrier(self, carrier):
        self.carrier = carrier
    def add_carrier(self, value):
        self.carrier.append(value)
    def add_carrier_with_type(self, value):
        self.carrier.append(value)
        value.original_tagname_ = 'carrier'
        value.extensiontype_ = value.__class__.__name__
    def insert_carrier_at(self, index, value):
        self.carrier.insert(index, value)
    def replace_carrier_at(self, index, value):
        self.carrier[index] = value
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.carrier or
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Carriers', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Carriers')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Carriers')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Carriers', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Carriers'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Carriers', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for carrier_ in self.carrier:
            carrier_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Carriers', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for carrier_ in self.carrier:
            carrier_.to_etree(element, name_='carrier', mapping_=mapping_)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'carrier':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <carrier> element')
            self.carrier.append(obj_)
            obj_.original_tagname_ = 'carrier'
        elif nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class Carriers


class EnergySystemInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, carriers=None, profiles=None, dataSources=None, mobilityFuelInformation=None, quantityAndUnits=None, sectors=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.carriers = carriers
        self.profiles = profiles
        self.dataSources = dataSources
        self.mobilityFuelInformation = mobilityFuelInformation
        self.quantityAndUnits = quantityAndUnits
        self.sectors = sectors
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergySystemInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergySystemInformation.subclass:
            return EnergySystemInformation.subclass(*args_, **kwargs_)
        else:
            return EnergySystemInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_carriers(self):
        return self.carriers
    def set_carriers(self, carriers):
        self.carriers = carriers
    def get_profiles(self):
        return self.profiles
    def set_profiles(self, profiles):
        self.profiles = profiles
    def get_dataSources(self):
        return self.dataSources
    def set_dataSources(self, dataSources):
        self.dataSources = dataSources
    def get_mobilityFuelInformation(self):
        return self.mobilityFuelInformation
    def set_mobilityFuelInformation(self, mobilityFuelInformation):
        self.mobilityFuelInformation = mobilityFuelInformation
    def get_quantityAndUnits(self):
        return self.quantityAndUnits
    def set_quantityAndUnits(self, quantityAndUnits):
        self.quantityAndUnits = quantityAndUnits
    def get_sectors(self):
        return self.sectors
    def set_sectors(self, sectors):
        self.sectors = sectors
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.carriers is not None or
            self.profiles is not None or
            self.dataSources is not None or
            self.mobilityFuelInformation is not None or
            self.quantityAndUnits is not None or
            self.sectors is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergySystemInformation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergySystemInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergySystemInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergySystemInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergySystemInformation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergySystemInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.carriers is not None:
            self.carriers.export(outfile, level, namespaceprefix_, name_='carriers', pretty_print=pretty_print)
        if self.profiles is not None:
            self.profiles.export(outfile, level, namespaceprefix_, name_='profiles', pretty_print=pretty_print)
        if self.dataSources is not None:
            self.dataSources.export(outfile, level, namespaceprefix_, name_='dataSources', pretty_print=pretty_print)
        if self.mobilityFuelInformation is not None:
            self.mobilityFuelInformation.export(outfile, level, namespaceprefix_, name_='mobilityFuelInformation', pretty_print=pretty_print)
        if self.quantityAndUnits is not None:
            self.quantityAndUnits.export(outfile, level, namespaceprefix_, name_='quantityAndUnits', pretty_print=pretty_print)
        if self.sectors is not None:
            self.sectors.export(outfile, level, namespaceprefix_, name_='sectors', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergySystemInformation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.carriers is not None:
            carriers_ = self.carriers
            carriers_.to_etree(element, name_='carriers', mapping_=mapping_)
        if self.profiles is not None:
            profiles_ = self.profiles
            profiles_.to_etree(element, name_='profiles', mapping_=mapping_)
        if self.dataSources is not None:
            dataSources_ = self.dataSources
            dataSources_.to_etree(element, name_='dataSources', mapping_=mapping_)
        if self.mobilityFuelInformation is not None:
            mobilityFuelInformation_ = self.mobilityFuelInformation
            mobilityFuelInformation_.to_etree(element, name_='mobilityFuelInformation', mapping_=mapping_)
        if self.quantityAndUnits is not None:
            quantityAndUnits_ = self.quantityAndUnits
            quantityAndUnits_.to_etree(element, name_='quantityAndUnits', mapping_=mapping_)
        if self.sectors is not None:
            sectors_ = self.sectors
            sectors_.to_etree(element, name_='sectors', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'carriers':
            obj_ = Carriers.factory(parent_object_=self)
            obj_.build(child_)
            self.carriers = obj_
            obj_.original_tagname_ = 'carriers'
        elif nodeName_ == 'profiles':
            obj_ = Profiles.factory(parent_object_=self)
            obj_.build(child_)
            self.profiles = obj_
            obj_.original_tagname_ = 'profiles'
        elif nodeName_ == 'dataSources':
            obj_ = DataSources.factory(parent_object_=self)
            obj_.build(child_)
            self.dataSources = obj_
            obj_.original_tagname_ = 'dataSources'
        elif nodeName_ == 'mobilityFuelInformation':
            obj_ = MobilityFuelInformation.factory(parent_object_=self)
            obj_.build(child_)
            self.mobilityFuelInformation = obj_
            obj_.original_tagname_ = 'mobilityFuelInformation'
        elif nodeName_ == 'quantityAndUnits':
            obj_ = QuantityAndUnits.factory(parent_object_=self)
            obj_.build(child_)
            self.quantityAndUnits = obj_
            obj_.original_tagname_ = 'quantityAndUnits'
        elif nodeName_ == 'sectors':
            obj_ = Sectors.factory(parent_object_=self)
            obj_.build(child_)
            self.sectors = obj_
            obj_.original_tagname_ = 'sectors'
# end class EnergySystemInformation


class GenericProfile(GeneratedsSuper):
    """All profiles should describe these fields: a name and a ProfileType.
    There are two different profile types: static, with static
    values stored in the ESDL model itself. And External, which
    allows you to refer to an externally defined profile (e.g. in an
    Energy Information System or a timeseries database)"""
    subclass = None
    superclass = None
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.profileType = _cast(None, profileType)
        self.id = _cast(None, id)
        self.interpolationMethod = _cast(None, interpolationMethod)
        self.dataSource = dataSource
        self.profileQuantityAndUnit = profileQuantityAndUnit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericProfile.subclass:
            return GenericProfile.subclass(*args_, **kwargs_)
        else:
            return GenericProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_profileQuantityAndUnit(self):
        return self.profileQuantityAndUnit
    def set_profileQuantityAndUnit(self, profileQuantityAndUnit):
        self.profileQuantityAndUnit = profileQuantityAndUnit
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_profileType(self):
        return self.profileType
    def set_profileType(self, profileType):
        self.profileType = profileType
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_interpolationMethod(self):
        return self.interpolationMethod
    def set_interpolationMethod(self, interpolationMethod):
        self.interpolationMethod = interpolationMethod
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.dataSource is not None or
            self.profileQuantityAndUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericProfile'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.profileType != "UNDEFINED" and 'profileType' not in already_processed:
            already_processed.add('profileType')
            outfile.write(' profileType=%s' % (quote_attrib(self.profileType), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.interpolationMethod != "UNDEFINED" and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            outfile.write(' interpolationMethod=%s' % (quote_attrib(self.interpolationMethod), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericProfile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.profileQuantityAndUnit is not None:
            self.profileQuantityAndUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericProfile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.profileType is not None:
            element.set('profileType', self.profileType)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.interpolationMethod is not None:
            element.set('interpolationMethod', self.interpolationMethod)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if self.profileQuantityAndUnit is not None:
            profileQuantityAndUnit_ = self.profileQuantityAndUnit
            profileQuantityAndUnit_.to_etree(element, name_='profileQuantityAndUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('profileType', node)
        if value is not None and 'profileType' not in already_processed:
            already_processed.add('profileType')
            self.profileType = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('interpolationMethod', node)
        if value is not None and 'interpolationMethod' not in already_processed:
            already_processed.add('interpolationMethod')
            self.interpolationMethod = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
        elif nodeName_ == 'profileQuantityAndUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <profileQuantityAndUnit> element')
            self.profileQuantityAndUnit = obj_
            obj_.original_tagname_ = 'profileQuantityAndUnit'
# end class GenericProfile


class StaticProfile(GenericProfile):
    """Stores the profile in the ESDL model itself, in contrast with an
    external profile, which refers to an external source for a
    profile"""
    subclass = None
    superclass = GenericProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StaticProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StaticProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StaticProfile.subclass:
            return StaticProfile.subclass(*args_, **kwargs_)
        else:
            return StaticProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(StaticProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='StaticProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StaticProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StaticProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='StaticProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='StaticProfile'):
        super(StaticProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StaticProfile')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='StaticProfile', fromsubclass_=False, pretty_print=True):
        super(StaticProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='StaticProfile', mapping_=None):
        element = super(StaticProfile, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(StaticProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StaticProfile, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StaticProfile


class DateTimeProfile(StaticProfile):
    """Describes a profile using one or more Profile elements. Each element
    defines a from- and a to-datetime and a value which is valid for
    this range. The to-field may be ommitted, meaning this value is
    valid for all time after the to-date."""
    subclass = None
    superclass = StaticProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, element=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DateTimeProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit,  **kwargs_)
        if element is None:
            self.element = []
        else:
            self.element = element
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeProfile.subclass:
            return DateTimeProfile.subclass(*args_, **kwargs_)
        else:
            return DateTimeProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_element(self):
        return self.element
    def set_element(self, element):
        self.element = element
    def add_element(self, value):
        self.element.append(value)
    def add_element(self, value):
        self.element.append(value)
    def insert_element_at(self, index, value):
        self.element.insert(index, value)
    def replace_element_at(self, index, value):
        self.element[index] = value
    def hasContent_(self):
        if (
            self.element or
            super(DateTimeProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DateTimeProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTimeProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTimeProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DateTimeProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DateTimeProfile'):
        super(DateTimeProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTimeProfile')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DateTimeProfile', fromsubclass_=False, pretty_print=True):
        super(DateTimeProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for element_ in self.element:
            element_.export(outfile, level, namespaceprefix_, name_='element', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DateTimeProfile', mapping_=None):
        element = super(DateTimeProfile, self).to_etree(parent_element, name_, mapping_)
        for element_ in self.element:
            element_.to_etree(element, name_='element', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DateTimeProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'element':
            obj_ = ProfileElement.factory(parent_object_=self)
            obj_.build(child_)
            self.element.append(obj_)
            obj_.original_tagname_ = 'element'
        super(DateTimeProfile, self).buildChildren(child_, node, nodeName_, True)
# end class DateTimeProfile


class ProfileElement(GeneratedsSuper):
    """ProfileElement describes a single profile element describing a range
    and a value which is valid for this range. From-field is
    inclusive, To-field is exclusive, allowing you to describe
    ranges such as 1-1-2017T00:00:00.000 to 1-1-2018T00:00:00.000
    instead of 31-12-2017T23:59:59:999. The to-field may be
    ommitted, meaning this value is valid for all time after the
    specified to-datetime. Examples: The heat demand of a
    municipality in 2013 is 20 PJ. The range you define is then from
    1-1-2013T to 1-1-2014T and the value 20 and ProfileType
    ENERGY_IN_PJincluding the value itselfexclusive the value itself"""
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.from_ = _cast(None, from_)
        self.to = _cast(None, to)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileElement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileElement.subclass:
            return ProfileElement.subclass(*args_, **kwargs_)
        else:
            return ProfileElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ProfileElement', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileElement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProfileElement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ProfileElement', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ProfileElement'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.from_), input_name='from')), ))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.to), input_name='to')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ProfileElement', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='ProfileElement', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.from_ is not None:
            element.set('from', self.gds_format_string(self.from_))
        if self.to is not None:
            element.set('to', self.gds_format_string(self.to))
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            self.from_ = value
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            self.to = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ProfileElement


class ExternalProfile(GenericProfile):
    """ExternalProfile allows to refer to an externally defined profile.
    Common uses are a profile defined in a (timeseries) database
    such as InfluxDB. It allows you to specify a multiplier to scale
    the supplied external profile by a certain factor (e.g. when
    using NEDU profiles). Default the multiplier is '1'.A multiplier
    can be used to scale the supplied external profile by a certain
    factor (e.g. when using NEDU profiles). Default the multiplier
    is '1'."""
    subclass = None
    superclass = GenericProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, multiplier=1.0, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ExternalProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit, extensiontype_,  **kwargs_)
        self.multiplier = _cast(float, multiplier)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ExternalProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ExternalProfile.subclass:
            return ExternalProfile.subclass(*args_, **kwargs_)
        else:
            return ExternalProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ExternalProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ExternalProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ExternalProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ExternalProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ExternalProfile'):
        super(ExternalProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ExternalProfile')
        if self.multiplier != 1.0 and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier="%s"' % self.gds_format_double(self.multiplier, input_name='multiplier'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ExternalProfile', fromsubclass_=False, pretty_print=True):
        super(ExternalProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ExternalProfile', mapping_=None):
        element = super(ExternalProfile, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.multiplier is not None:
            element.set('multiplier', self.gds_format_double(self.multiplier))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            try:
                self.multiplier = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplier): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ExternalProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExternalProfile, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExternalProfile


class SingleValue(StaticProfile):
    """A profile used to define a single value. This should be used when no
    information is present about the time. E.g. the price of a PV
    panel as currently known When a model queries for a value from a
    certain date (and to a certain date), that information will be
    ignored and it will always return this value."""
    subclass = None
    superclass = StaticProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SingleValue, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SingleValue)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SingleValue.subclass:
            return SingleValue.subclass(*args_, **kwargs_)
        else:
            return SingleValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(SingleValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SingleValue', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SingleValue')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SingleValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SingleValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SingleValue'):
        super(SingleValue, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SingleValue')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SingleValue', fromsubclass_=False, pretty_print=True):
        super(SingleValue, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SingleValue', mapping_=None):
        element = super(SingleValue, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SingleValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SingleValue, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SingleValue


class GenericDistribution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericDistribution.subclass:
            return GenericDistribution.subclass(*args_, **kwargs_)
        else:
            return GenericDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericDistribution', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericDistribution'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericDistribution', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='GenericDistribution', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GenericDistribution


class Percentile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, percentile=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.percentile = _cast(int, percentile)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Percentile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Percentile.subclass:
            return Percentile.subclass(*args_, **kwargs_)
        else:
            return Percentile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percentile(self):
        return self.percentile
    def set_percentile(self, percentile):
        self.percentile = percentile
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Percentile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Percentile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Percentile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Percentile', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Percentile'):
        if self.percentile is not None and 'percentile' not in already_processed:
            already_processed.add('percentile')
            outfile.write(' percentile="%s"' % self.gds_format_integer(self.percentile, input_name='percentile'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Percentile', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Percentile', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.percentile is not None:
            element.set('percentile', self.gds_format_integer(self.percentile))
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('percentile', node)
        if value is not None and 'percentile' not in already_processed:
            already_processed.add('percentile')
            try:
                self.percentile = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Percentile


class PercentileDistribution(GenericDistribution):
    subclass = None
    superclass = GenericDistribution
    def __init__(self, name=None, percentile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PercentileDistribution, self).__init__(name,  **kwargs_)
        if percentile is None:
            self.percentile = []
        else:
            self.percentile = percentile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PercentileDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PercentileDistribution.subclass:
            return PercentileDistribution.subclass(*args_, **kwargs_)
        else:
            return PercentileDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_percentile(self):
        return self.percentile
    def set_percentile(self, percentile):
        self.percentile = percentile
    def add_percentile(self, value):
        self.percentile.append(value)
    def add_percentile(self, value):
        self.percentile.append(value)
    def insert_percentile_at(self, index, value):
        self.percentile.insert(index, value)
    def replace_percentile_at(self, index, value):
        self.percentile[index] = value
    def hasContent_(self):
        if (
            self.percentile or
            super(PercentileDistribution, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PercentileDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PercentileDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PercentileDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PercentileDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PercentileDistribution'):
        super(PercentileDistribution, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PercentileDistribution')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PercentileDistribution', fromsubclass_=False, pretty_print=True):
        super(PercentileDistribution, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for percentile_ in self.percentile:
            percentile_.export(outfile, level, namespaceprefix_, name_='percentile', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PercentileDistribution', mapping_=None):
        element = super(PercentileDistribution, self).to_etree(parent_element, name_, mapping_)
        for percentile_ in self.percentile:
            percentile_.to_etree(element, name_='percentile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PercentileDistribution, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'percentile':
            obj_ = Percentile.factory(parent_object_=self)
            obj_.build(child_)
            self.percentile.append(obj_)
            obj_.original_tagname_ = 'percentile'
        super(PercentileDistribution, self).buildChildren(child_, node, nodeName_, True)
# end class PercentileDistribution


class CostInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, investmentCosts=None, installationCosts=None, O_and_MCosts=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.investmentCosts = investmentCosts
        self.installationCosts = installationCosts
        self.O_and_MCosts = O_and_MCosts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CostInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CostInformation.subclass:
            return CostInformation.subclass(*args_, **kwargs_)
        else:
            return CostInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_investmentCosts(self):
        return self.investmentCosts
    def set_investmentCosts(self, investmentCosts):
        self.investmentCosts = investmentCosts
    def get_installationCosts(self):
        return self.installationCosts
    def set_installationCosts(self, installationCosts):
        self.installationCosts = installationCosts
    def get_O_and_MCosts(self):
        return self.O_and_MCosts
    def set_O_and_MCosts(self, O_and_MCosts):
        self.O_and_MCosts = O_and_MCosts
    def hasContent_(self):
        if (
            self.investmentCosts is not None or
            self.installationCosts is not None or
            self.O_and_MCosts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CostInformation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CostInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CostInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CostInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CostInformation'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CostInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.investmentCosts is not None:
            self.investmentCosts.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.installationCosts is not None:
            self.installationCosts.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.O_and_MCosts is not None:
            self.O_and_MCosts.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CostInformation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.investmentCosts is not None:
            investmentCosts_ = self.investmentCosts
            investmentCosts_.to_etree(element, name_='investmentCosts', mapping_=mapping_)
        if self.installationCosts is not None:
            installationCosts_ = self.installationCosts
            installationCosts_.to_etree(element, name_='installationCosts', mapping_=mapping_)
        if self.O_and_MCosts is not None:
            O_and_MCosts_ = self.O_and_MCosts
            O_and_MCosts_.to_etree(element, name_='O_and_MCosts', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'investmentCosts':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <investmentCosts> element')
            self.investmentCosts = obj_
            obj_.original_tagname_ = 'investmentCosts'
        elif nodeName_ == 'installationCosts':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <installationCosts> element')
            self.installationCosts = obj_
            obj_.original_tagname_ = 'installationCosts'
        elif nodeName_ == 'O_and_MCosts':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <O_and_MCosts> element')
            self.O_and_MCosts = obj_
            obj_.original_tagname_ = 'O_and_MCosts'
# end class CostInformation


class LabelDistribution(GenericDistribution):
    subclass = None
    superclass = GenericDistribution
    def __init__(self, name=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(LabelDistribution, self).__init__(name, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LabelDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LabelDistribution.subclass:
            return LabelDistribution.subclass(*args_, **kwargs_)
        else:
            return LabelDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(LabelDistribution, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='LabelDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LabelDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LabelDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='LabelDistribution', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='LabelDistribution'):
        super(LabelDistribution, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LabelDistribution')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='LabelDistribution', fromsubclass_=False, pretty_print=True):
        super(LabelDistribution, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='LabelDistribution', mapping_=None):
        element = super(LabelDistribution, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(LabelDistribution, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LabelDistribution, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LabelDistribution


class StringLabelDistribution(LabelDistribution):
    subclass = None
    superclass = LabelDistribution
    def __init__(self, name=None, stringPerc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StringLabelDistribution, self).__init__(name,  **kwargs_)
        if stringPerc is None:
            self.stringPerc = []
        else:
            self.stringPerc = stringPerc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringLabelDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringLabelDistribution.subclass:
            return StringLabelDistribution.subclass(*args_, **kwargs_)
        else:
            return StringLabelDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stringPerc(self):
        return self.stringPerc
    def set_stringPerc(self, stringPerc):
        self.stringPerc = stringPerc
    def add_stringPerc(self, value):
        self.stringPerc.append(value)
    def add_stringPerc(self, value):
        self.stringPerc.append(value)
    def insert_stringPerc_at(self, index, value):
        self.stringPerc.insert(index, value)
    def replace_stringPerc_at(self, index, value):
        self.stringPerc[index] = value
    def hasContent_(self):
        if (
            self.stringPerc or
            super(StringLabelDistribution, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='StringLabelDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringLabelDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringLabelDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='StringLabelDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='StringLabelDistribution'):
        super(StringLabelDistribution, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringLabelDistribution')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='StringLabelDistribution', fromsubclass_=False, pretty_print=True):
        super(StringLabelDistribution, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for stringPerc_ in self.stringPerc:
            stringPerc_.export(outfile, level, namespaceprefix_, name_='stringPerc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='StringLabelDistribution', mapping_=None):
        element = super(StringLabelDistribution, self).to_etree(parent_element, name_, mapping_)
        for stringPerc_ in self.stringPerc:
            stringPerc_.to_etree(element, name_='stringPerc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StringLabelDistribution, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'stringPerc':
            obj_ = StringPerc.factory(parent_object_=self)
            obj_.build(child_)
            self.stringPerc.append(obj_)
            obj_.original_tagname_ = 'stringPerc'
        super(StringLabelDistribution, self).buildChildren(child_, node, nodeName_, True)
# end class StringLabelDistribution


class EnergyLabelDistribution(LabelDistribution):
    subclass = None
    superclass = LabelDistribution
    def __init__(self, name=None, labelPerc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyLabelDistribution, self).__init__(name,  **kwargs_)
        if labelPerc is None:
            self.labelPerc = []
        else:
            self.labelPerc = labelPerc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLabelDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLabelDistribution.subclass:
            return EnergyLabelDistribution.subclass(*args_, **kwargs_)
        else:
            return EnergyLabelDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_labelPerc(self):
        return self.labelPerc
    def set_labelPerc(self, labelPerc):
        self.labelPerc = labelPerc
    def add_labelPerc(self, value):
        self.labelPerc.append(value)
    def add_labelPerc(self, value):
        self.labelPerc.append(value)
    def insert_labelPerc_at(self, index, value):
        self.labelPerc.insert(index, value)
    def replace_labelPerc_at(self, index, value):
        self.labelPerc[index] = value
    def hasContent_(self):
        if (
            self.labelPerc or
            super(EnergyLabelDistribution, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyLabelDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyLabelDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyLabelDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyLabelDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyLabelDistribution'):
        super(EnergyLabelDistribution, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyLabelDistribution')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyLabelDistribution', fromsubclass_=False, pretty_print=True):
        super(EnergyLabelDistribution, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for labelPerc_ in self.labelPerc:
            labelPerc_.export(outfile, level, namespaceprefix_, name_='labelPerc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyLabelDistribution', mapping_=None):
        element = super(EnergyLabelDistribution, self).to_etree(parent_element, name_, mapping_)
        for labelPerc_ in self.labelPerc:
            labelPerc_.to_etree(element, name_='labelPerc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnergyLabelDistribution, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'labelPerc':
            obj_ = EnergyLabelPerc.factory(parent_object_=self)
            obj_.build(child_)
            self.labelPerc.append(obj_)
            obj_.original_tagname_ = 'labelPerc'
        super(EnergyLabelDistribution, self).buildChildren(child_, node, nodeName_, True)
# end class EnergyLabelDistribution


class StringPerc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, label=None, percentage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.label = _cast(None, label)
        self.percentage = _cast(float, percentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringPerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringPerc.subclass:
            return StringPerc.subclass(*args_, **kwargs_)
        else:
            return StringPerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_percentage(self):
        return self.percentage
    def set_percentage(self, percentage):
        self.percentage = percentage
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='StringPerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringPerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringPerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='StringPerc', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='StringPerc'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_double(self.percentage, input_name='percentage'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='StringPerc', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='StringPerc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.label is not None:
            element.set('label', self.gds_format_string(self.label))
        if self.percentage is not None:
            element.set('percentage', self.gds_format_double(self.percentage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StringPerc


class EnergyLabelPerc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, energyLabel=None, percentage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.energyLabel = _cast(None, energyLabel)
        self.percentage = _cast(float, percentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyLabelPerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyLabelPerc.subclass:
            return EnergyLabelPerc.subclass(*args_, **kwargs_)
        else:
            return EnergyLabelPerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyLabel(self):
        return self.energyLabel
    def set_energyLabel(self, energyLabel):
        self.energyLabel = energyLabel
    def get_percentage(self):
        return self.percentage
    def set_percentage(self, percentage):
        self.percentage = percentage
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyLabelPerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyLabelPerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyLabelPerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyLabelPerc', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyLabelPerc'):
        if self.energyLabel is not None and 'energyLabel' not in already_processed:
            already_processed.add('energyLabel')
            outfile.write(' energyLabel=%s' % (quote_attrib(self.energyLabel), ))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_double(self.percentage, input_name='percentage'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyLabelPerc', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='EnergyLabelPerc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.energyLabel is not None:
            element.set('energyLabel', self.energyLabel)
        if self.percentage is not None:
            element.set('percentage', self.gds_format_double(self.percentage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('energyLabel', node)
        if value is not None and 'energyLabel' not in already_processed:
            already_processed.add('energyLabel')
            self.energyLabel = value
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EnergyLabelPerc


class FromToDistribution(LabelDistribution):
    subclass = None
    superclass = LabelDistribution
    def __init__(self, name=None, fromToPerc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(FromToDistribution, self).__init__(name,  **kwargs_)
        if fromToPerc is None:
            self.fromToPerc = []
        else:
            self.fromToPerc = fromToPerc
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FromToDistribution)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FromToDistribution.subclass:
            return FromToDistribution.subclass(*args_, **kwargs_)
        else:
            return FromToDistribution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fromToPerc(self):
        return self.fromToPerc
    def set_fromToPerc(self, fromToPerc):
        self.fromToPerc = fromToPerc
    def add_fromToPerc(self, value):
        self.fromToPerc.append(value)
    def add_fromToPerc(self, value):
        self.fromToPerc.append(value)
    def insert_fromToPerc_at(self, index, value):
        self.fromToPerc.insert(index, value)
    def replace_fromToPerc_at(self, index, value):
        self.fromToPerc[index] = value
    def hasContent_(self):
        if (
            self.fromToPerc or
            super(FromToDistribution, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='FromToDistribution', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FromToDistribution')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FromToDistribution')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='FromToDistribution', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='FromToDistribution'):
        super(FromToDistribution, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FromToDistribution')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='FromToDistribution', fromsubclass_=False, pretty_print=True):
        super(FromToDistribution, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for fromToPerc_ in self.fromToPerc:
            fromToPerc_.export(outfile, level, namespaceprefix_, name_='fromToPerc', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FromToDistribution', mapping_=None):
        element = super(FromToDistribution, self).to_etree(parent_element, name_, mapping_)
        for fromToPerc_ in self.fromToPerc:
            fromToPerc_.to_etree(element, name_='fromToPerc', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FromToDistribution, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fromToPerc':
            obj_ = FromToPerc.factory(parent_object_=self)
            obj_.build(child_)
            self.fromToPerc.append(obj_)
            obj_.original_tagname_ = 'fromToPerc'
        super(FromToDistribution, self).buildChildren(child_, node, nodeName_, True)
# end class FromToDistribution


class FromToPerc(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, from_=None, to=None, percentage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.from_ = _cast(float, from_)
        self.to = _cast(float, to)
        self.percentage = _cast(float, percentage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FromToPerc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FromToPerc.subclass:
            return FromToPerc.subclass(*args_, **kwargs_)
        else:
            return FromToPerc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_from(self):
        return self.from_
    def set_from(self, from_):
        self.from_ = from_
    def get_to(self):
        return self.to
    def set_to(self, to):
        self.to = to
    def get_percentage(self):
        return self.percentage
    def set_percentage(self, percentage):
        self.percentage = percentage
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='FromToPerc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FromToPerc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FromToPerc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='FromToPerc', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='FromToPerc'):
        if self.from_ is not None and 'from_' not in already_processed:
            already_processed.add('from_')
            outfile.write(' from="%s"' % self.gds_format_double(self.from_, input_name='from'))
        if self.to is not None and 'to' not in already_processed:
            already_processed.add('to')
            outfile.write(' to="%s"' % self.gds_format_double(self.to, input_name='to'))
        if self.percentage is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            outfile.write(' percentage="%s"' % self.gds_format_double(self.percentage, input_name='percentage'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='FromToPerc', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='FromToPerc', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.from_ is not None:
            element.set('from', self.gds_format_double(self.from_))
        if self.to is not None:
            element.set('to', self.gds_format_double(self.to))
        if self.percentage is not None:
            element.set('percentage', self.gds_format_double(self.percentage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from', node)
        if value is not None and 'from' not in already_processed:
            already_processed.add('from')
            try:
                self.from_ = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (from): %s' % exp)
        value = find_attr_value_('to', node)
        if value is not None and 'to' not in already_processed:
            already_processed.add('to')
            try:
                self.to = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (to): %s' % exp)
        value = find_attr_value_('percentage', node)
        if value is not None and 'percentage' not in already_processed:
            already_processed.add('percentage')
            try:
                self.percentage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (percentage): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FromToPerc


class PItemStat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, sigma=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.value = _cast(float, value)
        self.sigma = _cast(float, sigma)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PItemStat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PItemStat.subclass:
            return PItemStat.subclass(*args_, **kwargs_)
        else:
            return PItemStat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_sigma(self):
        return self.sigma
    def set_sigma(self, sigma):
        self.sigma = sigma
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PItemStat', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PItemStat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PItemStat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PItemStat', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PItemStat'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            outfile.write(' sigma="%s"' % self.gds_format_double(self.sigma, input_name='sigma'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PItemStat', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='PItemStat', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if self.sigma is not None:
            element.set('sigma', self.gds_format_double(self.sigma))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('sigma', node)
        if value is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            try:
                self.sigma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigma): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PItemStat


class AbstractVariance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractVariance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractVariance.subclass:
            return AbstractVariance.subclass(*args_, **kwargs_)
        else:
            return AbstractVariance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractVariance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractVariance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractVariance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractVariance', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractVariance'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractVariance', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='AbstractVariance', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractVariance


class SymetricVariance(AbstractVariance):
    subclass = None
    superclass = AbstractVariance
    def __init__(self, sigma=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SymetricVariance, self).__init__( **kwargs_)
        self.sigma = _cast(float, sigma)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SymetricVariance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SymetricVariance.subclass:
            return SymetricVariance.subclass(*args_, **kwargs_)
        else:
            return SymetricVariance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sigma(self):
        return self.sigma
    def set_sigma(self, sigma):
        self.sigma = sigma
    def hasContent_(self):
        if (
            super(SymetricVariance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SymetricVariance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SymetricVariance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SymetricVariance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SymetricVariance', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SymetricVariance'):
        super(SymetricVariance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SymetricVariance')
        if self.sigma is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            outfile.write(' sigma="%s"' % self.gds_format_double(self.sigma, input_name='sigma'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SymetricVariance', fromsubclass_=False, pretty_print=True):
        super(SymetricVariance, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='SymetricVariance', mapping_=None):
        element = super(SymetricVariance, self).to_etree(parent_element, name_, mapping_)
        if self.sigma is not None:
            element.set('sigma', self.gds_format_double(self.sigma))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sigma', node)
        if value is not None and 'sigma' not in already_processed:
            already_processed.add('sigma')
            try:
                self.sigma = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigma): %s' % exp)
        super(SymetricVariance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SymetricVariance, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SymetricVariance


class AssymetricVariance(AbstractVariance):
    subclass = None
    superclass = AbstractVariance
    def __init__(self, sigmaMin=None, sigmaPlus=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AssymetricVariance, self).__init__( **kwargs_)
        self.sigmaMin = _cast(float, sigmaMin)
        self.sigmaPlus = _cast(float, sigmaPlus)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssymetricVariance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssymetricVariance.subclass:
            return AssymetricVariance.subclass(*args_, **kwargs_)
        else:
            return AssymetricVariance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sigmaMin(self):
        return self.sigmaMin
    def set_sigmaMin(self, sigmaMin):
        self.sigmaMin = sigmaMin
    def get_sigmaPlus(self):
        return self.sigmaPlus
    def set_sigmaPlus(self, sigmaPlus):
        self.sigmaPlus = sigmaPlus
    def hasContent_(self):
        if (
            super(AssymetricVariance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AssymetricVariance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssymetricVariance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssymetricVariance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AssymetricVariance', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AssymetricVariance'):
        super(AssymetricVariance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssymetricVariance')
        if self.sigmaMin is not None and 'sigmaMin' not in already_processed:
            already_processed.add('sigmaMin')
            outfile.write(' sigmaMin="%s"' % self.gds_format_double(self.sigmaMin, input_name='sigmaMin'))
        if self.sigmaPlus is not None and 'sigmaPlus' not in already_processed:
            already_processed.add('sigmaPlus')
            outfile.write(' sigmaPlus="%s"' % self.gds_format_double(self.sigmaPlus, input_name='sigmaPlus'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AssymetricVariance', fromsubclass_=False, pretty_print=True):
        super(AssymetricVariance, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='AssymetricVariance', mapping_=None):
        element = super(AssymetricVariance, self).to_etree(parent_element, name_, mapping_)
        if self.sigmaMin is not None:
            element.set('sigmaMin', self.gds_format_double(self.sigmaMin))
        if self.sigmaPlus is not None:
            element.set('sigmaPlus', self.gds_format_double(self.sigmaPlus))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sigmaMin', node)
        if value is not None and 'sigmaMin' not in already_processed:
            already_processed.add('sigmaMin')
            try:
                self.sigmaMin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigmaMin): %s' % exp)
        value = find_attr_value_('sigmaPlus', node)
        if value is not None and 'sigmaPlus' not in already_processed:
            already_processed.add('sigmaPlus')
            try:
                self.sigmaPlus = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (sigmaPlus): %s' % exp)
        super(AssymetricVariance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssymetricVariance, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssymetricVariance


class DoubleAssymetricVariance(AbstractVariance):
    subclass = None
    superclass = AbstractVariance
    def __init__(self, plus34perc=None, plus48perc=None, min34perc=None, min48perc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DoubleAssymetricVariance, self).__init__( **kwargs_)
        self.plus34perc = _cast(float, plus34perc)
        self.plus48perc = _cast(float, plus48perc)
        self.min34perc = _cast(float, min34perc)
        self.min48perc = _cast(float, min48perc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleAssymetricVariance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleAssymetricVariance.subclass:
            return DoubleAssymetricVariance.subclass(*args_, **kwargs_)
        else:
            return DoubleAssymetricVariance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_plus34perc(self):
        return self.plus34perc
    def set_plus34perc(self, plus34perc):
        self.plus34perc = plus34perc
    def get_plus48perc(self):
        return self.plus48perc
    def set_plus48perc(self, plus48perc):
        self.plus48perc = plus48perc
    def get_min34perc(self):
        return self.min34perc
    def set_min34perc(self, min34perc):
        self.min34perc = min34perc
    def get_min48perc(self):
        return self.min48perc
    def set_min48perc(self, min48perc):
        self.min48perc = min48perc
    def hasContent_(self):
        if (
            super(DoubleAssymetricVariance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DoubleAssymetricVariance', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DoubleAssymetricVariance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleAssymetricVariance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DoubleAssymetricVariance', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DoubleAssymetricVariance'):
        super(DoubleAssymetricVariance, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleAssymetricVariance')
        if self.plus34perc is not None and 'plus34perc' not in already_processed:
            already_processed.add('plus34perc')
            outfile.write(' plus34perc="%s"' % self.gds_format_double(self.plus34perc, input_name='plus34perc'))
        if self.plus48perc is not None and 'plus48perc' not in already_processed:
            already_processed.add('plus48perc')
            outfile.write(' plus48perc="%s"' % self.gds_format_double(self.plus48perc, input_name='plus48perc'))
        if self.min34perc is not None and 'min34perc' not in already_processed:
            already_processed.add('min34perc')
            outfile.write(' min34perc="%s"' % self.gds_format_double(self.min34perc, input_name='min34perc'))
        if self.min48perc is not None and 'min48perc' not in already_processed:
            already_processed.add('min48perc')
            outfile.write(' min48perc="%s"' % self.gds_format_double(self.min48perc, input_name='min48perc'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DoubleAssymetricVariance', fromsubclass_=False, pretty_print=True):
        super(DoubleAssymetricVariance, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='DoubleAssymetricVariance', mapping_=None):
        element = super(DoubleAssymetricVariance, self).to_etree(parent_element, name_, mapping_)
        if self.plus34perc is not None:
            element.set('plus34perc', self.gds_format_double(self.plus34perc))
        if self.plus48perc is not None:
            element.set('plus48perc', self.gds_format_double(self.plus48perc))
        if self.min34perc is not None:
            element.set('min34perc', self.gds_format_double(self.min34perc))
        if self.min48perc is not None:
            element.set('min48perc', self.gds_format_double(self.min48perc))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('plus34perc', node)
        if value is not None and 'plus34perc' not in already_processed:
            already_processed.add('plus34perc')
            try:
                self.plus34perc = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (plus34perc): %s' % exp)
        value = find_attr_value_('plus48perc', node)
        if value is not None and 'plus48perc' not in already_processed:
            already_processed.add('plus48perc')
            try:
                self.plus48perc = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (plus48perc): %s' % exp)
        value = find_attr_value_('min34perc', node)
        if value is not None and 'min34perc' not in already_processed:
            already_processed.add('min34perc')
            try:
                self.min34perc = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (min34perc): %s' % exp)
        value = find_attr_value_('min48perc', node)
        if value is not None and 'min48perc' not in already_processed:
            already_processed.add('min48perc')
            try:
                self.min48perc = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (min48perc): %s' % exp)
        super(DoubleAssymetricVariance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DoubleAssymetricVariance, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DoubleAssymetricVariance


class Party(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, shortName=None, owns=None, ownsArea=None, sector=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.shortName = _cast(None, shortName)
        self.owns = _cast(None, owns)
        self.ownsArea = _cast(None, ownsArea)
        self.sector = _cast(None, sector)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Party)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Party.subclass:
            return Party.subclass(*args_, **kwargs_)
        else:
            return Party(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_shortName(self):
        return self.shortName
    def set_shortName(self, shortName):
        self.shortName = shortName
    def get_owns(self):
        return self.owns
    def set_owns(self, owns):
        self.owns = owns
    def get_ownsArea(self):
        return self.ownsArea
    def set_ownsArea(self, ownsArea):
        self.ownsArea = ownsArea
    def get_sector(self):
        return self.sector
    def set_sector(self, sector):
        self.sector = sector
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Party', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Party')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Party')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Party', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Party'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.shortName is not None and 'shortName' not in already_processed:
            already_processed.add('shortName')
            outfile.write(' shortName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.shortName), input_name='shortName')), ))
        if self.owns is not None and 'owns' not in already_processed:
            already_processed.add('owns')
            outfile.write(' owns=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.owns), input_name='owns')), ))
        if self.ownsArea is not None and 'ownsArea' not in already_processed:
            already_processed.add('ownsArea')
            outfile.write(' ownsArea=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.ownsArea), input_name='ownsArea')), ))
        if self.sector is not None and 'sector' not in already_processed:
            already_processed.add('sector')
            outfile.write(' sector=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sector), input_name='sector')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Party', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Party', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.shortName is not None:
            element.set('shortName', self.gds_format_string(self.shortName))
        if self.owns is not None:
            element.set('owns', self.gds_format_string(self.owns))
        if self.ownsArea is not None:
            element.set('ownsArea', self.gds_format_string(self.ownsArea))
        if self.sector is not None:
            element.set('sector', self.gds_format_string(self.sector))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('shortName', node)
        if value is not None and 'shortName' not in already_processed:
            already_processed.add('shortName')
            self.shortName = value
        value = find_attr_value_('owns', node)
        if value is not None and 'owns' not in already_processed:
            already_processed.add('owns')
            self.owns = value
        value = find_attr_value_('ownsArea', node)
        if value is not None and 'ownsArea' not in already_processed:
            already_processed.add('ownsArea')
            self.ownsArea = value
        value = find_attr_value_('sector', node)
        if value is not None and 'sector' not in already_processed:
            already_processed.add('sector')
            self.sector = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Party


class URIProfile(ExternalProfile):
    """Describes a reference to a profile in an information system using a
    URI (e.g. a URI to a profile in Energy Information System (EIS))"""
    subclass = None
    superclass = ExternalProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, multiplier=1.0, URI=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(URIProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit, multiplier,  **kwargs_)
        self.URI = _cast(None, URI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, URIProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if URIProfile.subclass:
            return URIProfile.subclass(*args_, **kwargs_)
        else:
            return URIProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def hasContent_(self):
        if (
            super(URIProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='URIProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('URIProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URIProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='URIProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='URIProfile'):
        super(URIProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='URIProfile')
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.URI), input_name='URI')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='URIProfile', fromsubclass_=False, pretty_print=True):
        super(URIProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='URIProfile', mapping_=None):
        element = super(URIProfile, self).to_etree(parent_element, name_, mapping_)
        if self.URI is not None:
            element.set('URI', self.gds_format_string(self.URI))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        super(URIProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(URIProfile, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class URIProfile


class DatabaseProfile(ExternalProfile):
    """Describes the fields of a generic database-based profileCan be used
    in the WHERE-clause of a query"""
    subclass = None
    superclass = ExternalProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, multiplier=1.0, host=None, port=None, database=None, filters=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DatabaseProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit, multiplier, extensiontype_,  **kwargs_)
        self.host = _cast(None, host)
        self.port = _cast(int, port)
        self.database = _cast(None, database)
        self.filters = _cast(None, filters)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DatabaseProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DatabaseProfile.subclass:
            return DatabaseProfile.subclass(*args_, **kwargs_)
        else:
            return DatabaseProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_host(self):
        return self.host
    def set_host(self, host):
        self.host = host
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def get_database(self):
        return self.database
    def set_database(self, database):
        self.database = database
    def get_filters(self):
        return self.filters
    def set_filters(self, filters):
        self.filters = filters
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(DatabaseProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DatabaseProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DatabaseProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatabaseProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DatabaseProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DatabaseProfile'):
        super(DatabaseProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DatabaseProfile')
        if self.host is not None and 'host' not in already_processed:
            already_processed.add('host')
            outfile.write(' host=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.host), input_name='host')), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.add('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
        if self.database is not None and 'database' not in already_processed:
            already_processed.add('database')
            outfile.write(' database=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.database), input_name='database')), ))
        if self.filters is not None and 'filters' not in already_processed:
            already_processed.add('filters')
            outfile.write(' filters=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.filters), input_name='filters')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DatabaseProfile', fromsubclass_=False, pretty_print=True):
        super(DatabaseProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DatabaseProfile', mapping_=None):
        element = super(DatabaseProfile, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.host is not None:
            element.set('host', self.gds_format_string(self.host))
        if self.port is not None:
            element.set('port', self.gds_format_integer(self.port))
        if self.database is not None:
            element.set('database', self.gds_format_string(self.database))
        if self.filters is not None:
            element.set('filters', self.gds_format_string(self.filters))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('host', node)
        if value is not None and 'host' not in already_processed:
            already_processed.add('host')
            self.host = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.add('port')
            try:
                self.port = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('database', node)
        if value is not None and 'database' not in already_processed:
            already_processed.add('database')
            self.database = value
        value = find_attr_value_('filters', node)
        if value is not None and 'filters' not in already_processed:
            already_processed.add('filters')
            self.filters = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(DatabaseProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DatabaseProfile, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DatabaseProfile


class InfluxDBProfile(DatabaseProfile):
    """Describes a profile based on a measurement and field as part of an
    InfluxDB timeseries query"""
    subclass = None
    superclass = DatabaseProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, multiplier=1.0, host=None, port=None, database=None, filters=None, measurement=None, field=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InfluxDBProfile, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit, multiplier, host, port, database, filters,  **kwargs_)
        self.measurement = _cast(None, measurement)
        self.field = _cast(None, field)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InfluxDBProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InfluxDBProfile.subclass:
            return InfluxDBProfile.subclass(*args_, **kwargs_)
        else:
            return InfluxDBProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_measurement(self):
        return self.measurement
    def set_measurement(self, measurement):
        self.measurement = measurement
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def hasContent_(self):
        if (
            super(InfluxDBProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='InfluxDBProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InfluxDBProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InfluxDBProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='InfluxDBProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='InfluxDBProfile'):
        super(InfluxDBProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InfluxDBProfile')
        if self.measurement is not None and 'measurement' not in already_processed:
            already_processed.add('measurement')
            outfile.write(' measurement=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.measurement), input_name='measurement')), ))
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='InfluxDBProfile', fromsubclass_=False, pretty_print=True):
        super(InfluxDBProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='InfluxDBProfile', mapping_=None):
        element = super(InfluxDBProfile, self).to_etree(parent_element, name_, mapping_)
        if self.measurement is not None:
            element.set('measurement', self.gds_format_string(self.measurement))
        if self.field is not None:
            element.set('field', self.gds_format_string(self.field))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('measurement', node)
        if value is not None and 'measurement' not in already_processed:
            already_processed.add('measurement')
            self.measurement = value
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
        super(InfluxDBProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InfluxDBProfile, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InfluxDBProfile


class Geometry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Geometry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Geometry.subclass:
            return Geometry.subclass(*args_, **kwargs_)
        else:
            return Geometry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Geometry', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Geometry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Geometry')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Geometry', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Geometry'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Geometry', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Geometry', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Geometry


class Carrier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, id=None, cost=None, dataSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.id = _cast(None, id)
        self.cost = cost
        self.dataSource = dataSource
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Carrier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Carrier.subclass:
            return Carrier.subclass(*args_, **kwargs_)
        else:
            return Carrier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cost(self):
        return self.cost
    def set_cost(self, cost):
        self.cost = cost
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.cost is not None or
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Carrier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Carrier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Carrier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Carrier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Carrier'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Carrier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cost is not None:
            self.cost.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Carrier', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.cost is not None:
            cost_ = self.cost
            cost_.to_etree(element, name_='cost', mapping_=mapping_)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cost':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <cost> element')
            self.cost = obj_
            obj_.original_tagname_ = 'cost'
        elif nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class Carrier


class Range(StaticProfile):
    subclass = None
    superclass = StaticProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, minValue=None, maxValue=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Range, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit,  **kwargs_)
        self.minValue = _cast(float, minValue)
        self.maxValue = _cast(float, maxValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Range)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Range.subclass:
            return Range.subclass(*args_, **kwargs_)
        else:
            return Range(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minValue(self):
        return self.minValue
    def set_minValue(self, minValue):
        self.minValue = minValue
    def get_maxValue(self):
        return self.maxValue
    def set_maxValue(self, maxValue):
        self.maxValue = maxValue
    def hasContent_(self):
        if (
            super(Range, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Range', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Range')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Range', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Range'):
        super(Range, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Range')
        if self.minValue is not None and 'minValue' not in already_processed:
            already_processed.add('minValue')
            outfile.write(' minValue="%s"' % self.gds_format_double(self.minValue, input_name='minValue'))
        if self.maxValue is not None and 'maxValue' not in already_processed:
            already_processed.add('maxValue')
            outfile.write(' maxValue="%s"' % self.gds_format_double(self.maxValue, input_name='maxValue'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Range', fromsubclass_=False, pretty_print=True):
        super(Range, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Range', mapping_=None):
        element = super(Range, self).to_etree(parent_element, name_, mapping_)
        if self.minValue is not None:
            element.set('minValue', self.gds_format_double(self.minValue))
        if self.maxValue is not None:
            element.set('maxValue', self.gds_format_double(self.maxValue))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minValue', node)
        if value is not None and 'minValue' not in already_processed:
            already_processed.add('minValue')
            try:
                self.minValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minValue): %s' % exp)
        value = find_attr_value_('maxValue', node)
        if value is not None and 'maxValue' not in already_processed:
            already_processed.add('maxValue')
            try:
                self.maxValue = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxValue): %s' % exp)
        super(Range, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Range, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Range


class SolarFieldPotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, value=0.0, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SolarFieldPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarFieldPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarFieldPotential.subclass:
            return SolarFieldPotential.subclass(*args_, **kwargs_)
        else:
            return SolarFieldPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(SolarFieldPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SolarFieldPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SolarFieldPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolarFieldPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SolarFieldPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SolarFieldPotential'):
        super(SolarFieldPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolarFieldPotential')
        if self.value != 0.0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SolarFieldPotential', fromsubclass_=False, pretty_print=True):
        super(SolarFieldPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SolarFieldPotential', mapping_=None):
        element = super(SolarFieldPotential, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(SolarFieldPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SolarFieldPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SolarFieldPotential


class Duration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, durationUnit='SECOND', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.value = _cast(int, value)
        self.durationUnit = _cast(None, durationUnit)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Duration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Duration.subclass:
            return Duration.subclass(*args_, **kwargs_)
        else:
            return Duration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_durationUnit(self):
        return self.durationUnit
    def set_durationUnit(self, durationUnit):
        self.durationUnit = durationUnit
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Duration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Duration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Duration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Duration', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Duration'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.durationUnit != "SECOND" and 'durationUnit' not in already_processed:
            already_processed.add('durationUnit')
            outfile.write(' durationUnit=%s' % (quote_attrib(self.durationUnit), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Duration', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='Duration', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.value is not None:
            element.set('value', self.gds_format_integer(self.value))
        if self.durationUnit is not None:
            element.set('durationUnit', self.durationUnit)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('durationUnit', node)
        if value is not None and 'durationUnit' not in already_processed:
            already_processed.add('durationUnit')
            self.durationUnit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Duration


class ProfileReference(StaticProfile):
    subclass = None
    superclass = StaticProfile
    def __init__(self, name=None, profileType='UNDEFINED', id=None, interpolationMethod='UNDEFINED', dataSource=None, profileQuantityAndUnit=None, multiplier=1, reference=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ProfileReference, self).__init__(name, profileType, id, interpolationMethod, dataSource, profileQuantityAndUnit,  **kwargs_)
        self.multiplier = _cast(float, multiplier)
        self.reference = _cast(None, reference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProfileReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProfileReference.subclass:
            return ProfileReference.subclass(*args_, **kwargs_)
        else:
            return ProfileReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def hasContent_(self):
        if (
            super(ProfileReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ProfileReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProfileReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProfileReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ProfileReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ProfileReference'):
        super(ProfileReference, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProfileReference')
        if self.multiplier != 1 and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier="%s"' % self.gds_format_double(self.multiplier, input_name='multiplier'))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ProfileReference', fromsubclass_=False, pretty_print=True):
        super(ProfileReference, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ProfileReference', mapping_=None):
        element = super(ProfileReference, self).to_etree(parent_element, name_, mapping_)
        if self.multiplier is not None:
            element.set('multiplier', self.gds_format_double(self.multiplier))
        if self.reference is not None:
            element.set('reference', self.gds_format_string(self.reference))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            try:
                self.multiplier = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (multiplier): %s' % exp)
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        super(ProfileReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProfileReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProfileReference


class Profiles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if profile is None:
            self.profile = []
        else:
            self.profile = profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Profiles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Profiles.subclass:
            return Profiles.subclass(*args_, **kwargs_)
        else:
            return Profiles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile(self):
        return self.profile
    def set_profile(self, profile):
        self.profile = profile
        profile.original_tagname_ = 'profile'
        profile.extensiontype_ = profile.__class__.__name__
    def add_profile(self, value):
        self.profile.append(value)
    def add_profile_with_type(self, value):
        self.profile.append(value)
        value.original_tagname_ = 'profile'
        value.extensiontype_ = value.__class__.__name__
    def insert_profile_at(self, index, value):
        self.profile.insert(index, value)
    def replace_profile_at(self, index, value):
        self.profile[index] = value
    def hasContent_(self):
        if (
            self.profile
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Profiles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Profiles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Profiles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Profiles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Profiles'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Profiles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for profile_ in self.profile:
            profile_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Profiles', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for profile_ in self.profile:
            profile_.to_etree(element, name_='profile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <profile> element')
            self.profile.append(obj_)
            obj_.original_tagname_ = 'profile'
# end class Profiles


class Parties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, party=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if party is None:
            self.party = []
        else:
            self.party = party
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parties.subclass:
            return Parties.subclass(*args_, **kwargs_)
        else:
            return Parties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_party(self):
        return self.party
    def set_party(self, party):
        self.party = party
    def add_party(self, value):
        self.party.append(value)
    def add_party(self, value):
        self.party.append(value)
    def insert_party_at(self, index, value):
        self.party.insert(index, value)
    def replace_party_at(self, index, value):
        self.party[index] = value
    def hasContent_(self):
        if (
            self.party
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Parties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Parties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Parties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Parties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Parties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Parties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for party_ in self.party:
            party_.export(outfile, level, namespaceprefix_, name_='party', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Parties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for party_ in self.party:
            party_.to_etree(element, name_='party', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'party':
            obj_ = Party.factory(parent_object_=self)
            obj_.build(child_)
            self.party.append(obj_)
            obj_.original_tagname_ = 'party'
# end class Parties


class DataSources(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        if dataSource is None:
            self.dataSource = []
        else:
            self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSources)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSources.subclass:
            return DataSources.subclass(*args_, **kwargs_)
        else:
            return DataSources(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def add_dataSource(self, value):
        self.dataSource.append(value)
    def add_dataSource(self, value):
        self.dataSource.append(value)
    def insert_dataSource_at(self, index, value):
        self.dataSource.insert(index, value)
    def replace_dataSource_at(self, index, value):
        self.dataSource[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.dataSource
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DataSources', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataSources')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSources')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DataSources', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DataSources'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DataSources', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for dataSource_ in self.dataSource:
            dataSource_.export(outfile, level, namespaceprefix_, name_='dataSource', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DataSources', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for dataSource_ in self.dataSource:
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSource':
            obj_ = DataSource.factory(parent_object_=self)
            obj_.build(child_)
            self.dataSource.append(obj_)
            obj_.original_tagname_ = 'dataSource'
# end class DataSources


class ResidualHeatSourcePotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, value=0.0, type_=None, associatedConversionAsset=None, residualHeatSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ResidualHeatSourcePotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
        self.type_ = _cast(None, type_)
        self.associatedConversionAsset = _cast(None, associatedConversionAsset)
        self.residualHeatSource = _cast(None, residualHeatSource)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidualHeatSourcePotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidualHeatSourcePotential.subclass:
            return ResidualHeatSourcePotential.subclass(*args_, **kwargs_)
        else:
            return ResidualHeatSourcePotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_associatedConversionAsset(self):
        return self.associatedConversionAsset
    def set_associatedConversionAsset(self, associatedConversionAsset):
        self.associatedConversionAsset = associatedConversionAsset
    def get_residualHeatSource(self):
        return self.residualHeatSource
    def set_residualHeatSource(self, residualHeatSource):
        self.residualHeatSource = residualHeatSource
    def hasContent_(self):
        if (
            super(ResidualHeatSourcePotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ResidualHeatSourcePotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResidualHeatSourcePotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidualHeatSourcePotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ResidualHeatSourcePotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ResidualHeatSourcePotential'):
        super(ResidualHeatSourcePotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidualHeatSourcePotential')
        if self.value != 0.0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.associatedConversionAsset is not None and 'associatedConversionAsset' not in already_processed:
            already_processed.add('associatedConversionAsset')
            outfile.write(' associatedConversionAsset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.associatedConversionAsset), input_name='associatedConversionAsset')), ))
        if self.residualHeatSource is not None and 'residualHeatSource' not in already_processed:
            already_processed.add('residualHeatSource')
            outfile.write(' residualHeatSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.residualHeatSource), input_name='residualHeatSource')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ResidualHeatSourcePotential', fromsubclass_=False, pretty_print=True):
        super(ResidualHeatSourcePotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ResidualHeatSourcePotential', mapping_=None):
        element = super(ResidualHeatSourcePotential, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.associatedConversionAsset is not None:
            element.set('associatedConversionAsset', self.gds_format_string(self.associatedConversionAsset))
        if self.residualHeatSource is not None:
            element.set('residualHeatSource', self.gds_format_string(self.residualHeatSource))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('associatedConversionAsset', node)
        if value is not None and 'associatedConversionAsset' not in already_processed:
            already_processed.add('associatedConversionAsset')
            self.associatedConversionAsset = value
        value = find_attr_value_('residualHeatSource', node)
        if value is not None and 'residualHeatSource' not in already_processed:
            already_processed.add('residualHeatSource')
            self.residualHeatSource = value
        super(ResidualHeatSourcePotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResidualHeatSourcePotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResidualHeatSourcePotential


class SubPolygon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, point=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if point is None:
            self.point = []
        else:
            self.point = point
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubPolygon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubPolygon.subclass:
            return SubPolygon.subclass(*args_, **kwargs_)
        else:
            return SubPolygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def add_point(self, value):
        self.point.append(value)
    def add_point(self, value):
        self.point.append(value)
    def insert_point_at(self, index, value):
        self.point.insert(index, value)
    def replace_point_at(self, index, value):
        self.point[index] = value
    def hasContent_(self):
        if (
            self.point
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SubPolygon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubPolygon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubPolygon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SubPolygon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SubPolygon'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SubPolygon', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for point_ in self.point:
            point_.export(outfile, level, namespaceprefix_, name_='point', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SubPolygon', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for point_ in self.point:
            point_.to_etree(element, name_='point', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = Point.factory(parent_object_=self)
            obj_.build(child_)
            self.point.append(obj_)
            obj_.original_tagname_ = 'point'
# end class SubPolygon


class MultiPolygon(Geometry):
    subclass = None
    superclass = Geometry
    def __init__(self, polygon=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(MultiPolygon, self).__init__( **kwargs_)
        if polygon is None:
            self.polygon = []
        else:
            self.polygon = polygon
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiPolygon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiPolygon.subclass:
            return MultiPolygon.subclass(*args_, **kwargs_)
        else:
            return MultiPolygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_polygon(self):
        return self.polygon
    def set_polygon(self, polygon):
        self.polygon = polygon
    def add_polygon(self, value):
        self.polygon.append(value)
    def add_polygon(self, value):
        self.polygon.append(value)
    def insert_polygon_at(self, index, value):
        self.polygon.insert(index, value)
    def replace_polygon_at(self, index, value):
        self.polygon[index] = value
    def hasContent_(self):
        if (
            self.polygon or
            super(MultiPolygon, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MultiPolygon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiPolygon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiPolygon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MultiPolygon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MultiPolygon'):
        super(MultiPolygon, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiPolygon')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MultiPolygon', fromsubclass_=False, pretty_print=True):
        super(MultiPolygon, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for polygon_ in self.polygon:
            polygon_.export(outfile, level, namespaceprefix_, name_='polygon', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MultiPolygon', mapping_=None):
        element = super(MultiPolygon, self).to_etree(parent_element, name_, mapping_)
        for polygon_ in self.polygon:
            polygon_.to_etree(element, name_='polygon', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiPolygon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'polygon':
            obj_ = Polygon.factory(parent_object_=self)
            obj_.build(child_)
            self.polygon.append(obj_)
            obj_.original_tagname_ = 'polygon'
        super(MultiPolygon, self).buildChildren(child_, node, nodeName_, True)
# end class MultiPolygon


class MobilityFuelInformation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, vehicleFuelEfficiency=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        if vehicleFuelEfficiency is None:
            self.vehicleFuelEfficiency = []
        else:
            self.vehicleFuelEfficiency = vehicleFuelEfficiency
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MobilityFuelInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MobilityFuelInformation.subclass:
            return MobilityFuelInformation.subclass(*args_, **kwargs_)
        else:
            return MobilityFuelInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vehicleFuelEfficiency(self):
        return self.vehicleFuelEfficiency
    def set_vehicleFuelEfficiency(self, vehicleFuelEfficiency):
        self.vehicleFuelEfficiency = vehicleFuelEfficiency
    def add_vehicleFuelEfficiency(self, value):
        self.vehicleFuelEfficiency.append(value)
    def add_vehicleFuelEfficiency(self, value):
        self.vehicleFuelEfficiency.append(value)
    def insert_vehicleFuelEfficiency_at(self, index, value):
        self.vehicleFuelEfficiency.insert(index, value)
    def replace_vehicleFuelEfficiency_at(self, index, value):
        self.vehicleFuelEfficiency[index] = value
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.vehicleFuelEfficiency or
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityFuelInformation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MobilityFuelInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MobilityFuelInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MobilityFuelInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MobilityFuelInformation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityFuelInformation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vehicleFuelEfficiency_ in self.vehicleFuelEfficiency:
            vehicleFuelEfficiency_.export(outfile, level, namespaceprefix_, name_='vehicleFuelEfficiency', pretty_print=pretty_print)
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MobilityFuelInformation', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for vehicleFuelEfficiency_ in self.vehicleFuelEfficiency:
            vehicleFuelEfficiency_.to_etree(element, name_='vehicleFuelEfficiency', mapping_=mapping_)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vehicleFuelEfficiency':
            obj_ = VehicleFuelEfficiency.factory(parent_object_=self)
            obj_.build(child_)
            self.vehicleFuelEfficiency.append(obj_)
            obj_.original_tagname_ = 'vehicleFuelEfficiency'
        elif nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class MobilityFuelInformation


class VehicleFuelEfficiency(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vehicleType=None, fuel=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vehicleType = _cast(None, vehicleType)
        self.fuel = _cast(None, fuel)
        self.efficiency = _cast(float, efficiency)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VehicleFuelEfficiency)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VehicleFuelEfficiency.subclass:
            return VehicleFuelEfficiency.subclass(*args_, **kwargs_)
        else:
            return VehicleFuelEfficiency(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vehicleType(self):
        return self.vehicleType
    def set_vehicleType(self, vehicleType):
        self.vehicleType = vehicleType
    def get_fuel(self):
        return self.fuel
    def set_fuel(self, fuel):
        self.fuel = fuel
    def get_efficiency(self):
        return self.efficiency
    def set_efficiency(self, efficiency):
        self.efficiency = efficiency
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='VehicleFuelEfficiency', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VehicleFuelEfficiency')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VehicleFuelEfficiency')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='VehicleFuelEfficiency', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='VehicleFuelEfficiency'):
        if self.vehicleType is not None and 'vehicleType' not in already_processed:
            already_processed.add('vehicleType')
            outfile.write(' vehicleType=%s' % (quote_attrib(self.vehicleType), ))
        if self.fuel is not None and 'fuel' not in already_processed:
            already_processed.add('fuel')
            outfile.write(' fuel=%s' % (quote_attrib(self.fuel), ))
        if self.efficiency is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            outfile.write(' efficiency="%s"' % self.gds_format_double(self.efficiency, input_name='efficiency'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='VehicleFuelEfficiency', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='VehicleFuelEfficiency', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.vehicleType is not None:
            element.set('vehicleType', self.vehicleType)
        if self.fuel is not None:
            element.set('fuel', self.fuel)
        if self.efficiency is not None:
            element.set('efficiency', self.gds_format_double(self.efficiency))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vehicleType', node)
        if value is not None and 'vehicleType' not in already_processed:
            already_processed.add('vehicleType')
            self.vehicleType = value
        value = find_attr_value_('fuel', node)
        if value is not None and 'fuel' not in already_processed:
            already_processed.add('fuel')
            self.fuel = value
        value = find_attr_value_('efficiency', node)
        if value is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            try:
                self.efficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (efficiency): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VehicleFuelEfficiency


class MobilityProperties(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numberOfVehicles=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.numberOfVehicles = numberOfVehicles
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MobilityProperties)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MobilityProperties.subclass:
            return MobilityProperties.subclass(*args_, **kwargs_)
        else:
            return MobilityProperties(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfVehicles(self):
        return self.numberOfVehicles
    def set_numberOfVehicles(self, numberOfVehicles):
        self.numberOfVehicles = numberOfVehicles
    def hasContent_(self):
        if (
            self.numberOfVehicles is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityProperties', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MobilityProperties')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MobilityProperties')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MobilityProperties', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MobilityProperties'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityProperties', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.numberOfVehicles is not None:
            self.numberOfVehicles.export(outfile, level, namespaceprefix_, name_='numberOfVehicles', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MobilityProperties', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.numberOfVehicles is not None:
            numberOfVehicles_ = self.numberOfVehicles
            numberOfVehicles_.to_etree(element, name_='numberOfVehicles', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'numberOfVehicles':
            obj_ = NumberOfVehicles.factory(parent_object_=self)
            obj_.build(child_)
            self.numberOfVehicles = obj_
            obj_.original_tagname_ = 'numberOfVehicles'
# end class MobilityProperties


class NumberOfVehicles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vehicleCount=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if vehicleCount is None:
            self.vehicleCount = []
        else:
            self.vehicleCount = vehicleCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NumberOfVehicles)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NumberOfVehicles.subclass:
            return NumberOfVehicles.subclass(*args_, **kwargs_)
        else:
            return NumberOfVehicles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vehicleCount(self):
        return self.vehicleCount
    def set_vehicleCount(self, vehicleCount):
        self.vehicleCount = vehicleCount
    def add_vehicleCount(self, value):
        self.vehicleCount.append(value)
    def add_vehicleCount(self, value):
        self.vehicleCount.append(value)
    def insert_vehicleCount_at(self, index, value):
        self.vehicleCount.insert(index, value)
    def replace_vehicleCount_at(self, index, value):
        self.vehicleCount[index] = value
    def hasContent_(self):
        if (
            self.vehicleCount
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='NumberOfVehicles', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NumberOfVehicles')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NumberOfVehicles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='NumberOfVehicles', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='NumberOfVehicles'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='NumberOfVehicles', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for vehicleCount_ in self.vehicleCount:
            vehicleCount_.export(outfile, level, namespaceprefix_, name_='vehicleCount', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='NumberOfVehicles', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for vehicleCount_ in self.vehicleCount:
            vehicleCount_.to_etree(element, name_='vehicleCount', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vehicleCount':
            obj_ = VehicleCount.factory(parent_object_=self)
            obj_.build(child_)
            self.vehicleCount.append(obj_)
            obj_.original_tagname_ = 'vehicleCount'
# end class NumberOfVehicles


class VehicleCount(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, count=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = _cast(None, type_)
        self.count = _cast(int, count)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VehicleCount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VehicleCount.subclass:
            return VehicleCount.subclass(*args_, **kwargs_)
        else:
            return VehicleCount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='VehicleCount', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VehicleCount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VehicleCount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='VehicleCount', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='VehicleCount'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='VehicleCount', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='VehicleCount', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.count is not None:
            element.set('count', self.gds_format_integer(self.count))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VehicleCount


class Services(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, service=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if service is None:
            self.service = []
        else:
            self.service = service
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Services)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Services.subclass:
            return Services.subclass(*args_, **kwargs_)
        else:
            return Services(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self):
        return self.service
    def set_service(self, service):
        self.service = service
    def add_service(self, value):
        self.service.append(value)
    def add_service_with_type(self, value):
        self.service.append(value)
        value.original_tagname_ = 'service'
        value.extensiontype_ = value.__class__.__name__
    def insert_service_at(self, index, value):
        self.service.insert(index, value)
    def replace_service_at(self, index, value):
        self.service[index] = value
    def hasContent_(self):
        if (
            self.service
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Services', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Services')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Services')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Services', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Services'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Services', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for service_ in self.service:
            service_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Services', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        for service_ in self.service:
            service_.to_etree(element, name_='service', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'service':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <service> element')
            self.service.append(obj_)
            obj_.original_tagname_ = 'service'
# end class Services


class AbstractDataSource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDataSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDataSource.subclass:
            return AbstractDataSource.subclass(*args_, **kwargs_)
        else:
            return AbstractDataSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractDataSource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractDataSource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractDataSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractDataSource', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractDataSource'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractDataSource', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='AbstractDataSource', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractDataSource


class DataSourceReference(AbstractDataSource):
    subclass = None
    superclass = AbstractDataSource
    def __init__(self, reference=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DataSourceReference, self).__init__( **kwargs_)
        self.reference = _cast(None, reference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSourceReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSourceReference.subclass:
            return DataSourceReference.subclass(*args_, **kwargs_)
        else:
            return DataSourceReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def hasContent_(self):
        if (
            super(DataSourceReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DataSourceReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataSourceReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSourceReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DataSourceReference', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DataSourceReference'):
        super(DataSourceReference, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSourceReference')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DataSourceReference', fromsubclass_=False, pretty_print=True):
        super(DataSourceReference, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='DataSourceReference', mapping_=None):
        element = super(DataSourceReference, self).to_etree(parent_element, name_, mapping_)
        if self.reference is not None:
            element.set('reference', self.gds_format_string(self.reference))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        super(DataSourceReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DataSourceReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DataSourceReference


class KPIs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, description=None, kpi=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.description = _cast(None, description)
        if kpi is None:
            self.kpi = []
        else:
            self.kpi = kpi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KPIs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KPIs.subclass:
            return KPIs.subclass(*args_, **kwargs_)
        else:
            return KPIs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kpi(self):
        return self.kpi
    def set_kpi(self, kpi):
        self.kpi = kpi
    def add_kpi(self, value):
        self.kpi.append(value)
    def add_kpi(self, value):
        self.kpi.append(value)
    def insert_kpi_at(self, index, value):
        self.kpi.insert(index, value)
    def replace_kpi_at(self, index, value):
        self.kpi[index] = value
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def hasContent_(self):
        if (
            self.kpi
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='KPIs', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KPIs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KPIs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='KPIs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='KPIs'):
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='KPIs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for kpi_ in self.kpi:
            kpi_.export(outfile, level, namespaceprefix_, name_='kpi', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KPIs', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        for kpi_ in self.kpi:
            kpi_.to_etree(element, name_='kpi', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kpi':
            obj_ = KPI.factory(parent_object_=self)
            obj_.build(child_)
            self.kpi.append(obj_)
            obj_.original_tagname_ = 'kpi'
# end class KPIs


class KPI(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, quantityAndUnit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.value = _cast(float, value)
        self.quantityAndUnit = quantityAndUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KPI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KPI.subclass:
            return KPI.subclass(*args_, **kwargs_)
        else:
            return KPI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityAndUnit(self):
        return self.quantityAndUnit
    def set_quantityAndUnit(self, quantityAndUnit):
        self.quantityAndUnit = quantityAndUnit
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.quantityAndUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='KPI', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KPI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KPI')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='KPI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='KPI'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='KPI', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.quantityAndUnit is not None:
            self.quantityAndUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='KPI', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if self.quantityAndUnit is not None:
            quantityAndUnit_ = self.quantityAndUnit
            quantityAndUnit_.to_etree(element, name_='quantityAndUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityAndUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <quantityAndUnit> element')
            self.quantityAndUnit = obj_
            obj_.original_tagname_ = 'quantityAndUnit'
# end class KPI


class QuantityAndUnits(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, quantityAndUnit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        if quantityAndUnit is None:
            self.quantityAndUnit = []
        else:
            self.quantityAndUnit = quantityAndUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityAndUnits)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityAndUnits.subclass:
            return QuantityAndUnits.subclass(*args_, **kwargs_)
        else:
            return QuantityAndUnits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantityAndUnit(self):
        return self.quantityAndUnit
    def set_quantityAndUnit(self, quantityAndUnit):
        self.quantityAndUnit = quantityAndUnit
    def add_quantityAndUnit(self, value):
        self.quantityAndUnit.append(value)
    def add_quantityAndUnit(self, value):
        self.quantityAndUnit.append(value)
    def insert_quantityAndUnit_at(self, index, value):
        self.quantityAndUnit.insert(index, value)
    def replace_quantityAndUnit_at(self, index, value):
        self.quantityAndUnit[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.quantityAndUnit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnits', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuantityAndUnits')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityAndUnits')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='QuantityAndUnits', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='QuantityAndUnits'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnits', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for quantityAndUnit_ in self.quantityAndUnit:
            quantityAndUnit_.export(outfile, level, namespaceprefix_, name_='quantityAndUnit', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='QuantityAndUnits', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for quantityAndUnit_ in self.quantityAndUnit:
            quantityAndUnit_.to_etree(element, name_='quantityAndUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantityAndUnit':
            obj_ = QuantityAndUnitType.factory(parent_object_=self)
            obj_.build(child_)
            self.quantityAndUnit.append(obj_)
            obj_.original_tagname_ = 'quantityAndUnit'
# end class QuantityAndUnits


class AbstractQuantityAndUnit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractQuantityAndUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractQuantityAndUnit.subclass:
            return AbstractQuantityAndUnit.subclass(*args_, **kwargs_)
        else:
            return AbstractQuantityAndUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractQuantityAndUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractQuantityAndUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractQuantityAndUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractQuantityAndUnit', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractQuantityAndUnit'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractQuantityAndUnit', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='AbstractQuantityAndUnit', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractQuantityAndUnit


class QuantityAndUnitReference(AbstractQuantityAndUnit):
    subclass = None
    superclass = AbstractQuantityAndUnit
    def __init__(self, reference=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuantityAndUnitReference, self).__init__( **kwargs_)
        self.reference = _cast(None, reference)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityAndUnitReference)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityAndUnitReference.subclass:
            return QuantityAndUnitReference.subclass(*args_, **kwargs_)
        else:
            return QuantityAndUnitReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def hasContent_(self):
        if (
            super(QuantityAndUnitReference, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnitReference', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuantityAndUnitReference')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityAndUnitReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='QuantityAndUnitReference', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='QuantityAndUnitReference'):
        super(QuantityAndUnitReference, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityAndUnitReference')
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnitReference', fromsubclass_=False, pretty_print=True):
        super(QuantityAndUnitReference, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='QuantityAndUnitReference', mapping_=None):
        element = super(QuantityAndUnitReference, self).to_etree(parent_element, name_, mapping_)
        if self.reference is not None:
            element.set('reference', self.gds_format_string(self.reference))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        super(QuantityAndUnitReference, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QuantityAndUnitReference, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QuantityAndUnitReference


class Parameters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, parameterUnit=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = _cast(None, name)
        self.parameterUnit = parameterUnit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Parameters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Parameters.subclass:
            return Parameters.subclass(*args_, **kwargs_)
        else:
            return Parameters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameterUnit(self):
        return self.parameterUnit
    def set_parameterUnit(self, parameterUnit):
        self.parameterUnit = parameterUnit
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.parameterUnit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Parameters', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Parameters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Parameters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Parameters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Parameters'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Parameters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parameterUnit is not None:
            self.parameterUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Parameters', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.parameterUnit is not None:
            parameterUnit_ = self.parameterUnit
            parameterUnit_.to_etree(element, name_='parameterUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameterUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <parameterUnit> element')
            self.parameterUnit = obj_
            obj_.original_tagname_ = 'parameterUnit'
# end class Parameters


class StringParameter(Parameters):
    subclass = None
    superclass = Parameters
    def __init__(self, name=None, parameterUnit=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(StringParameter, self).__init__(name, parameterUnit,  **kwargs_)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StringParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StringParameter.subclass:
            return StringParameter.subclass(*args_, **kwargs_)
        else:
            return StringParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(StringParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='StringParameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StringParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='StringParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='StringParameter'):
        super(StringParameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StringParameter')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='StringParameter', fromsubclass_=False, pretty_print=True):
        super(StringParameter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='StringParameter', mapping_=None):
        element = super(StringParameter, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(StringParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(StringParameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class StringParameter


class DoubleParameter(Parameters):
    subclass = None
    superclass = Parameters
    def __init__(self, name=None, parameterUnit=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DoubleParameter, self).__init__(name, parameterUnit,  **kwargs_)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DoubleParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DoubleParameter.subclass:
            return DoubleParameter.subclass(*args_, **kwargs_)
        else:
            return DoubleParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(DoubleParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DoubleParameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DoubleParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DoubleParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DoubleParameter'):
        super(DoubleParameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DoubleParameter')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DoubleParameter', fromsubclass_=False, pretty_print=True):
        super(DoubleParameter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DoubleParameter', mapping_=None):
        element = super(DoubleParameter, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(DoubleParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DoubleParameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DoubleParameter


class IntegerParameter(Parameters):
    subclass = None
    superclass = Parameters
    def __init__(self, name=None, parameterUnit=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(IntegerParameter, self).__init__(name, parameterUnit,  **kwargs_)
        self.value = _cast(int, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IntegerParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IntegerParameter.subclass:
            return IntegerParameter.subclass(*args_, **kwargs_)
        else:
            return IntegerParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(IntegerParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='IntegerParameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IntegerParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='IntegerParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='IntegerParameter'):
        super(IntegerParameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IntegerParameter')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='IntegerParameter', fromsubclass_=False, pretty_print=True):
        super(IntegerParameter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='IntegerParameter', mapping_=None):
        element = super(IntegerParameter, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_integer(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(IntegerParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IntegerParameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IntegerParameter


class BooleanParameter(Parameters):
    subclass = None
    superclass = Parameters
    def __init__(self, name=None, parameterUnit=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BooleanParameter, self).__init__(name, parameterUnit,  **kwargs_)
        self.value = _cast(bool, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BooleanParameter)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BooleanParameter.subclass:
            return BooleanParameter.subclass(*args_, **kwargs_)
        else:
            return BooleanParameter(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(BooleanParameter, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='BooleanParameter', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BooleanParameter')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanParameter')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='BooleanParameter', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='BooleanParameter'):
        super(BooleanParameter, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BooleanParameter')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_boolean(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='BooleanParameter', fromsubclass_=False, pretty_print=True):
        super(BooleanParameter, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BooleanParameter', mapping_=None):
        element = super(BooleanParameter, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_boolean(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            if value in ('true', '1'):
                self.value = True
            elif value in ('false', '0'):
                self.value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(BooleanParameter, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BooleanParameter, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BooleanParameter


class MeasuresCollection(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, description=None, asset=None, costInformation=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        if asset is None:
            self.asset = []
        else:
            self.asset = asset
        self.costInformation = costInformation
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeasuresCollection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeasuresCollection.subclass:
            return MeasuresCollection.subclass(*args_, **kwargs_)
        else:
            return MeasuresCollection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def add_asset(self, value):
        self.asset.append(value)
    def add_asset_with_type(self, value):
        self.asset.append(value)
        value.original_tagname_ = 'asset'
        value.extensiontype_ = value.__class__.__name__
    def insert_asset_at(self, index, value):
        self.asset.insert(index, value)
    def replace_asset_at(self, index, value):
        self.asset[index] = value
    def get_costInformation(self):
        return self.costInformation
    def set_costInformation(self, costInformation):
        self.costInformation = costInformation
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def hasContent_(self):
        if (
            self.asset or
            self.costInformation is not None or
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MeasuresCollection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeasuresCollection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeasuresCollection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MeasuresCollection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MeasuresCollection'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MeasuresCollection', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asset_ in self.asset:
            asset_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.costInformation is not None:
            self.costInformation.export(outfile, level, namespaceprefix_, name_='costInformation', pretty_print=pretty_print)
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MeasuresCollection', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        for asset_ in self.asset:
            asset_.to_etree(element, name_='asset', mapping_=mapping_)
        if self.costInformation is not None:
            costInformation_ = self.costInformation
            costInformation_.to_etree(element, name_='costInformation', mapping_=mapping_)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <asset> element')
            self.asset.append(obj_)
            obj_.original_tagname_ = 'asset'
        elif nodeName_ == 'costInformation':
            obj_ = CostInformation.factory(parent_object_=self)
            obj_.build(child_)
            self.costInformation = obj_
            obj_.original_tagname_ = 'costInformation'
        elif nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class MeasuresCollection


class Sectors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, sector=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        if sector is None:
            self.sector = []
        else:
            self.sector = sector
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sectors)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sectors.subclass:
            return Sectors.subclass(*args_, **kwargs_)
        else:
            return Sectors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sector(self):
        return self.sector
    def set_sector(self, sector):
        self.sector = sector
    def add_sector(self, value):
        self.sector.append(value)
    def add_sector(self, value):
        self.sector.append(value)
    def insert_sector_at(self, index, value):
        self.sector.insert(index, value)
    def replace_sector_at(self, index, value):
        self.sector[index] = value
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            self.sector or
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Sectors', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sectors')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sectors')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Sectors', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Sectors'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Sectors', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for sector_ in self.sector:
            sector_.export(outfile, level, namespaceprefix_, name_='sector', pretty_print=pretty_print)
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Sectors', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        for sector_ in self.sector:
            sector_.to_etree(element, name_='sector', mapping_=mapping_)
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sector':
            obj_ = Sector.factory(parent_object_=self)
            obj_.build(child_)
            self.sector.append(obj_)
            obj_.original_tagname_ = 'sector'
        elif nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class Sectors


class Sector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, description=None, code=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.code = _cast(None, code)
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Sector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Sector.subclass:
            return Sector.subclass(*args_, **kwargs_)
        else:
            return Sector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataSource(self):
        return self.dataSource
    def set_dataSource(self, dataSource):
        self.dataSource = dataSource
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def hasContent_(self):
        if (
            self.dataSource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Sector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Sector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Sector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Sector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Sector'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.code), input_name='code')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Sector', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dataSource is not None:
            self.dataSource.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Sector', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.code is not None:
            element.set('code', self.gds_format_string(self.code))
        if self.dataSource is not None:
            dataSource_ = self.dataSource
            dataSource_.to_etree(element, name_='dataSource', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dataSource':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <dataSource> element')
            self.dataSource = obj_
            obj_.original_tagname_ = 'dataSource'
# end class Sector


class MultiLine(Geometry):
    subclass = None
    superclass = Geometry
    def __init__(self, line=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(MultiLine, self).__init__( **kwargs_)
        if line is None:
            self.line = []
        else:
            self.line = line
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MultiLine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MultiLine.subclass:
            return MultiLine.subclass(*args_, **kwargs_)
        else:
            return MultiLine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_line(self):
        return self.line
    def set_line(self, line):
        self.line = line
    def add_line(self, value):
        self.line.append(value)
    def add_line(self, value):
        self.line.append(value)
    def insert_line_at(self, index, value):
        self.line.insert(index, value)
    def replace_line_at(self, index, value):
        self.line[index] = value
    def hasContent_(self):
        if (
            self.line or
            super(MultiLine, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MultiLine', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MultiLine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiLine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MultiLine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MultiLine'):
        super(MultiLine, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MultiLine')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MultiLine', fromsubclass_=False, pretty_print=True):
        super(MultiLine, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for line_ in self.line:
            line_.export(outfile, level, namespaceprefix_, name_='line', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MultiLine', mapping_=None):
        element = super(MultiLine, self).to_etree(parent_element, name_, mapping_)
        for line_ in self.line:
            line_.to_etree(element, name_='line', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MultiLine, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'line':
            obj_ = Line.factory(parent_object_=self)
            obj_.build(child_)
            self.line.append(obj_)
            obj_.original_tagname_ = 'line'
        super(MultiLine, self).buildChildren(child_, node, nodeName_, True)
# end class MultiLine


class AbstractGTPotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, geothermalSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractGTPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit, extensiontype_,  **kwargs_)
        self.geothermalSource = _cast(None, geothermalSource)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractGTPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractGTPotential.subclass:
            return AbstractGTPotential.subclass(*args_, **kwargs_)
        else:
            return AbstractGTPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geothermalSource(self):
        return self.geothermalSource
    def set_geothermalSource(self, geothermalSource):
        self.geothermalSource = geothermalSource
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractGTPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractGTPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractGTPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractGTPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractGTPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractGTPotential'):
        super(AbstractGTPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractGTPotential')
        if self.geothermalSource is not None and 'geothermalSource' not in already_processed:
            already_processed.add('geothermalSource')
            outfile.write(' geothermalSource=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geothermalSource), input_name='geothermalSource')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractGTPotential', fromsubclass_=False, pretty_print=True):
        super(AbstractGTPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractGTPotential', mapping_=None):
        element = super(AbstractGTPotential, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.geothermalSource is not None:
            element.set('geothermalSource', self.gds_format_string(self.geothermalSource))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('geothermalSource', node)
        if value is not None and 'geothermalSource' not in already_processed:
            already_processed.add('geothermalSource')
            self.geothermalSource = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractGTPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractGTPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractGTPotential


class UTESPotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, value=None, type_=None, UTES=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(UTESPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
        self.type_ = _cast(None, type_)
        self.UTES = _cast(None, UTES)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UTESPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UTESPotential.subclass:
            return UTESPotential.subclass(*args_, **kwargs_)
        else:
            return UTESPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_UTES(self):
        return self.UTES
    def set_UTES(self, UTES):
        self.UTES = UTES
    def hasContent_(self):
        if (
            super(UTESPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='UTESPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UTESPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UTESPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='UTESPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='UTESPotential'):
        super(UTESPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UTESPotential')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.UTES is not None and 'UTES' not in already_processed:
            already_processed.add('UTES')
            outfile.write(' UTES=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UTES), input_name='UTES')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='UTESPotential', fromsubclass_=False, pretty_print=True):
        super(UTESPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='UTESPotential', mapping_=None):
        element = super(UTESPotential, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.UTES is not None:
            element.set('UTES', self.gds_format_string(self.UTES))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('UTES', node)
        if value is not None and 'UTES' not in already_processed:
            already_processed.add('UTES')
            self.UTES = value
        super(UTESPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UTESPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UTESPotential


class AbstractInstanceDate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractInstanceDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractInstanceDate.subclass:
            return AbstractInstanceDate.subclass(*args_, **kwargs_)
        else:
            return AbstractInstanceDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractInstanceDate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractInstanceDate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractInstanceDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractInstanceDate', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractInstanceDate'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractInstanceDate', fromsubclass_=False, pretty_print=True):
        pass
    def to_etree(self, parent_element=None, name_='AbstractInstanceDate', mapping_=None):
        if parent_element is None:
            element = etree_.Element('{http://www.tno.nl/esdl}' + name_)
        else:
            element = etree_.SubElement(parent_element, '{http://www.tno.nl/esdl}' + name_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AbstractInstanceDate


class InstanceDate(AbstractInstanceDate):
    subclass = None
    superclass = AbstractInstanceDate
    def __init__(self, date=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InstanceDate, self).__init__( **kwargs_)
        self.date = _cast(None, date)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstanceDate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstanceDate.subclass:
            return InstanceDate.subclass(*args_, **kwargs_)
        else:
            return InstanceDate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_date(self):
        return self.date
    def set_date(self, date):
        self.date = date
    def hasContent_(self):
        if (
            super(InstanceDate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='InstanceDate', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstanceDate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstanceDate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='InstanceDate', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='InstanceDate'):
        super(InstanceDate, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstanceDate')
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.date), input_name='date')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='InstanceDate', fromsubclass_=False, pretty_print=True):
        super(InstanceDate, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='InstanceDate', mapping_=None):
        element = super(InstanceDate, self).to_etree(parent_element, name_, mapping_)
        if self.date is not None:
            element.set('date', self.gds_format_string(self.date))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            self.date = value
        super(InstanceDate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstanceDate, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstanceDate


class InstancePeriod(AbstractInstanceDate):
    subclass = None
    superclass = AbstractInstanceDate
    def __init__(self, fromDate=None, toDate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(InstancePeriod, self).__init__( **kwargs_)
        self.fromDate = _cast(None, fromDate)
        self.toDate = _cast(None, toDate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InstancePeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InstancePeriod.subclass:
            return InstancePeriod.subclass(*args_, **kwargs_)
        else:
            return InstancePeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fromDate(self):
        return self.fromDate
    def set_fromDate(self, fromDate):
        self.fromDate = fromDate
    def get_toDate(self):
        return self.toDate
    def set_toDate(self, toDate):
        self.toDate = toDate
    def hasContent_(self):
        if (
            super(InstancePeriod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='InstancePeriod', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InstancePeriod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstancePeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='InstancePeriod', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='InstancePeriod'):
        super(InstancePeriod, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InstancePeriod')
        if self.fromDate is not None and 'fromDate' not in already_processed:
            already_processed.add('fromDate')
            outfile.write(' fromDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.fromDate), input_name='fromDate')), ))
        if self.toDate is not None and 'toDate' not in already_processed:
            already_processed.add('toDate')
            outfile.write(' toDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.toDate), input_name='toDate')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='InstancePeriod', fromsubclass_=False, pretty_print=True):
        super(InstancePeriod, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='InstancePeriod', mapping_=None):
        element = super(InstancePeriod, self).to_etree(parent_element, name_, mapping_)
        if self.fromDate is not None:
            element.set('fromDate', self.gds_format_string(self.fromDate))
        if self.toDate is not None:
            element.set('toDate', self.gds_format_string(self.toDate))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fromDate', node)
        if value is not None and 'fromDate' not in already_processed:
            already_processed.add('fromDate')
            self.fromDate = value
        value = find_attr_value_('toDate', node)
        if value is not None and 'toDate' not in already_processed:
            already_processed.add('toDate')
            self.toDate = value
        super(InstancePeriod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(InstancePeriod, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class InstancePeriod


class BiomassPotential(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, value=0.0, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BiomassPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiomassPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiomassPotential.subclass:
            return BiomassPotential.subclass(*args_, **kwargs_)
        else:
            return BiomassPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(BiomassPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='BiomassPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiomassPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiomassPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='BiomassPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='BiomassPotential'):
        super(BiomassPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiomassPotential')
        if self.value != 0.0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='BiomassPotential', fromsubclass_=False, pretty_print=True):
        super(BiomassPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BiomassPotential', mapping_=None):
        element = super(BiomassPotential, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(BiomassPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BiomassPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BiomassPotential


class WKT(Geometry):
    """Well-Known Text (see https://en.wikipedia.org/wiki/Well-known_text)"""
    subclass = None
    superclass = Geometry
    def __init__(self, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WKT, self).__init__( **kwargs_)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WKT)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WKT.subclass:
            return WKT.subclass(*args_, **kwargs_)
        else:
            return WKT(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(WKT, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WKT', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WKT')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WKT')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WKT', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WKT'):
        super(WKT, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WKT')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WKT', fromsubclass_=False, pretty_print=True):
        super(WKT, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='WKT', mapping_=None):
        element = super(WKT, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(WKT, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WKT, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WKT


class WKB(Geometry):
    """Well-Known Binary (See https://en.wikipedia.org/wiki/Well-
    known_text#Well-known_binary)Base64 encoded WKB value"""
    subclass = None
    superclass = Geometry
    def __init__(self, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WKB, self).__init__( **kwargs_)
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WKB)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WKB.subclass:
            return WKB.subclass(*args_, **kwargs_)
        else:
            return WKB(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(WKB, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WKB', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WKB')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WKB')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WKB', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WKB'):
        super(WKB, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WKB')
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.value), input_name='value')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WKB', fromsubclass_=False, pretty_print=True):
        super(WKB, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='WKB', mapping_=None):
        element = super(WKB, self).to_etree(parent_element, name_, mapping_)
        if self.value is not None:
            element.set('value', self.gds_format_string(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        super(WKB, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WKB, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WKB


class SearchAreaWind(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SearchAreaWind, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SearchAreaWind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SearchAreaWind.subclass:
            return SearchAreaWind.subclass(*args_, **kwargs_)
        else:
            return SearchAreaWind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SearchAreaWind, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SearchAreaWind', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SearchAreaWind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SearchAreaWind')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SearchAreaWind', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SearchAreaWind'):
        super(SearchAreaWind, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SearchAreaWind')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SearchAreaWind', fromsubclass_=False, pretty_print=True):
        super(SearchAreaWind, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SearchAreaWind', mapping_=None):
        element = super(SearchAreaWind, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SearchAreaWind, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SearchAreaWind, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SearchAreaWind


class SearchAreaSolar(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SearchAreaSolar, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SearchAreaSolar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SearchAreaSolar.subclass:
            return SearchAreaSolar.subclass(*args_, **kwargs_)
        else:
            return SearchAreaSolar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SearchAreaSolar, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SearchAreaSolar', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SearchAreaSolar')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SearchAreaSolar')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SearchAreaSolar', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SearchAreaSolar'):
        super(SearchAreaSolar, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SearchAreaSolar')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SearchAreaSolar', fromsubclass_=False, pretty_print=True):
        super(SearchAreaSolar, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SearchAreaSolar', mapping_=None):
        element = super(SearchAreaSolar, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SearchAreaSolar, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SearchAreaSolar, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SearchAreaSolar


class GeothermalEnergyPotential(AbstractGTPotential):
    subclass = None
    superclass = AbstractGTPotential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, geothermalSource=None, depth=None, value=0.0, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GeothermalEnergyPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit, geothermalSource,  **kwargs_)
        self.depth = _cast(int, depth)
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeothermalEnergyPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeothermalEnergyPotential.subclass:
            return GeothermalEnergyPotential.subclass(*args_, **kwargs_)
        else:
            return GeothermalEnergyPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_depth(self):
        return self.depth
    def set_depth(self, depth):
        self.depth = depth
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            super(GeothermalEnergyPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalEnergyPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeothermalEnergyPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalEnergyPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GeothermalEnergyPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GeothermalEnergyPotential'):
        super(GeothermalEnergyPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalEnergyPotential')
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.add('depth')
            outfile.write(' depth="%s"' % self.gds_format_integer(self.depth, input_name='depth'))
        if self.value != 0.0 and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalEnergyPotential', fromsubclass_=False, pretty_print=True):
        super(GeothermalEnergyPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeothermalEnergyPotential', mapping_=None):
        element = super(GeothermalEnergyPotential, self).to_etree(parent_element, name_, mapping_)
        if self.depth is not None:
            element.set('depth', self.gds_format_integer(self.depth))
        if self.value is not None:
            element.set('value', self.gds_format_double(self.value))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('depth', node)
        if value is not None and 'depth' not in already_processed:
            already_processed.add('depth')
            try:
                self.depth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        super(GeothermalEnergyPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GeothermalEnergyPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GeothermalEnergyPotential


class QuantityAndUnitType(AbstractQuantityAndUnit):
    subclass = None
    superclass = AbstractQuantityAndUnit
    def __init__(self, physicalQuantity=None, multiplier=None, unit=None, perMultiplier=None, perUnit=None, description=None, perTimeUnit=None, id=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(QuantityAndUnitType, self).__init__( **kwargs_)
        self.physicalQuantity = _cast(None, physicalQuantity)
        self.multiplier = _cast(None, multiplier)
        self.unit = _cast(None, unit)
        self.perMultiplier = _cast(None, perMultiplier)
        self.perUnit = _cast(None, perUnit)
        self.description = _cast(None, description)
        self.perTimeUnit = _cast(None, perTimeUnit)
        self.id = _cast(None, id)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, QuantityAndUnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if QuantityAndUnitType.subclass:
            return QuantityAndUnitType.subclass(*args_, **kwargs_)
        else:
            return QuantityAndUnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_physicalQuantity(self):
        return self.physicalQuantity
    def set_physicalQuantity(self, physicalQuantity):
        self.physicalQuantity = physicalQuantity
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_perMultiplier(self):
        return self.perMultiplier
    def set_perMultiplier(self, perMultiplier):
        self.perMultiplier = perMultiplier
    def get_perUnit(self):
        return self.perUnit
    def set_perUnit(self, perUnit):
        self.perUnit = perUnit
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_perTimeUnit(self):
        return self.perTimeUnit
    def set_perTimeUnit(self, perTimeUnit):
        self.perTimeUnit = perTimeUnit
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            super(QuantityAndUnitType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnitType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('QuantityAndUnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityAndUnitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='QuantityAndUnitType', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='QuantityAndUnitType'):
        super(QuantityAndUnitType, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='QuantityAndUnitType')
        if self.physicalQuantity is not None and 'physicalQuantity' not in already_processed:
            already_processed.add('physicalQuantity')
            outfile.write(' physicalQuantity=%s' % (quote_attrib(self.physicalQuantity), ))
        if self.multiplier is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.perMultiplier is not None and 'perMultiplier' not in already_processed:
            already_processed.add('perMultiplier')
            outfile.write(' perMultiplier=%s' % (quote_attrib(self.perMultiplier), ))
        if self.perUnit is not None and 'perUnit' not in already_processed:
            already_processed.add('perUnit')
            outfile.write(' perUnit=%s' % (quote_attrib(self.perUnit), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.perTimeUnit is not None and 'perTimeUnit' not in already_processed:
            already_processed.add('perTimeUnit')
            outfile.write(' perTimeUnit=%s' % (quote_attrib(self.perTimeUnit), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='QuantityAndUnitType', fromsubclass_=False, pretty_print=True):
        super(QuantityAndUnitType, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='QuantityAndUnitType', mapping_=None):
        element = super(QuantityAndUnitType, self).to_etree(parent_element, name_, mapping_)
        if self.physicalQuantity is not None:
            element.set('physicalQuantity', self.physicalQuantity)
        if self.multiplier is not None:
            element.set('multiplier', self.multiplier)
        if self.unit is not None:
            element.set('unit', self.unit)
        if self.perMultiplier is not None:
            element.set('perMultiplier', self.perMultiplier)
        if self.perUnit is not None:
            element.set('perUnit', self.perUnit)
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.perTimeUnit is not None:
            element.set('perTimeUnit', self.perTimeUnit)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('physicalQuantity', node)
        if value is not None and 'physicalQuantity' not in already_processed:
            already_processed.add('physicalQuantity')
            self.physicalQuantity = value
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
        value = find_attr_value_('perMultiplier', node)
        if value is not None and 'perMultiplier' not in already_processed:
            already_processed.add('perMultiplier')
            self.perMultiplier = value
        value = find_attr_value_('perUnit', node)
        if value is not None and 'perUnit' not in already_processed:
            already_processed.add('perUnit')
            self.perUnit = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('perTimeUnit', node)
        if value is not None and 'perTimeUnit' not in already_processed:
            already_processed.add('perTimeUnit')
            self.perTimeUnit = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(QuantityAndUnitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QuantityAndUnitType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QuantityAndUnitType


class DataSource(AbstractDataSource):
    subclass = None
    superclass = AbstractDataSource
    def __init__(self, id=None, name=None, description=None, reference=None, attribution=None, releaseDate=None, version=None, licence=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DataSource, self).__init__( **kwargs_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        self.reference = _cast(None, reference)
        self.attribution = _cast(None, attribution)
        self.releaseDate = _cast(None, releaseDate)
        self.version = _cast(None, version)
        self.licence = _cast(None, licence)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataSource.subclass:
            return DataSource.subclass(*args_, **kwargs_)
        else:
            return DataSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_reference(self):
        return self.reference
    def set_reference(self, reference):
        self.reference = reference
    def get_attribution(self):
        return self.attribution
    def set_attribution(self, attribution):
        self.attribution = attribution
    def get_releaseDate(self):
        return self.releaseDate
    def set_releaseDate(self, releaseDate):
        self.releaseDate = releaseDate
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_licence(self):
        return self.licence
    def set_licence(self, licence):
        self.licence = licence
    def hasContent_(self):
        if (
            super(DataSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DataSource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataSource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DataSource', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DataSource'):
        super(DataSource, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataSource')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.reference is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            outfile.write(' reference=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.reference), input_name='reference')), ))
        if self.attribution is not None and 'attribution' not in already_processed:
            already_processed.add('attribution')
            outfile.write(' attribution=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.attribution), input_name='attribution')), ))
        if self.releaseDate is not None and 'releaseDate' not in already_processed:
            already_processed.add('releaseDate')
            outfile.write(' releaseDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.releaseDate), input_name='releaseDate')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.licence is not None and 'licence' not in already_processed:
            already_processed.add('licence')
            outfile.write(' licence=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.licence), input_name='licence')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DataSource', fromsubclass_=False, pretty_print=True):
        super(DataSource, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='DataSource', mapping_=None):
        element = super(DataSource, self).to_etree(parent_element, name_, mapping_)
        if self.id is not None:
            element.set('id', self.gds_format_string(self.id))
        if self.name is not None:
            element.set('name', self.gds_format_string(self.name))
        if self.description is not None:
            element.set('description', self.gds_format_string(self.description))
        if self.reference is not None:
            element.set('reference', self.gds_format_string(self.reference))
        if self.attribution is not None:
            element.set('attribution', self.gds_format_string(self.attribution))
        if self.releaseDate is not None:
            element.set('releaseDate', self.gds_format_string(self.releaseDate))
        if self.version is not None:
            element.set('version', self.gds_format_string(self.version))
        if self.licence is not None:
            element.set('licence', self.gds_format_string(self.licence))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
        value = find_attr_value_('reference', node)
        if value is not None and 'reference' not in already_processed:
            already_processed.add('reference')
            self.reference = value
        value = find_attr_value_('attribution', node)
        if value is not None and 'attribution' not in already_processed:
            already_processed.add('attribution')
            self.attribution = value
        value = find_attr_value_('releaseDate', node)
        if value is not None and 'releaseDate' not in already_processed:
            already_processed.add('releaseDate')
            self.releaseDate = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('licence', node)
        if value is not None and 'licence' not in already_processed:
            already_processed.add('licence')
            self.licence = value
        super(DataSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DataSource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DataSource


class Commodity(Carrier):
    subclass = None
    superclass = Carrier
    def __init__(self, name=None, id=None, cost=None, dataSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Commodity, self).__init__(name, id, cost, dataSource, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Commodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Commodity.subclass:
            return Commodity.subclass(*args_, **kwargs_)
        else:
            return Commodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Commodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Commodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Commodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Commodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Commodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Commodity'):
        super(Commodity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Commodity')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Commodity', fromsubclass_=False, pretty_print=True):
        super(Commodity, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Commodity', mapping_=None):
        element = super(Commodity, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Commodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Commodity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Commodity


class Line(Geometry):
    subclass = None
    superclass = Geometry
    def __init__(self, point=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Line, self).__init__( **kwargs_)
        if point is None:
            self.point = []
        else:
            self.point = point
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Line)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Line.subclass:
            return Line.subclass(*args_, **kwargs_)
        else:
            return Line(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_point(self):
        return self.point
    def set_point(self, point):
        self.point = point
    def add_point(self, value):
        self.point.append(value)
    def add_point(self, value):
        self.point.append(value)
    def insert_point_at(self, index, value):
        self.point.insert(index, value)
    def replace_point_at(self, index, value):
        self.point[index] = value
    def hasContent_(self):
        if (
            self.point or
            super(Line, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Line', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Line')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Line')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Line', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Line'):
        super(Line, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Line')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Line', fromsubclass_=False, pretty_print=True):
        super(Line, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for point_ in self.point:
            point_.export(outfile, level, namespaceprefix_, name_='point', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Line', mapping_=None):
        element = super(Line, self).to_etree(parent_element, name_, mapping_)
        for point_ in self.point:
            point_.to_etree(element, name_='point', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Line, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'point':
            obj_ = Point.factory(parent_object_=self)
            obj_.build(child_)
            self.point.append(obj_)
            obj_.original_tagname_ = 'point'
        super(Line, self).buildChildren(child_, node, nodeName_, True)
# end class Line


class EnergyCarrier(Carrier):
    subclass = None
    superclass = Carrier
    def __init__(self, name=None, id=None, cost=None, dataSource=None, energyContent=0.0, emission=0.0, energyCarrierType=None, stateOfMatter=None, energyContentUnit=None, emissionUnit=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyCarrier, self).__init__(name, id, cost, dataSource,  **kwargs_)
        self.energyContent = _cast(float, energyContent)
        self.emission = _cast(float, emission)
        self.energyCarrierType = _cast(None, energyCarrierType)
        self.stateOfMatter = _cast(None, stateOfMatter)
        self.energyContentUnit = energyContentUnit
        self.emissionUnit = emissionUnit
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCarrier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCarrier.subclass:
            return EnergyCarrier.subclass(*args_, **kwargs_)
        else:
            return EnergyCarrier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyContentUnit(self):
        return self.energyContentUnit
    def set_energyContentUnit(self, energyContentUnit):
        self.energyContentUnit = energyContentUnit
    def get_emissionUnit(self):
        return self.emissionUnit
    def set_emissionUnit(self, emissionUnit):
        self.emissionUnit = emissionUnit
    def get_energyContent(self):
        return self.energyContent
    def set_energyContent(self, energyContent):
        self.energyContent = energyContent
    def get_emission(self):
        return self.emission
    def set_emission(self, emission):
        self.emission = emission
    def get_energyCarrierType(self):
        return self.energyCarrierType
    def set_energyCarrierType(self, energyCarrierType):
        self.energyCarrierType = energyCarrierType
    def get_stateOfMatter(self):
        return self.stateOfMatter
    def set_stateOfMatter(self, stateOfMatter):
        self.stateOfMatter = stateOfMatter
    def hasContent_(self):
        if (
            self.energyContentUnit is not None or
            self.emissionUnit is not None or
            super(EnergyCarrier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyCarrier', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyCarrier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyCarrier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyCarrier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyCarrier'):
        super(EnergyCarrier, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyCarrier')
        if self.energyContent != 0.0 and 'energyContent' not in already_processed:
            already_processed.add('energyContent')
            outfile.write(' energyContent="%s"' % self.gds_format_double(self.energyContent, input_name='energyContent'))
        if self.emission != 0.0 and 'emission' not in already_processed:
            already_processed.add('emission')
            outfile.write(' emission="%s"' % self.gds_format_double(self.emission, input_name='emission'))
        if self.energyCarrierType is not None and 'energyCarrierType' not in already_processed:
            already_processed.add('energyCarrierType')
            outfile.write(' energyCarrierType=%s' % (quote_attrib(self.energyCarrierType), ))
        if self.stateOfMatter is not None and 'stateOfMatter' not in already_processed:
            already_processed.add('stateOfMatter')
            outfile.write(' stateOfMatter=%s' % (quote_attrib(self.stateOfMatter), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyCarrier', fromsubclass_=False, pretty_print=True):
        super(EnergyCarrier, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyContentUnit is not None:
            self.energyContentUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.emissionUnit is not None:
            self.emissionUnit.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyCarrier', mapping_=None):
        element = super(EnergyCarrier, self).to_etree(parent_element, name_, mapping_)
        if self.energyContent is not None:
            element.set('energyContent', self.gds_format_double(self.energyContent))
        if self.emission is not None:
            element.set('emission', self.gds_format_double(self.emission))
        if self.energyCarrierType is not None:
            element.set('energyCarrierType', self.energyCarrierType)
        if self.stateOfMatter is not None:
            element.set('stateOfMatter', self.stateOfMatter)
        if self.energyContentUnit is not None:
            energyContentUnit_ = self.energyContentUnit
            energyContentUnit_.to_etree(element, name_='energyContentUnit', mapping_=mapping_)
        if self.emissionUnit is not None:
            emissionUnit_ = self.emissionUnit
            emissionUnit_.to_etree(element, name_='emissionUnit', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('energyContent', node)
        if value is not None and 'energyContent' not in already_processed:
            already_processed.add('energyContent')
            try:
                self.energyContent = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (energyContent): %s' % exp)
        value = find_attr_value_('emission', node)
        if value is not None and 'emission' not in already_processed:
            already_processed.add('emission')
            try:
                self.emission = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (emission): %s' % exp)
        value = find_attr_value_('energyCarrierType', node)
        if value is not None and 'energyCarrierType' not in already_processed:
            already_processed.add('energyCarrierType')
            self.energyCarrierType = value
        value = find_attr_value_('stateOfMatter', node)
        if value is not None and 'stateOfMatter' not in already_processed:
            already_processed.add('stateOfMatter')
            self.stateOfMatter = value
        super(EnergyCarrier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energyContentUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <energyContentUnit> element')
            self.energyContentUnit = obj_
            obj_.original_tagname_ = 'energyContentUnit'
        elif nodeName_ == 'emissionUnit':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <emissionUnit> element')
            self.emissionUnit = obj_
            obj_.original_tagname_ = 'emissionUnit'
        super(EnergyCarrier, self).buildChildren(child_, node, nodeName_, True)
# end class EnergyCarrier


class EnergyService(Service):
    subclass = None
    superclass = Service
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyService, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyService.subclass:
            return EnergyService.subclass(*args_, **kwargs_)
        else:
            return EnergyService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(EnergyService, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyService', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyService', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyService'):
        super(EnergyService, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyService')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyService', fromsubclass_=False, pretty_print=True):
        super(EnergyService, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyService', mapping_=None):
        element = super(EnergyService, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EnergyService, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EnergyService, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EnergyService


class LegalArea(Potential):
    subclass = None
    superclass = Potential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, purpose=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(LegalArea, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit,  **kwargs_)
        self.purpose = _cast(None, purpose)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LegalArea)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LegalArea.subclass:
            return LegalArea.subclass(*args_, **kwargs_)
        else:
            return LegalArea(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_purpose(self):
        return self.purpose
    def set_purpose(self, purpose):
        self.purpose = purpose
    def hasContent_(self):
        if (
            super(LegalArea, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='LegalArea', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LegalArea')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LegalArea')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='LegalArea', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='LegalArea'):
        super(LegalArea, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LegalArea')
        if self.purpose is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            outfile.write(' purpose=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.purpose), input_name='purpose')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='LegalArea', fromsubclass_=False, pretty_print=True):
        super(LegalArea, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='LegalArea', mapping_=None):
        element = super(LegalArea, self).to_etree(parent_element, name_, mapping_)
        if self.purpose is not None:
            element.set('purpose', self.gds_format_string(self.purpose))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('purpose', node)
        if value is not None and 'purpose' not in already_processed:
            already_processed.add('purpose')
            self.purpose = value
        super(LegalArea, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LegalArea, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LegalArea


class Polygon(Geometry):
    subclass = None
    superclass = Geometry
    def __init__(self, exterior=None, interior=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Polygon, self).__init__( **kwargs_)
        self.exterior = exterior
        if interior is None:
            self.interior = []
        else:
            self.interior = interior
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Polygon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Polygon.subclass:
            return Polygon.subclass(*args_, **kwargs_)
        else:
            return Polygon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exterior(self):
        return self.exterior
    def set_exterior(self, exterior):
        self.exterior = exterior
    def get_interior(self):
        return self.interior
    def set_interior(self, interior):
        self.interior = interior
    def add_interior(self, value):
        self.interior.append(value)
    def add_interior(self, value):
        self.interior.append(value)
    def insert_interior_at(self, index, value):
        self.interior.insert(index, value)
    def replace_interior_at(self, index, value):
        self.interior[index] = value
    def hasContent_(self):
        if (
            self.exterior is not None or
            self.interior or
            super(Polygon, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Polygon', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Polygon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Polygon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Polygon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Polygon'):
        super(Polygon, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Polygon')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Polygon', fromsubclass_=False, pretty_print=True):
        super(Polygon, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.exterior is not None:
            self.exterior.export(outfile, level, namespaceprefix_, name_='exterior', pretty_print=pretty_print)
        for interior_ in self.interior:
            interior_.export(outfile, level, namespaceprefix_, name_='interior', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Polygon', mapping_=None):
        element = super(Polygon, self).to_etree(parent_element, name_, mapping_)
        if self.exterior is not None:
            exterior_ = self.exterior
            exterior_.to_etree(element, name_='exterior', mapping_=mapping_)
        for interior_ in self.interior:
            interior_.to_etree(element, name_='interior', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Polygon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exterior':
            obj_ = SubPolygon.factory(parent_object_=self)
            obj_.build(child_)
            self.exterior = obj_
            obj_.original_tagname_ = 'exterior'
        elif nodeName_ == 'interior':
            obj_ = SubPolygon.factory(parent_object_=self)
            obj_.build(child_)
            self.interior.append(obj_)
            obj_.original_tagname_ = 'interior'
        super(Polygon, self).buildChildren(child_, node, nodeName_, True)
# end class Polygon


class Point(Geometry):
    subclass = None
    superclass = Geometry
    def __init__(self, lat=None, lon=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Point, self).__init__( **kwargs_)
        self.lat = _cast(float, lat)
        self.lon = _cast(float, lon)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Point)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Point.subclass:
            return Point.subclass(*args_, **kwargs_)
        else:
            return Point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lat(self):
        return self.lat
    def set_lat(self, lat):
        self.lat = lat
    def get_lon(self):
        return self.lon
    def set_lon(self, lon):
        self.lon = lon
    def hasContent_(self):
        if (
            super(Point, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Point', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Point')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Point')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Point', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Point'):
        super(Point, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Point')
        if self.lat is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            outfile.write(' lat="%s"' % self.gds_format_double(self.lat, input_name='lat'))
        if self.lon is not None and 'lon' not in already_processed:
            already_processed.add('lon')
            outfile.write(' lon="%s"' % self.gds_format_double(self.lon, input_name='lon'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Point', fromsubclass_=False, pretty_print=True):
        super(Point, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='Point', mapping_=None):
        element = super(Point, self).to_etree(parent_element, name_, mapping_)
        if self.lat is not None:
            element.set('lat', self.gds_format_double(self.lat))
        if self.lon is not None:
            element.set('lon', self.gds_format_double(self.lon))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lat', node)
        if value is not None and 'lat' not in already_processed:
            already_processed.add('lat')
            try:
                self.lat = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lat): %s' % exp)
        value = find_attr_value_('lon', node)
        if value is not None and 'lon' not in already_processed:
            already_processed.add('lon')
            try:
                self.lon = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (lon): %s' % exp)
        super(Point, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Point, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Point


class GeothermalPotential(AbstractGTPotential):
    subclass = None
    superclass = AbstractGTPotential
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, geometryReference=None, aggregated=False, aggregationCount=1, geometry=None, quantityAndUnit=None, geothermalSource=None, temperature=None, depth=None, potential=None, powerPerDoublet='UNKNOWN', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GeothermalPotential, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, geometryReference, aggregated, aggregationCount, geometry, quantityAndUnit, geothermalSource,  **kwargs_)
        self.temperature = _cast(int, temperature)
        self.depth = _cast(int, depth)
        self.potential = _cast(None, potential)
        self.powerPerDoublet = _cast(None, powerPerDoublet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeothermalPotential)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeothermalPotential.subclass:
            return GeothermalPotential.subclass(*args_, **kwargs_)
        else:
            return GeothermalPotential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temperature(self):
        return self.temperature
    def set_temperature(self, temperature):
        self.temperature = temperature
    def get_depth(self):
        return self.depth
    def set_depth(self, depth):
        self.depth = depth
    def get_potential(self):
        return self.potential
    def set_potential(self, potential):
        self.potential = potential
    def get_powerPerDoublet(self):
        return self.powerPerDoublet
    def set_powerPerDoublet(self, powerPerDoublet):
        self.powerPerDoublet = powerPerDoublet
    def hasContent_(self):
        if (
            super(GeothermalPotential, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalPotential', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeothermalPotential')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalPotential')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GeothermalPotential', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GeothermalPotential'):
        super(GeothermalPotential, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalPotential')
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            outfile.write(' temperature="%s"' % self.gds_format_integer(self.temperature, input_name='temperature'))
        if self.depth is not None and 'depth' not in already_processed:
            already_processed.add('depth')
            outfile.write(' depth="%s"' % self.gds_format_integer(self.depth, input_name='depth'))
        if self.potential is not None and 'potential' not in already_processed:
            already_processed.add('potential')
            outfile.write(' potential=%s' % (quote_attrib(self.potential), ))
        if self.powerPerDoublet != "UNKNOWN" and 'powerPerDoublet' not in already_processed:
            already_processed.add('powerPerDoublet')
            outfile.write(' powerPerDoublet=%s' % (quote_attrib(self.powerPerDoublet), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalPotential', fromsubclass_=False, pretty_print=True):
        super(GeothermalPotential, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeothermalPotential', mapping_=None):
        element = super(GeothermalPotential, self).to_etree(parent_element, name_, mapping_)
        if self.temperature is not None:
            element.set('temperature', self.gds_format_integer(self.temperature))
        if self.depth is not None:
            element.set('depth', self.gds_format_integer(self.depth))
        if self.potential is not None:
            element.set('potential', self.potential)
        if self.powerPerDoublet is not None:
            element.set('powerPerDoublet', self.powerPerDoublet)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            try:
                self.temperature = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('depth', node)
        if value is not None and 'depth' not in already_processed:
            already_processed.add('depth')
            try:
                self.depth = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('potential', node)
        if value is not None and 'potential' not in already_processed:
            already_processed.add('potential')
            self.potential = value
        value = find_attr_value_('powerPerDoublet', node)
        if value is not None and 'powerPerDoublet' not in already_processed:
            already_processed.add('powerPerDoublet')
            self.powerPerDoublet = value
        super(GeothermalPotential, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GeothermalPotential, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GeothermalPotential


class Asset(Item):
    subclass = None
    superclass = Item
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Asset, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, extensiontype_,  **kwargs_)
        self.surfaceArea = _cast(int, surfaceArea)
        self.commissioningDate = _cast(None, commissioningDate)
        self.decommissioningDate = _cast(None, decommissioningDate)
        self.owner = _cast(None, owner)
        self.technicalLifetime = _cast(float, technicalLifetime)
        self.aggregated = _cast(bool, aggregated)
        self.aggregationCount = _cast(int, aggregationCount)
        self.area = _cast(None, area)
        self.containingBuilding = _cast(None, containingBuilding)
        self.geometry = geometry
        self.costInformation = costInformation
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Asset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Asset.subclass:
            return Asset.subclass(*args_, **kwargs_)
        else:
            return Asset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geometry(self):
        return self.geometry
    def set_geometry(self, geometry):
        self.geometry = geometry
    def set_geometry_with_type(self, geometry):
        self.geometry = geometry
        geometry.original_tagname_ = 'geometry'
        geometry.extensiontype_ = geometry.__class__.__name__
    def get_costInformation(self):
        return self.costInformation
    def set_costInformation(self, costInformation):
        self.costInformation = costInformation
    def get_surfaceArea(self):
        return self.surfaceArea
    def set_surfaceArea(self, surfaceArea):
        self.surfaceArea = surfaceArea
    def get_commissioningDate(self):
        return self.commissioningDate
    def set_commissioningDate(self, commissioningDate):
        self.commissioningDate = commissioningDate
    def get_decommissioningDate(self):
        return self.decommissioningDate
    def set_decommissioningDate(self, decommissioningDate):
        self.decommissioningDate = decommissioningDate
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    def get_technicalLifetime(self):
        return self.technicalLifetime
    def set_technicalLifetime(self, technicalLifetime):
        self.technicalLifetime = technicalLifetime
    def get_aggregated(self):
        return self.aggregated
    def set_aggregated(self, aggregated):
        self.aggregated = aggregated
    def get_aggregationCount(self):
        return self.aggregationCount
    def set_aggregationCount(self, aggregationCount):
        self.aggregationCount = aggregationCount
    def get_area(self):
        return self.area
    def set_area(self, area):
        self.area = area
    def get_containingBuilding(self):
        return self.containingBuilding
    def set_containingBuilding(self, containingBuilding):
        self.containingBuilding = containingBuilding
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.geometry is not None or
            self.costInformation is not None or
            super(Asset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Asset', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Asset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Asset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Asset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Asset'):
        super(Asset, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Asset')
        if self.surfaceArea is not None and 'surfaceArea' not in already_processed:
            already_processed.add('surfaceArea')
            outfile.write(' surfaceArea="%s"' % self.gds_format_integer(self.surfaceArea, input_name='surfaceArea'))
        if self.commissioningDate is not None and 'commissioningDate' not in already_processed:
            already_processed.add('commissioningDate')
            outfile.write(' commissioningDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.commissioningDate), input_name='commissioningDate')), ))
        if self.decommissioningDate is not None and 'decommissioningDate' not in already_processed:
            already_processed.add('decommissioningDate')
            outfile.write(' decommissioningDate=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.decommissioningDate), input_name='decommissioningDate')), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.owner), input_name='owner')), ))
        if self.technicalLifetime is not None and 'technicalLifetime' not in already_processed:
            already_processed.add('technicalLifetime')
            outfile.write(' technicalLifetime="%s"' % self.gds_format_double(self.technicalLifetime, input_name='technicalLifetime'))
        if self.aggregated is not None and 'aggregated' not in already_processed:
            already_processed.add('aggregated')
            outfile.write(' aggregated="%s"' % self.gds_format_boolean(self.aggregated, input_name='aggregated'))
        if self.aggregationCount != 1 and 'aggregationCount' not in already_processed:
            already_processed.add('aggregationCount')
            outfile.write(' aggregationCount="%s"' % self.gds_format_integer(self.aggregationCount, input_name='aggregationCount'))
        if self.area is not None and 'area' not in already_processed:
            already_processed.add('area')
            outfile.write(' area=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.area), input_name='area')), ))
        if self.containingBuilding is not None and 'containingBuilding' not in already_processed:
            already_processed.add('containingBuilding')
            outfile.write(' containingBuilding=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.containingBuilding), input_name='containingBuilding')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Asset', fromsubclass_=False, pretty_print=True):
        super(Asset, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
        if self.costInformation is not None:
            self.costInformation.export(outfile, level, namespaceprefix_, name_='costInformation', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Asset', mapping_=None):
        element = super(Asset, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.surfaceArea is not None:
            element.set('surfaceArea', self.gds_format_integer(self.surfaceArea))
        if self.commissioningDate is not None:
            element.set('commissioningDate', self.gds_format_string(self.commissioningDate))
        if self.decommissioningDate is not None:
            element.set('decommissioningDate', self.gds_format_string(self.decommissioningDate))
        if self.owner is not None:
            element.set('owner', self.gds_format_string(self.owner))
        if self.technicalLifetime is not None:
            element.set('technicalLifetime', self.gds_format_double(self.technicalLifetime))
        if self.aggregated is not None:
            element.set('aggregated', self.gds_format_boolean(self.aggregated))
        if self.aggregationCount is not None:
            element.set('aggregationCount', self.gds_format_integer(self.aggregationCount))
        if self.area is not None:
            element.set('area', self.gds_format_string(self.area))
        if self.containingBuilding is not None:
            element.set('containingBuilding', self.gds_format_string(self.containingBuilding))
        if self.geometry is not None:
            geometry_ = self.geometry
            geometry_.to_etree(element, name_='geometry', mapping_=mapping_)
        if self.costInformation is not None:
            costInformation_ = self.costInformation
            costInformation_.to_etree(element, name_='costInformation', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('surfaceArea', node)
        if value is not None and 'surfaceArea' not in already_processed:
            already_processed.add('surfaceArea')
            try:
                self.surfaceArea = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('commissioningDate', node)
        if value is not None and 'commissioningDate' not in already_processed:
            already_processed.add('commissioningDate')
            self.commissioningDate = value
        value = find_attr_value_('decommissioningDate', node)
        if value is not None and 'decommissioningDate' not in already_processed:
            already_processed.add('decommissioningDate')
            self.decommissioningDate = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('technicalLifetime', node)
        if value is not None and 'technicalLifetime' not in already_processed:
            already_processed.add('technicalLifetime')
            try:
                self.technicalLifetime = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (technicalLifetime): %s' % exp)
        value = find_attr_value_('aggregated', node)
        if value is not None and 'aggregated' not in already_processed:
            already_processed.add('aggregated')
            if value in ('true', '1'):
                self.aggregated = True
            elif value in ('false', '0'):
                self.aggregated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('aggregationCount', node)
        if value is not None and 'aggregationCount' not in already_processed:
            already_processed.add('aggregationCount')
            try:
                self.aggregationCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('area', node)
        if value is not None and 'area' not in already_processed:
            already_processed.add('area')
            self.area = value
        value = find_attr_value_('containingBuilding', node)
        if value is not None and 'containingBuilding' not in already_processed:
            already_processed.add('containingBuilding')
            self.containingBuilding = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Asset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometry':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <geometry> element')
            self.geometry = obj_
            obj_.original_tagname_ = 'geometry'
        elif nodeName_ == 'costInformation':
            obj_ = CostInformation.factory(parent_object_=self)
            obj_.build(child_)
            self.costInformation = obj_
            obj_.original_tagname_ = 'costInformation'
        super(Asset, self).buildChildren(child_, node, nodeName_, True)
# end class Asset


class EnergyAsset(Asset):
    subclass = None
    superclass = Asset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyAsset, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, extensiontype_,  **kwargs_)
        self.controlStrategy = _cast(None, controlStrategy)
        if port is None:
            self.port = []
        else:
            self.port = port
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyAsset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyAsset.subclass:
            return EnergyAsset.subclass(*args_, **kwargs_)
        else:
            return EnergyAsset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_port(self):
        return self.port
    def set_port(self, port):
        self.port = port
    def add_port(self, value):
        self.port.append(value)
    def add_port_with_type(self, value):
        self.port.append(value)
        value.original_tagname_ = 'port'
        value.extensiontype_ = value.__class__.__name__
    def insert_port_at(self, index, value):
        self.port.insert(index, value)
    def replace_port_at(self, index, value):
        self.port[index] = value
    def get_controlStrategy(self):
        return self.controlStrategy
    def set_controlStrategy(self, controlStrategy):
        self.controlStrategy = controlStrategy
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.port or
            super(EnergyAsset, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyAsset', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyAsset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyAsset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyAsset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyAsset'):
        super(EnergyAsset, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyAsset')
        if self.controlStrategy is not None and 'controlStrategy' not in already_processed:
            already_processed.add('controlStrategy')
            outfile.write(' controlStrategy=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.controlStrategy), input_name='controlStrategy')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyAsset', fromsubclass_=False, pretty_print=True):
        super(EnergyAsset, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for port_ in self.port:
            port_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyAsset', mapping_=None):
        element = super(EnergyAsset, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.controlStrategy is not None:
            element.set('controlStrategy', self.gds_format_string(self.controlStrategy))
        for port_ in self.port:
            port_.to_etree(element, name_='port', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('controlStrategy', node)
        if value is not None and 'controlStrategy' not in already_processed:
            already_processed.add('controlStrategy')
            self.controlStrategy = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EnergyAsset, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'port':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <port> element')
            self.port.append(obj_)
            obj_.original_tagname_ = 'port'
        super(EnergyAsset, self).buildChildren(child_, node, nodeName_, True)
# end class EnergyAsset


class Glass(Asset):
    subclass = None
    superclass = Asset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, uWindow=None, glasType='UNDEFINED', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Glass, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation,  **kwargs_)
        self.uWindow = _cast(float, uWindow)
        self.glasType = _cast(None, glasType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Glass)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Glass.subclass:
            return Glass.subclass(*args_, **kwargs_)
        else:
            return Glass(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uWindow(self):
        return self.uWindow
    def set_uWindow(self, uWindow):
        self.uWindow = uWindow
    def get_glasType(self):
        return self.glasType
    def set_glasType(self, glasType):
        self.glasType = glasType
    def hasContent_(self):
        if (
            super(Glass, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Glass', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Glass')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Glass')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Glass', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Glass'):
        super(Glass, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Glass')
        if self.uWindow is not None and 'uWindow' not in already_processed:
            already_processed.add('uWindow')
            outfile.write(' uWindow="%s"' % self.gds_format_double(self.uWindow, input_name='uWindow'))
        if self.glasType != "UNDEFINED" and 'glasType' not in already_processed:
            already_processed.add('glasType')
            outfile.write(' glasType=%s' % (quote_attrib(self.glasType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Glass', fromsubclass_=False, pretty_print=True):
        super(Glass, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Glass', mapping_=None):
        element = super(Glass, self).to_etree(parent_element, name_, mapping_)
        if self.uWindow is not None:
            element.set('uWindow', self.gds_format_double(self.uWindow))
        if self.glasType is not None:
            element.set('glasType', self.glasType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uWindow', node)
        if value is not None and 'uWindow' not in already_processed:
            already_processed.add('uWindow')
            try:
                self.uWindow = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (uWindow): %s' % exp)
        value = find_attr_value_('glasType', node)
        if value is not None and 'glasType' not in already_processed:
            already_processed.add('glasType')
            self.glasType = value
        super(Glass, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Glass, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Glass


class EnergyMarket(EnergyService):
    subclass = None
    superclass = EnergyService
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, asset=None, carrier=None, parameters=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyMarket, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource,  **kwargs_)
        self.asset = _cast(None, asset)
        self.carrier = _cast(None, carrier)
        if parameters is None:
            self.parameters = []
        else:
            self.parameters = parameters
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyMarket)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyMarket.subclass:
            return EnergyMarket.subclass(*args_, **kwargs_)
        else:
            return EnergyMarket(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parameters(self):
        return self.parameters
    def set_parameters(self, parameters):
        self.parameters = parameters
    def add_parameters(self, value):
        self.parameters.append(value)
    def add_parameters_with_type(self, value):
        self.parameters.append(value)
        value.original_tagname_ = 'parameters'
        value.extensiontype_ = value.__class__.__name__
    def insert_parameters_at(self, index, value):
        self.parameters.insert(index, value)
    def replace_parameters_at(self, index, value):
        self.parameters[index] = value
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def get_carrier(self):
        return self.carrier
    def set_carrier(self, carrier):
        self.carrier = carrier
    def hasContent_(self):
        if (
            self.parameters or
            super(EnergyMarket, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyMarket', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyMarket')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyMarket')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyMarket', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyMarket'):
        super(EnergyMarket, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyMarket')
        if self.asset is not None and 'asset' not in already_processed:
            already_processed.add('asset')
            outfile.write(' asset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.asset), input_name='asset')), ))
        if self.carrier is not None and 'carrier' not in already_processed:
            already_processed.add('carrier')
            outfile.write(' carrier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.carrier), input_name='carrier')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyMarket', fromsubclass_=False, pretty_print=True):
        super(EnergyMarket, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for parameters_ in self.parameters:
            parameters_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyMarket', mapping_=None):
        element = super(EnergyMarket, self).to_etree(parent_element, name_, mapping_)
        if self.asset is not None:
            element.set('asset', self.gds_format_string(self.asset))
        if self.carrier is not None:
            element.set('carrier', self.gds_format_string(self.carrier))
        for parameters_ in self.parameters:
            parameters_.to_etree(element, name_='parameters', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('asset', node)
        if value is not None and 'asset' not in already_processed:
            already_processed.add('asset')
            self.asset = value
        value = find_attr_value_('carrier', node)
        if value is not None and 'carrier' not in already_processed:
            already_processed.add('carrier')
            self.carrier = value
        super(EnergyMarket, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parameters':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <parameters> element')
            self.parameters.append(obj_)
            obj_.original_tagname_ = 'parameters'
        super(EnergyMarket, self).buildChildren(child_, node, nodeName_, True)
# end class EnergyMarket


class ControlStrategy(EnergyService):
    subclass = None
    superclass = EnergyService
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, energyAsset=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ControlStrategy, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, extensiontype_,  **kwargs_)
        self.energyAsset = _cast(None, energyAsset)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ControlStrategy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ControlStrategy.subclass:
            return ControlStrategy.subclass(*args_, **kwargs_)
        else:
            return ControlStrategy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyAsset(self):
        return self.energyAsset
    def set_energyAsset(self, energyAsset):
        self.energyAsset = energyAsset
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ControlStrategy, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ControlStrategy', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ControlStrategy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlStrategy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ControlStrategy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ControlStrategy'):
        super(ControlStrategy, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ControlStrategy')
        if self.energyAsset is not None and 'energyAsset' not in already_processed:
            already_processed.add('energyAsset')
            outfile.write(' energyAsset=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.energyAsset), input_name='energyAsset')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ControlStrategy', fromsubclass_=False, pretty_print=True):
        super(ControlStrategy, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ControlStrategy', mapping_=None):
        element = super(ControlStrategy, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.energyAsset is not None:
            element.set('energyAsset', self.gds_format_string(self.energyAsset))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('energyAsset', node)
        if value is not None and 'energyAsset' not in already_processed:
            already_processed.add('energyAsset')
            self.energyAsset = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ControlStrategy, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ControlStrategy, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ControlStrategy


class EnergyCommodity(Commodity):
    subclass = None
    superclass = Commodity
    def __init__(self, name=None, id=None, cost=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyCommodity, self).__init__(name, id, cost, dataSource,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyCommodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyCommodity.subclass:
            return EnergyCommodity.subclass(*args_, **kwargs_)
        else:
            return EnergyCommodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EnergyCommodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyCommodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyCommodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyCommodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyCommodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyCommodity'):
        super(EnergyCommodity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyCommodity')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyCommodity', fromsubclass_=False, pretty_print=True):
        super(EnergyCommodity, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyCommodity', mapping_=None):
        element = super(EnergyCommodity, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnergyCommodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EnergyCommodity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EnergyCommodity


class ElectricityCommodity(Commodity):
    subclass = None
    superclass = Commodity
    def __init__(self, name=None, id=None, cost=None, dataSource=None, voltage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ElectricityCommodity, self).__init__(name, id, cost, dataSource,  **kwargs_)
        self.voltage = _cast(float, voltage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityCommodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityCommodity.subclass:
            return ElectricityCommodity.subclass(*args_, **kwargs_)
        else:
            return ElectricityCommodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voltage(self):
        return self.voltage
    def set_voltage(self, voltage):
        self.voltage = voltage
    def hasContent_(self):
        if (
            super(ElectricityCommodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityCommodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricityCommodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityCommodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ElectricityCommodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ElectricityCommodity'):
        super(ElectricityCommodity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityCommodity')
        if self.voltage is not None and 'voltage' not in already_processed:
            already_processed.add('voltage')
            outfile.write(' voltage="%s"' % self.gds_format_double(self.voltage, input_name='voltage'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityCommodity', fromsubclass_=False, pretty_print=True):
        super(ElectricityCommodity, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ElectricityCommodity', mapping_=None):
        element = super(ElectricityCommodity, self).to_etree(parent_element, name_, mapping_)
        if self.voltage is not None:
            element.set('voltage', self.gds_format_double(self.voltage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('voltage', node)
        if value is not None and 'voltage' not in already_processed:
            already_processed.add('voltage')
            try:
                self.voltage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (voltage): %s' % exp)
        super(ElectricityCommodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ElectricityCommodity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ElectricityCommodity


class HeatCommodity(Commodity):
    subclass = None
    superclass = Commodity
    def __init__(self, name=None, id=None, cost=None, dataSource=None, temperature=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatCommodity, self).__init__(name, id, cost, dataSource,  **kwargs_)
        self.temperature = _cast(float, temperature)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatCommodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatCommodity.subclass:
            return HeatCommodity.subclass(*args_, **kwargs_)
        else:
            return HeatCommodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temperature(self):
        return self.temperature
    def set_temperature(self, temperature):
        self.temperature = temperature
    def hasContent_(self):
        if (
            super(HeatCommodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatCommodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatCommodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatCommodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatCommodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatCommodity'):
        super(HeatCommodity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatCommodity')
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            outfile.write(' temperature="%s"' % self.gds_format_double(self.temperature, input_name='temperature'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatCommodity', fromsubclass_=False, pretty_print=True):
        super(HeatCommodity, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HeatCommodity', mapping_=None):
        element = super(HeatCommodity, self).to_etree(parent_element, name_, mapping_)
        if self.temperature is not None:
            element.set('temperature', self.gds_format_double(self.temperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            try:
                self.temperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temperature): %s' % exp)
        super(HeatCommodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatCommodity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatCommodity


class GasCommodity(Commodity):
    subclass = None
    superclass = Commodity
    def __init__(self, name=None, id=None, cost=None, dataSource=None, pressure=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasCommodity, self).__init__(name, id, cost, dataSource,  **kwargs_)
        self.pressure = _cast(float, pressure)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasCommodity)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasCommodity.subclass:
            return GasCommodity.subclass(*args_, **kwargs_)
        else:
            return GasCommodity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pressure(self):
        return self.pressure
    def set_pressure(self, pressure):
        self.pressure = pressure
    def hasContent_(self):
        if (
            super(GasCommodity, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasCommodity', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasCommodity')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasCommodity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasCommodity', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasCommodity'):
        super(GasCommodity, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasCommodity')
        if self.pressure is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            outfile.write(' pressure="%s"' % self.gds_format_double(self.pressure, input_name='pressure'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasCommodity', fromsubclass_=False, pretty_print=True):
        super(GasCommodity, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GasCommodity', mapping_=None):
        element = super(GasCommodity, self).to_etree(parent_element, name_, mapping_)
        if self.pressure is not None:
            element.set('pressure', self.gds_format_double(self.pressure))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pressure', node)
        if value is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            try:
                self.pressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pressure): %s' % exp)
        super(GasCommodity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasCommodity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasCommodity


class AggregatorService(EnergyService):
    subclass = None
    superclass = EnergyService
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatorService, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatorService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatorService.subclass:
            return AggregatorService.subclass(*args_, **kwargs_)
        else:
            return AggregatorService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AggregatorService, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatorService', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatorService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatorService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatorService', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatorService'):
        super(AggregatorService, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatorService')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatorService', fromsubclass_=False, pretty_print=True):
        super(AggregatorService, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatorService', mapping_=None):
        element = super(AggregatorService, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AggregatorService, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatorService, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatorService


class AbstractBuilding(Asset):
    subclass = None
    superclass = Asset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, energyLabel=None, energyIndex=None, asset=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractBuilding, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, extensiontype_,  **kwargs_)
        self.energyLabel = _cast(None, energyLabel)
        self.energyIndex = _cast(float, energyIndex)
        if asset is None:
            self.asset = []
        else:
            self.asset = asset
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractBuilding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractBuilding.subclass:
            return AbstractBuilding.subclass(*args_, **kwargs_)
        else:
            return AbstractBuilding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asset(self):
        return self.asset
    def set_asset(self, asset):
        self.asset = asset
    def add_asset(self, value):
        self.asset.append(value)
    def add_asset_with_type(self, value):
        self.asset.append(value)
        value.original_tagname_ = 'asset'
        value.extensiontype_ = value.__class__.__name__
    def insert_asset_at(self, index, value):
        self.asset.insert(index, value)
    def replace_asset_at(self, index, value):
        self.asset[index] = value
    def get_energyLabel(self):
        return self.energyLabel
    def set_energyLabel(self, energyLabel):
        self.energyLabel = energyLabel
    def get_energyIndex(self):
        return self.energyIndex
    def set_energyIndex(self, energyIndex):
        self.energyIndex = energyIndex
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.asset or
            super(AbstractBuilding, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractBuilding', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractBuilding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractBuilding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractBuilding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractBuilding'):
        super(AbstractBuilding, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractBuilding')
        if self.energyLabel is not None and 'energyLabel' not in already_processed:
            already_processed.add('energyLabel')
            outfile.write(' energyLabel=%s' % (quote_attrib(self.energyLabel), ))
        if self.energyIndex is not None and 'energyIndex' not in already_processed:
            already_processed.add('energyIndex')
            outfile.write(' energyIndex="%s"' % self.gds_format_double(self.energyIndex, input_name='energyIndex'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractBuilding', fromsubclass_=False, pretty_print=True):
        super(AbstractBuilding, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for asset_ in self.asset:
            asset_.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractBuilding', mapping_=None):
        element = super(AbstractBuilding, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.energyLabel is not None:
            element.set('energyLabel', self.energyLabel)
        if self.energyIndex is not None:
            element.set('energyIndex', self.gds_format_double(self.energyIndex))
        for asset_ in self.asset:
            asset_.to_etree(element, name_='asset', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('energyLabel', node)
        if value is not None and 'energyLabel' not in already_processed:
            already_processed.add('energyLabel')
            self.energyLabel = value
        value = find_attr_value_('energyIndex', node)
        if value is not None and 'energyIndex' not in already_processed:
            already_processed.add('energyIndex')
            try:
                self.energyIndex = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (energyIndex): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractBuilding, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asset':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <asset> element')
            self.asset.append(obj_)
            obj_.original_tagname_ = 'asset'
        super(AbstractBuilding, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractBuilding


class DemandResponseService(EnergyService):
    subclass = None
    superclass = EnergyService
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DemandResponseService, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandResponseService)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandResponseService.subclass:
            return DemandResponseService.subclass(*args_, **kwargs_)
        else:
            return DemandResponseService(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DemandResponseService, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DemandResponseService', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DemandResponseService')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseService')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DemandResponseService', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DemandResponseService'):
        super(DemandResponseService, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseService')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DemandResponseService', fromsubclass_=False, pretty_print=True):
        super(DemandResponseService, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DemandResponseService', mapping_=None):
        element = super(DemandResponseService, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseService, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DemandResponseService, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DemandResponseService


class Insulation(Asset):
    subclass = None
    superclass = Asset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, thermalInsulation=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Insulation, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation,  **kwargs_)
        self.thermalInsulation = _cast(float, thermalInsulation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Insulation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Insulation.subclass:
            return Insulation.subclass(*args_, **kwargs_)
        else:
            return Insulation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thermalInsulation(self):
        return self.thermalInsulation
    def set_thermalInsulation(self, thermalInsulation):
        self.thermalInsulation = thermalInsulation
    def hasContent_(self):
        if (
            super(Insulation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Insulation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Insulation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Insulation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Insulation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Insulation'):
        super(Insulation, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Insulation')
        if self.thermalInsulation is not None and 'thermalInsulation' not in already_processed:
            already_processed.add('thermalInsulation')
            outfile.write(' thermalInsulation="%s"' % self.gds_format_double(self.thermalInsulation, input_name='thermalInsulation'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Insulation', fromsubclass_=False, pretty_print=True):
        super(Insulation, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Insulation', mapping_=None):
        element = super(Insulation, self).to_etree(parent_element, name_, mapping_)
        if self.thermalInsulation is not None:
            element.set('thermalInsulation', self.gds_format_double(self.thermalInsulation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('thermalInsulation', node)
        if value is not None and 'thermalInsulation' not in already_processed:
            already_processed.add('thermalInsulation')
            try:
                self.thermalInsulation = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (thermalInsulation): %s' % exp)
        super(Insulation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Insulation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Insulation


class Building(AbstractBuilding):
    subclass = None
    superclass = AbstractBuilding
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, energyLabel=None, energyIndex=None, asset=None, buildingYear=None, residentialBuildingType=None, floorArea=None, numberOfFloors=None, slantedRoofArea=None, flatRoofArea=None, roofType=None, wallArea=None, windowArea=None, perimeter=None, height=None, rcFloor=None, rcWall=None, rcRoof=None, uWindow=None, orientation=None, glasType=None, ventilationType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Building, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, energyLabel, energyIndex, asset,  **kwargs_)
        self.buildingYear = _cast(int, buildingYear)
        self.residentialBuildingType = _cast(None, residentialBuildingType)
        self.floorArea = _cast(float, floorArea)
        self.numberOfFloors = _cast(int, numberOfFloors)
        self.slantedRoofArea = _cast(float, slantedRoofArea)
        self.flatRoofArea = _cast(float, flatRoofArea)
        self.roofType = _cast(None, roofType)
        self.wallArea = _cast(float, wallArea)
        self.windowArea = _cast(float, windowArea)
        self.perimeter = _cast(float, perimeter)
        self.height = _cast(float, height)
        self.rcFloor = _cast(float, rcFloor)
        self.rcWall = _cast(float, rcWall)
        self.rcRoof = _cast(float, rcRoof)
        self.uWindow = _cast(float, uWindow)
        self.orientation = _cast(int, orientation)
        self.glasType = _cast(None, glasType)
        self.ventilationType = _cast(None, ventilationType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Building)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Building.subclass:
            return Building.subclass(*args_, **kwargs_)
        else:
            return Building(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_buildingYear(self):
        return self.buildingYear
    def set_buildingYear(self, buildingYear):
        self.buildingYear = buildingYear
    def get_residentialBuildingType(self):
        return self.residentialBuildingType
    def set_residentialBuildingType(self, residentialBuildingType):
        self.residentialBuildingType = residentialBuildingType
    def get_floorArea(self):
        return self.floorArea
    def set_floorArea(self, floorArea):
        self.floorArea = floorArea
    def get_numberOfFloors(self):
        return self.numberOfFloors
    def set_numberOfFloors(self, numberOfFloors):
        self.numberOfFloors = numberOfFloors
    def get_slantedRoofArea(self):
        return self.slantedRoofArea
    def set_slantedRoofArea(self, slantedRoofArea):
        self.slantedRoofArea = slantedRoofArea
    def get_flatRoofArea(self):
        return self.flatRoofArea
    def set_flatRoofArea(self, flatRoofArea):
        self.flatRoofArea = flatRoofArea
    def get_roofType(self):
        return self.roofType
    def set_roofType(self, roofType):
        self.roofType = roofType
    def get_wallArea(self):
        return self.wallArea
    def set_wallArea(self, wallArea):
        self.wallArea = wallArea
    def get_windowArea(self):
        return self.windowArea
    def set_windowArea(self, windowArea):
        self.windowArea = windowArea
    def get_perimeter(self):
        return self.perimeter
    def set_perimeter(self, perimeter):
        self.perimeter = perimeter
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_rcFloor(self):
        return self.rcFloor
    def set_rcFloor(self, rcFloor):
        self.rcFloor = rcFloor
    def get_rcWall(self):
        return self.rcWall
    def set_rcWall(self, rcWall):
        self.rcWall = rcWall
    def get_rcRoof(self):
        return self.rcRoof
    def set_rcRoof(self, rcRoof):
        self.rcRoof = rcRoof
    def get_uWindow(self):
        return self.uWindow
    def set_uWindow(self, uWindow):
        self.uWindow = uWindow
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def get_glasType(self):
        return self.glasType
    def set_glasType(self, glasType):
        self.glasType = glasType
    def get_ventilationType(self):
        return self.ventilationType
    def set_ventilationType(self, ventilationType):
        self.ventilationType = ventilationType
    def hasContent_(self):
        if (
            super(Building, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Building', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Building')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Building')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Building', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Building'):
        super(Building, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Building')
        if self.buildingYear is not None and 'buildingYear' not in already_processed:
            already_processed.add('buildingYear')
            outfile.write(' buildingYear="%s"' % self.gds_format_integer(self.buildingYear, input_name='buildingYear'))
        if self.residentialBuildingType is not None and 'residentialBuildingType' not in already_processed:
            already_processed.add('residentialBuildingType')
            outfile.write(' residentialBuildingType=%s' % (quote_attrib(self.residentialBuildingType), ))
        if self.floorArea is not None and 'floorArea' not in already_processed:
            already_processed.add('floorArea')
            outfile.write(' floorArea="%s"' % self.gds_format_double(self.floorArea, input_name='floorArea'))
        if self.numberOfFloors is not None and 'numberOfFloors' not in already_processed:
            already_processed.add('numberOfFloors')
            outfile.write(' numberOfFloors="%s"' % self.gds_format_integer(self.numberOfFloors, input_name='numberOfFloors'))
        if self.slantedRoofArea is not None and 'slantedRoofArea' not in already_processed:
            already_processed.add('slantedRoofArea')
            outfile.write(' slantedRoofArea="%s"' % self.gds_format_double(self.slantedRoofArea, input_name='slantedRoofArea'))
        if self.flatRoofArea is not None and 'flatRoofArea' not in already_processed:
            already_processed.add('flatRoofArea')
            outfile.write(' flatRoofArea="%s"' % self.gds_format_double(self.flatRoofArea, input_name='flatRoofArea'))
        if self.roofType is not None and 'roofType' not in already_processed:
            already_processed.add('roofType')
            outfile.write(' roofType=%s' % (quote_attrib(self.roofType), ))
        if self.wallArea is not None and 'wallArea' not in already_processed:
            already_processed.add('wallArea')
            outfile.write(' wallArea="%s"' % self.gds_format_double(self.wallArea, input_name='wallArea'))
        if self.windowArea is not None and 'windowArea' not in already_processed:
            already_processed.add('windowArea')
            outfile.write(' windowArea="%s"' % self.gds_format_double(self.windowArea, input_name='windowArea'))
        if self.perimeter is not None and 'perimeter' not in already_processed:
            already_processed.add('perimeter')
            outfile.write(' perimeter="%s"' % self.gds_format_double(self.perimeter, input_name='perimeter'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.rcFloor is not None and 'rcFloor' not in already_processed:
            already_processed.add('rcFloor')
            outfile.write(' rcFloor="%s"' % self.gds_format_double(self.rcFloor, input_name='rcFloor'))
        if self.rcWall is not None and 'rcWall' not in already_processed:
            already_processed.add('rcWall')
            outfile.write(' rcWall="%s"' % self.gds_format_double(self.rcWall, input_name='rcWall'))
        if self.rcRoof is not None and 'rcRoof' not in already_processed:
            already_processed.add('rcRoof')
            outfile.write(' rcRoof="%s"' % self.gds_format_double(self.rcRoof, input_name='rcRoof'))
        if self.uWindow is not None and 'uWindow' not in already_processed:
            already_processed.add('uWindow')
            outfile.write(' uWindow="%s"' % self.gds_format_double(self.uWindow, input_name='uWindow'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation="%s"' % self.gds_format_integer(self.orientation, input_name='orientation'))
        if self.glasType is not None and 'glasType' not in already_processed:
            already_processed.add('glasType')
            outfile.write(' glasType=%s' % (quote_attrib(self.glasType), ))
        if self.ventilationType is not None and 'ventilationType' not in already_processed:
            already_processed.add('ventilationType')
            outfile.write(' ventilationType=%s' % (quote_attrib(self.ventilationType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Building', fromsubclass_=False, pretty_print=True):
        super(Building, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Building', mapping_=None):
        element = super(Building, self).to_etree(parent_element, name_, mapping_)
        if self.buildingYear is not None:
            element.set('buildingYear', self.gds_format_integer(self.buildingYear))
        if self.residentialBuildingType is not None:
            element.set('residentialBuildingType', self.residentialBuildingType)
        if self.floorArea is not None:
            element.set('floorArea', self.gds_format_double(self.floorArea))
        if self.numberOfFloors is not None:
            element.set('numberOfFloors', self.gds_format_integer(self.numberOfFloors))
        if self.slantedRoofArea is not None:
            element.set('slantedRoofArea', self.gds_format_double(self.slantedRoofArea))
        if self.flatRoofArea is not None:
            element.set('flatRoofArea', self.gds_format_double(self.flatRoofArea))
        if self.roofType is not None:
            element.set('roofType', self.roofType)
        if self.wallArea is not None:
            element.set('wallArea', self.gds_format_double(self.wallArea))
        if self.windowArea is not None:
            element.set('windowArea', self.gds_format_double(self.windowArea))
        if self.perimeter is not None:
            element.set('perimeter', self.gds_format_double(self.perimeter))
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if self.rcFloor is not None:
            element.set('rcFloor', self.gds_format_double(self.rcFloor))
        if self.rcWall is not None:
            element.set('rcWall', self.gds_format_double(self.rcWall))
        if self.rcRoof is not None:
            element.set('rcRoof', self.gds_format_double(self.rcRoof))
        if self.uWindow is not None:
            element.set('uWindow', self.gds_format_double(self.uWindow))
        if self.orientation is not None:
            element.set('orientation', self.gds_format_integer(self.orientation))
        if self.glasType is not None:
            element.set('glasType', self.glasType)
        if self.ventilationType is not None:
            element.set('ventilationType', self.ventilationType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('buildingYear', node)
        if value is not None and 'buildingYear' not in already_processed:
            already_processed.add('buildingYear')
            try:
                self.buildingYear = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('residentialBuildingType', node)
        if value is not None and 'residentialBuildingType' not in already_processed:
            already_processed.add('residentialBuildingType')
            self.residentialBuildingType = value
        value = find_attr_value_('floorArea', node)
        if value is not None and 'floorArea' not in already_processed:
            already_processed.add('floorArea')
            try:
                self.floorArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (floorArea): %s' % exp)
        value = find_attr_value_('numberOfFloors', node)
        if value is not None and 'numberOfFloors' not in already_processed:
            already_processed.add('numberOfFloors')
            try:
                self.numberOfFloors = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('slantedRoofArea', node)
        if value is not None and 'slantedRoofArea' not in already_processed:
            already_processed.add('slantedRoofArea')
            try:
                self.slantedRoofArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (slantedRoofArea): %s' % exp)
        value = find_attr_value_('flatRoofArea', node)
        if value is not None and 'flatRoofArea' not in already_processed:
            already_processed.add('flatRoofArea')
            try:
                self.flatRoofArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (flatRoofArea): %s' % exp)
        value = find_attr_value_('roofType', node)
        if value is not None and 'roofType' not in already_processed:
            already_processed.add('roofType')
            self.roofType = value
        value = find_attr_value_('wallArea', node)
        if value is not None and 'wallArea' not in already_processed:
            already_processed.add('wallArea')
            try:
                self.wallArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (wallArea): %s' % exp)
        value = find_attr_value_('windowArea', node)
        if value is not None and 'windowArea' not in already_processed:
            already_processed.add('windowArea')
            try:
                self.windowArea = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (windowArea): %s' % exp)
        value = find_attr_value_('perimeter', node)
        if value is not None and 'perimeter' not in already_processed:
            already_processed.add('perimeter')
            try:
                self.perimeter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (perimeter): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('rcFloor', node)
        if value is not None and 'rcFloor' not in already_processed:
            already_processed.add('rcFloor')
            try:
                self.rcFloor = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rcFloor): %s' % exp)
        value = find_attr_value_('rcWall', node)
        if value is not None and 'rcWall' not in already_processed:
            already_processed.add('rcWall')
            try:
                self.rcWall = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rcWall): %s' % exp)
        value = find_attr_value_('rcRoof', node)
        if value is not None and 'rcRoof' not in already_processed:
            already_processed.add('rcRoof')
            try:
                self.rcRoof = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rcRoof): %s' % exp)
        value = find_attr_value_('uWindow', node)
        if value is not None and 'uWindow' not in already_processed:
            already_processed.add('uWindow')
            try:
                self.uWindow = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (uWindow): %s' % exp)
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            try:
                self.orientation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('glasType', node)
        if value is not None and 'glasType' not in already_processed:
            already_processed.add('glasType')
            self.glasType = value
        value = find_attr_value_('ventilationType', node)
        if value is not None and 'ventilationType' not in already_processed:
            already_processed.add('ventilationType')
            self.ventilationType = value
        super(Building, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Building, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Building


class BuildingUnit(AbstractBuilding):
    subclass = None
    superclass = AbstractBuilding
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, energyLabel=None, energyIndex=None, asset=None, type_=None, housingType=None, numberOfInhabitants=None, inhabitantsType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BuildingUnit, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, energyLabel, energyIndex, asset,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.housingType = _cast(None, housingType)
        self.numberOfInhabitants = _cast(int, numberOfInhabitants)
        self.inhabitantsType = _cast(None, inhabitantsType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BuildingUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BuildingUnit.subclass:
            return BuildingUnit.subclass(*args_, **kwargs_)
        else:
            return BuildingUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_housingType(self):
        return self.housingType
    def set_housingType(self, housingType):
        self.housingType = housingType
    def get_numberOfInhabitants(self):
        return self.numberOfInhabitants
    def set_numberOfInhabitants(self, numberOfInhabitants):
        self.numberOfInhabitants = numberOfInhabitants
    def get_inhabitantsType(self):
        return self.inhabitantsType
    def set_inhabitantsType(self, inhabitantsType):
        self.inhabitantsType = inhabitantsType
    def hasContent_(self):
        if (
            super(BuildingUnit, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='BuildingUnit', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BuildingUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BuildingUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='BuildingUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='BuildingUnit'):
        super(BuildingUnit, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BuildingUnit')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.housingType is not None and 'housingType' not in already_processed:
            already_processed.add('housingType')
            outfile.write(' housingType=%s' % (quote_attrib(self.housingType), ))
        if self.numberOfInhabitants is not None and 'numberOfInhabitants' not in already_processed:
            already_processed.add('numberOfInhabitants')
            outfile.write(' numberOfInhabitants="%s"' % self.gds_format_integer(self.numberOfInhabitants, input_name='numberOfInhabitants'))
        if self.inhabitantsType is not None and 'inhabitantsType' not in already_processed:
            already_processed.add('inhabitantsType')
            outfile.write(' inhabitantsType=%s' % (quote_attrib(self.inhabitantsType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='BuildingUnit', fromsubclass_=False, pretty_print=True):
        super(BuildingUnit, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BuildingUnit', mapping_=None):
        element = super(BuildingUnit, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.housingType is not None:
            element.set('housingType', self.housingType)
        if self.numberOfInhabitants is not None:
            element.set('numberOfInhabitants', self.gds_format_integer(self.numberOfInhabitants))
        if self.inhabitantsType is not None:
            element.set('inhabitantsType', self.inhabitantsType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('housingType', node)
        if value is not None and 'housingType' not in already_processed:
            already_processed.add('housingType')
            self.housingType = value
        value = find_attr_value_('numberOfInhabitants', node)
        if value is not None and 'numberOfInhabitants' not in already_processed:
            already_processed.add('numberOfInhabitants')
            try:
                self.numberOfInhabitants = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('inhabitantsType', node)
        if value is not None and 'inhabitantsType' not in already_processed:
            already_processed.add('inhabitantsType')
            self.inhabitantsType = value
        super(BuildingUnit, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BuildingUnit, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BuildingUnit


class Transport(EnergyAsset):
    """Allows to specify transmission losses as a percentage"""
    subclass = None
    superclass = EnergyAsset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Transport, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, extensiontype_,  **kwargs_)
        self.capacity = _cast(float, capacity)
        self.efficiency = _cast(float, efficiency)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Transport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Transport.subclass:
            return Transport.subclass(*args_, **kwargs_)
        else:
            return Transport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_capacity(self):
        return self.capacity
    def set_capacity(self, capacity):
        self.capacity = capacity
    def get_efficiency(self):
        return self.efficiency
    def set_efficiency(self, efficiency):
        self.efficiency = efficiency
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Transport, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Transport', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Transport')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Transport', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Transport'):
        super(Transport, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transport')
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            outfile.write(' capacity="%s"' % self.gds_format_double(self.capacity, input_name='capacity'))
        if self.efficiency is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            outfile.write(' efficiency="%s"' % self.gds_format_double(self.efficiency, input_name='efficiency'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Transport', fromsubclass_=False, pretty_print=True):
        super(Transport, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Transport', mapping_=None):
        element = super(Transport, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.capacity is not None:
            element.set('capacity', self.gds_format_double(self.capacity))
        if self.efficiency is not None:
            element.set('efficiency', self.gds_format_double(self.efficiency))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('capacity', node)
        if value is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            try:
                self.capacity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (capacity): %s' % exp)
        value = find_attr_value_('efficiency', node)
        if value is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            try:
                self.efficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (efficiency): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Transport, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Transport, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Transport


class Conversion(EnergyAsset):
    """Conversion Capability"""
    subclass = None
    superclass = EnergyAsset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Conversion, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, extensiontype_,  **kwargs_)
        self.efficiency = _cast(float, efficiency)
        self.operationalHours = _cast(int, operationalHours)
        self.fullLoadHours = _cast(int, fullLoadHours)
        self.power = _cast(float, power)
        self.residualHeatSourcePotential = _cast(None, residualHeatSourcePotential)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Conversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Conversion.subclass:
            return Conversion.subclass(*args_, **kwargs_)
        else:
            return Conversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_efficiency(self):
        return self.efficiency
    def set_efficiency(self, efficiency):
        self.efficiency = efficiency
    def get_operationalHours(self):
        return self.operationalHours
    def set_operationalHours(self, operationalHours):
        self.operationalHours = operationalHours
    def get_fullLoadHours(self):
        return self.fullLoadHours
    def set_fullLoadHours(self, fullLoadHours):
        self.fullLoadHours = fullLoadHours
    def get_power(self):
        return self.power
    def set_power(self, power):
        self.power = power
    def get_residualHeatSourcePotential(self):
        return self.residualHeatSourcePotential
    def set_residualHeatSourcePotential(self, residualHeatSourcePotential):
        self.residualHeatSourcePotential = residualHeatSourcePotential
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Conversion, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Conversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Conversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Conversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Conversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Conversion'):
        super(Conversion, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Conversion')
        if self.efficiency is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            outfile.write(' efficiency="%s"' % self.gds_format_double(self.efficiency, input_name='efficiency'))
        if self.operationalHours is not None and 'operationalHours' not in already_processed:
            already_processed.add('operationalHours')
            outfile.write(' operationalHours="%s"' % self.gds_format_integer(self.operationalHours, input_name='operationalHours'))
        if self.fullLoadHours is not None and 'fullLoadHours' not in already_processed:
            already_processed.add('fullLoadHours')
            outfile.write(' fullLoadHours="%s"' % self.gds_format_integer(self.fullLoadHours, input_name='fullLoadHours'))
        if self.power is not None and 'power' not in already_processed:
            already_processed.add('power')
            outfile.write(' power="%s"' % self.gds_format_double(self.power, input_name='power'))
        if self.residualHeatSourcePotential is not None and 'residualHeatSourcePotential' not in already_processed:
            already_processed.add('residualHeatSourcePotential')
            outfile.write(' residualHeatSourcePotential=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.residualHeatSourcePotential), input_name='residualHeatSourcePotential')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Conversion', fromsubclass_=False, pretty_print=True):
        super(Conversion, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Conversion', mapping_=None):
        element = super(Conversion, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.efficiency is not None:
            element.set('efficiency', self.gds_format_double(self.efficiency))
        if self.operationalHours is not None:
            element.set('operationalHours', self.gds_format_integer(self.operationalHours))
        if self.fullLoadHours is not None:
            element.set('fullLoadHours', self.gds_format_integer(self.fullLoadHours))
        if self.power is not None:
            element.set('power', self.gds_format_double(self.power))
        if self.residualHeatSourcePotential is not None:
            element.set('residualHeatSourcePotential', self.gds_format_string(self.residualHeatSourcePotential))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('efficiency', node)
        if value is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            try:
                self.efficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (efficiency): %s' % exp)
        value = find_attr_value_('operationalHours', node)
        if value is not None and 'operationalHours' not in already_processed:
            already_processed.add('operationalHours')
            try:
                self.operationalHours = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fullLoadHours', node)
        if value is not None and 'fullLoadHours' not in already_processed:
            already_processed.add('fullLoadHours')
            try:
                self.fullLoadHours = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('power', node)
        if value is not None and 'power' not in already_processed:
            already_processed.add('power')
            try:
                self.power = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (power): %s' % exp)
        value = find_attr_value_('residualHeatSourcePotential', node)
        if value is not None and 'residualHeatSourcePotential' not in already_processed:
            already_processed.add('residualHeatSourcePotential')
            self.residualHeatSourcePotential = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Conversion, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Conversion, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Conversion


class Storage(EnergyAsset):
    subclass = None
    superclass = EnergyAsset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Storage, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, extensiontype_,  **kwargs_)
        self.capacity = _cast(float, capacity)
        self.chargeEfficiency = _cast(float, chargeEfficiency)
        self.dischargeEfficiency = _cast(float, dischargeEfficiency)
        self.selfDischargeRate = _cast(float, selfDischargeRate)
        self.fillLevel = _cast(float, fillLevel)
        self.maxChargeRate = _cast(float, maxChargeRate)
        self.maxDischargeRate = _cast(float, maxDischargeRate)
        self.profile = profile
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Storage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Storage.subclass:
            return Storage.subclass(*args_, **kwargs_)
        else:
            return Storage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile(self):
        return self.profile
    def set_profile(self, profile):
        self.profile = profile
        profile.original_tagname_ = 'profile'
        profile.extensiontype_ = profile.__class__.__name__
    def get_capacity(self):
        return self.capacity
    def set_capacity(self, capacity):
        self.capacity = capacity
    def get_chargeEfficiency(self):
        return self.chargeEfficiency
    def set_chargeEfficiency(self, chargeEfficiency):
        self.chargeEfficiency = chargeEfficiency
    def get_dischargeEfficiency(self):
        return self.dischargeEfficiency
    def set_dischargeEfficiency(self, dischargeEfficiency):
        self.dischargeEfficiency = dischargeEfficiency
    def get_selfDischargeRate(self):
        return self.selfDischargeRate
    def set_selfDischargeRate(self, selfDischargeRate):
        self.selfDischargeRate = selfDischargeRate
    def get_fillLevel(self):
        return self.fillLevel
    def set_fillLevel(self, fillLevel):
        self.fillLevel = fillLevel
    def get_maxChargeRate(self):
        return self.maxChargeRate
    def set_maxChargeRate(self, maxChargeRate):
        self.maxChargeRate = maxChargeRate
    def get_maxDischargeRate(self):
        return self.maxDischargeRate
    def set_maxDischargeRate(self, maxDischargeRate):
        self.maxDischargeRate = maxDischargeRate
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.profile is not None or
            super(Storage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Storage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Storage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Storage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Storage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Storage'):
        super(Storage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Storage')
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            outfile.write(' capacity="%s"' % self.gds_format_double(self.capacity, input_name='capacity'))
        if self.chargeEfficiency != 0.0 and 'chargeEfficiency' not in already_processed:
            already_processed.add('chargeEfficiency')
            outfile.write(' chargeEfficiency="%s"' % self.gds_format_double(self.chargeEfficiency, input_name='chargeEfficiency'))
        if self.dischargeEfficiency != 0.0 and 'dischargeEfficiency' not in already_processed:
            already_processed.add('dischargeEfficiency')
            outfile.write(' dischargeEfficiency="%s"' % self.gds_format_double(self.dischargeEfficiency, input_name='dischargeEfficiency'))
        if self.selfDischargeRate != 0.0 and 'selfDischargeRate' not in already_processed:
            already_processed.add('selfDischargeRate')
            outfile.write(' selfDischargeRate="%s"' % self.gds_format_double(self.selfDischargeRate, input_name='selfDischargeRate'))
        if self.fillLevel is not None and 'fillLevel' not in already_processed:
            already_processed.add('fillLevel')
            outfile.write(' fillLevel="%s"' % self.gds_format_double(self.fillLevel, input_name='fillLevel'))
        if self.maxChargeRate != 0.0 and 'maxChargeRate' not in already_processed:
            already_processed.add('maxChargeRate')
            outfile.write(' maxChargeRate="%s"' % self.gds_format_double(self.maxChargeRate, input_name='maxChargeRate'))
        if self.maxDischargeRate != 0.0 and 'maxDischargeRate' not in already_processed:
            already_processed.add('maxDischargeRate')
            outfile.write(' maxDischargeRate="%s"' % self.gds_format_double(self.maxDischargeRate, input_name='maxDischargeRate'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Storage', fromsubclass_=False, pretty_print=True):
        super(Storage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.profile is not None:
            self.profile.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Storage', mapping_=None):
        element = super(Storage, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.capacity is not None:
            element.set('capacity', self.gds_format_double(self.capacity))
        if self.chargeEfficiency is not None:
            element.set('chargeEfficiency', self.gds_format_double(self.chargeEfficiency))
        if self.dischargeEfficiency is not None:
            element.set('dischargeEfficiency', self.gds_format_double(self.dischargeEfficiency))
        if self.selfDischargeRate is not None:
            element.set('selfDischargeRate', self.gds_format_double(self.selfDischargeRate))
        if self.fillLevel is not None:
            element.set('fillLevel', self.gds_format_double(self.fillLevel))
        if self.maxChargeRate is not None:
            element.set('maxChargeRate', self.gds_format_double(self.maxChargeRate))
        if self.maxDischargeRate is not None:
            element.set('maxDischargeRate', self.gds_format_double(self.maxDischargeRate))
        if self.profile is not None:
            profile_ = self.profile
            profile_.to_etree(element, name_='profile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('capacity', node)
        if value is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            try:
                self.capacity = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (capacity): %s' % exp)
        value = find_attr_value_('chargeEfficiency', node)
        if value is not None and 'chargeEfficiency' not in already_processed:
            already_processed.add('chargeEfficiency')
            try:
                self.chargeEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (chargeEfficiency): %s' % exp)
        value = find_attr_value_('dischargeEfficiency', node)
        if value is not None and 'dischargeEfficiency' not in already_processed:
            already_processed.add('dischargeEfficiency')
            try:
                self.dischargeEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (dischargeEfficiency): %s' % exp)
        value = find_attr_value_('selfDischargeRate', node)
        if value is not None and 'selfDischargeRate' not in already_processed:
            already_processed.add('selfDischargeRate')
            try:
                self.selfDischargeRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (selfDischargeRate): %s' % exp)
        value = find_attr_value_('fillLevel', node)
        if value is not None and 'fillLevel' not in already_processed:
            already_processed.add('fillLevel')
            try:
                self.fillLevel = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (fillLevel): %s' % exp)
        value = find_attr_value_('maxChargeRate', node)
        if value is not None and 'maxChargeRate' not in already_processed:
            already_processed.add('maxChargeRate')
            try:
                self.maxChargeRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxChargeRate): %s' % exp)
        value = find_attr_value_('maxDischargeRate', node)
        if value is not None and 'maxDischargeRate' not in already_processed:
            already_processed.add('maxDischargeRate')
            try:
                self.maxDischargeRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxDischargeRate): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Storage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <profile> element')
            self.profile = obj_
            obj_.original_tagname_ = 'profile'
        super(Storage, self).buildChildren(child_, node, nodeName_, True)
# end class Storage


class Consumer(EnergyAsset):
    subclass = None
    superclass = EnergyAsset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Consumer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, extensiontype_,  **kwargs_)
        self.consType = _cast(None, consType)
        self.power = _cast(float, power)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Consumer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Consumer.subclass:
            return Consumer.subclass(*args_, **kwargs_)
        else:
            return Consumer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_consType(self):
        return self.consType
    def set_consType(self, consType):
        self.consType = consType
    def get_power(self):
        return self.power
    def set_power(self, power):
        self.power = power
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Consumer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Consumer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Consumer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Consumer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Consumer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Consumer'):
        super(Consumer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Consumer')
        if self.consType != "PRIMARY" and 'consType' not in already_processed:
            already_processed.add('consType')
            outfile.write(' consType=%s' % (quote_attrib(self.consType), ))
        if self.power is not None and 'power' not in already_processed:
            already_processed.add('power')
            outfile.write(' power="%s"' % self.gds_format_double(self.power, input_name='power'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Consumer', fromsubclass_=False, pretty_print=True):
        super(Consumer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Consumer', mapping_=None):
        element = super(Consumer, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.consType is not None:
            element.set('consType', self.consType)
        if self.power is not None:
            element.set('power', self.gds_format_double(self.power))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('consType', node)
        if value is not None and 'consType' not in already_processed:
            already_processed.add('consType')
            self.consType = value
        value = find_attr_value_('power', node)
        if value is not None and 'power' not in already_processed:
            already_processed.add('power')
            try:
                self.power = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (power): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Consumer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Consumer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Consumer


class Producer(EnergyAsset):
    subclass = None
    superclass = EnergyAsset
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Producer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, extensiontype_,  **kwargs_)
        self.prodType = _cast(None, prodType)
        self.operationalHours = _cast(int, operationalHours)
        self.fullLoadHours = _cast(int, fullLoadHours)
        self.power = _cast(float, power)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Producer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Producer.subclass:
            return Producer.subclass(*args_, **kwargs_)
        else:
            return Producer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prodType(self):
        return self.prodType
    def set_prodType(self, prodType):
        self.prodType = prodType
    def get_operationalHours(self):
        return self.operationalHours
    def set_operationalHours(self, operationalHours):
        self.operationalHours = operationalHours
    def get_fullLoadHours(self):
        return self.fullLoadHours
    def set_fullLoadHours(self, fullLoadHours):
        self.fullLoadHours = fullLoadHours
    def get_power(self):
        return self.power
    def set_power(self, power):
        self.power = power
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(Producer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Producer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Producer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Producer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Producer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Producer'):
        super(Producer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Producer')
        if self.prodType != "RENEWABLE" and 'prodType' not in already_processed:
            already_processed.add('prodType')
            outfile.write(' prodType=%s' % (quote_attrib(self.prodType), ))
        if self.operationalHours is not None and 'operationalHours' not in already_processed:
            already_processed.add('operationalHours')
            outfile.write(' operationalHours="%s"' % self.gds_format_integer(self.operationalHours, input_name='operationalHours'))
        if self.fullLoadHours is not None and 'fullLoadHours' not in already_processed:
            already_processed.add('fullLoadHours')
            outfile.write(' fullLoadHours="%s"' % self.gds_format_integer(self.fullLoadHours, input_name='fullLoadHours'))
        if self.power is not None and 'power' not in already_processed:
            already_processed.add('power')
            outfile.write(' power="%s"' % self.gds_format_double(self.power, input_name='power'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Producer', fromsubclass_=False, pretty_print=True):
        super(Producer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Producer', mapping_=None):
        element = super(Producer, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.prodType is not None:
            element.set('prodType', self.prodType)
        if self.operationalHours is not None:
            element.set('operationalHours', self.gds_format_integer(self.operationalHours))
        if self.fullLoadHours is not None:
            element.set('fullLoadHours', self.gds_format_integer(self.fullLoadHours))
        if self.power is not None:
            element.set('power', self.gds_format_double(self.power))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('prodType', node)
        if value is not None and 'prodType' not in already_processed:
            already_processed.add('prodType')
            self.prodType = value
        value = find_attr_value_('operationalHours', node)
        if value is not None and 'operationalHours' not in already_processed:
            already_processed.add('operationalHours')
            try:
                self.operationalHours = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fullLoadHours', node)
        if value is not None and 'fullLoadHours' not in already_processed:
            already_processed.add('fullLoadHours')
            try:
                self.fullLoadHours = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('power', node)
        if value is not None and 'power' not in already_processed:
            already_processed.add('power')
            try:
                self.power = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (power): %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(Producer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Producer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Producer


class BiomassHeater(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(BiomassHeater, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BiomassHeater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BiomassHeater.subclass:
            return BiomassHeater.subclass(*args_, **kwargs_)
        else:
            return BiomassHeater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BiomassHeater, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='BiomassHeater', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BiomassHeater')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiomassHeater')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='BiomassHeater', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='BiomassHeater'):
        super(BiomassHeater, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BiomassHeater')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='BiomassHeater', fromsubclass_=False, pretty_print=True):
        super(BiomassHeater, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='BiomassHeater', mapping_=None):
        element = super(BiomassHeater, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BiomassHeater, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BiomassHeater, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BiomassHeater


class RoomHeater(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(RoomHeater, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoomHeater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoomHeater.subclass:
            return RoomHeater.subclass(*args_, **kwargs_)
        else:
            return RoomHeater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(RoomHeater, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='RoomHeater', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RoomHeater')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RoomHeater')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='RoomHeater', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='RoomHeater'):
        super(RoomHeater, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RoomHeater')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='RoomHeater', fromsubclass_=False, pretty_print=True):
        super(RoomHeater, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='RoomHeater', mapping_=None):
        element = super(RoomHeater, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(RoomHeater, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RoomHeater, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RoomHeater


class AbstractConnection(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractConnection, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractConnection.subclass:
            return AbstractConnection.subclass(*args_, **kwargs_)
        else:
            return AbstractConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractConnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractConnection'):
        super(AbstractConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractConnection')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractConnection', fromsubclass_=False, pretty_print=True):
        super(AbstractConnection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractConnection', mapping_=None):
        element = super(AbstractConnection, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractConnection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractConnection


class AbstractTransformer(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractTransformer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractTransformer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractTransformer.subclass:
            return AbstractTransformer.subclass(*args_, **kwargs_)
        else:
            return AbstractTransformer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractTransformer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractTransformer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractTransformer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractTransformer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractTransformer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractTransformer'):
        super(AbstractTransformer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractTransformer')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractTransformer', fromsubclass_=False, pretty_print=True):
        super(AbstractTransformer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractTransformer', mapping_=None):
        element = super(AbstractTransformer, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractTransformer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractTransformer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractTransformer


class AbstractSwitch(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractSwitch, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractSwitch)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractSwitch.subclass:
            return AbstractSwitch.subclass(*args_, **kwargs_)
        else:
            return AbstractSwitch(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractSwitch, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractSwitch', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractSwitch')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractSwitch')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractSwitch', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractSwitch'):
        super(AbstractSwitch, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractSwitch')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractSwitch', fromsubclass_=False, pretty_print=True):
        super(AbstractSwitch, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractSwitch', mapping_=None):
        element = super(AbstractSwitch, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractSwitch, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractSwitch, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractSwitch


class AbstractConductor(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AbstractConductor, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency, extensiontype_,  **kwargs_)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractConductor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractConductor.subclass:
            return AbstractConductor.subclass(*args_, **kwargs_)
        else:
            return AbstractConductor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(AbstractConductor, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractConductor', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractConductor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractConductor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AbstractConductor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AbstractConductor'):
        super(AbstractConductor, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractConductor')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AbstractConductor', fromsubclass_=False, pretty_print=True):
        super(AbstractConductor, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AbstractConductor', mapping_=None):
        element = super(AbstractConductor, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractConductor, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractConductor, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractConductor


class EnergyNetwork(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyNetwork, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyNetwork.subclass:
            return EnergyNetwork.subclass(*args_, **kwargs_)
        else:
            return EnergyNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EnergyNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyNetwork', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyNetwork'):
        super(EnergyNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyNetwork')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyNetwork', fromsubclass_=False, pretty_print=True):
        super(EnergyNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyNetwork', mapping_=None):
        element = super(EnergyNetwork, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnergyNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EnergyNetwork, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EnergyNetwork


class WaterToPower(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WaterToPower, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterToPower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterToPower.subclass:
            return WaterToPower.subclass(*args_, **kwargs_)
        else:
            return WaterToPower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(WaterToPower, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WaterToPower', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WaterToPower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WaterToPower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WaterToPower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WaterToPower'):
        super(WaterToPower, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WaterToPower')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WaterToPower', fromsubclass_=False, pretty_print=True):
        super(WaterToPower, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='WaterToPower', mapping_=None):
        element = super(WaterToPower, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(WaterToPower, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WaterToPower, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WaterToPower


class CircuitBraker(AbstractSwitch):
    subclass = None
    superclass = AbstractSwitch
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CircuitBraker, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CircuitBraker)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CircuitBraker.subclass:
            return CircuitBraker.subclass(*args_, **kwargs_)
        else:
            return CircuitBraker(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CircuitBraker, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CircuitBraker', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CircuitBraker')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CircuitBraker')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CircuitBraker', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CircuitBraker'):
        super(CircuitBraker, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CircuitBraker')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CircuitBraker', fromsubclass_=False, pretty_print=True):
        super(CircuitBraker, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CircuitBraker', mapping_=None):
        element = super(CircuitBraker, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CircuitBraker, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CircuitBraker, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CircuitBraker


class DrivenByProfile(ControlStrategy):
    subclass = None
    superclass = ControlStrategy
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, energyAsset=None, profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DrivenByProfile, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, energyAsset,  **kwargs_)
        self.profile = profile
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrivenByProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrivenByProfile.subclass:
            return DrivenByProfile.subclass(*args_, **kwargs_)
        else:
            return DrivenByProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_profile(self):
        return self.profile
    def set_profile(self, profile):
        self.profile = profile
        profile.original_tagname_ = 'profile'
        profile.extensiontype_ = profile.__class__.__name__
    def hasContent_(self):
        if (
            self.profile is not None or
            super(DrivenByProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenByProfile', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrivenByProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenByProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DrivenByProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DrivenByProfile'):
        super(DrivenByProfile, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenByProfile')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenByProfile', fromsubclass_=False, pretty_print=True):
        super(DrivenByProfile, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.profile is not None:
            self.profile.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DrivenByProfile', mapping_=None):
        element = super(DrivenByProfile, self).to_etree(parent_element, name_, mapping_)
        if self.profile is not None:
            profile_ = self.profile
            profile_.to_etree(element, name_='profile', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DrivenByProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'profile':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <profile> element')
            self.profile = obj_
            obj_.original_tagname_ = 'profile'
        super(DrivenByProfile, self).buildChildren(child_, node, nodeName_, True)
# end class DrivenByProfile


class DrivenBySupply(ControlStrategy):
    subclass = None
    superclass = ControlStrategy
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, energyAsset=None, inPort=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DrivenBySupply, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, energyAsset,  **kwargs_)
        self.inPort = _cast(None, inPort)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrivenBySupply)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrivenBySupply.subclass:
            return DrivenBySupply.subclass(*args_, **kwargs_)
        else:
            return DrivenBySupply(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inPort(self):
        return self.inPort
    def set_inPort(self, inPort):
        self.inPort = inPort
    def hasContent_(self):
        if (
            super(DrivenBySupply, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenBySupply', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrivenBySupply')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenBySupply')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DrivenBySupply', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DrivenBySupply'):
        super(DrivenBySupply, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenBySupply')
        if self.inPort is not None and 'inPort' not in already_processed:
            already_processed.add('inPort')
            outfile.write(' inPort=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inPort), input_name='inPort')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenBySupply', fromsubclass_=False, pretty_print=True):
        super(DrivenBySupply, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DrivenBySupply', mapping_=None):
        element = super(DrivenBySupply, self).to_etree(parent_element, name_, mapping_)
        if self.inPort is not None:
            element.set('inPort', self.gds_format_string(self.inPort))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inPort', node)
        if value is not None and 'inPort' not in already_processed:
            already_processed.add('inPort')
            self.inPort = value
        super(DrivenBySupply, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DrivenBySupply, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DrivenBySupply


class GasConversion(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasConversion, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasConversion.subclass:
            return GasConversion.subclass(*args_, **kwargs_)
        else:
            return GasConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(GasConversion, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasConversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasConversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasConversion'):
        super(GasConversion, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasConversion')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasConversion', fromsubclass_=False, pretty_print=True):
        super(GasConversion, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GasConversion', mapping_=None):
        element = super(GasConversion, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(GasConversion, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasConversion, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasConversion


class DrivenByDemand(ControlStrategy):
    subclass = None
    superclass = ControlStrategy
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, energyAsset=None, outPort=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(DrivenByDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, energyAsset,  **kwargs_)
        self.outPort = _cast(None, outPort)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrivenByDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrivenByDemand.subclass:
            return DrivenByDemand.subclass(*args_, **kwargs_)
        else:
            return DrivenByDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_outPort(self):
        return self.outPort
    def set_outPort(self, outPort):
        self.outPort = outPort
    def hasContent_(self):
        if (
            super(DrivenByDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenByDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrivenByDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenByDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='DrivenByDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='DrivenByDemand'):
        super(DrivenByDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrivenByDemand')
        if self.outPort is not None and 'outPort' not in already_processed:
            already_processed.add('outPort')
            outfile.write(' outPort=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.outPort), input_name='outPort')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='DrivenByDemand', fromsubclass_=False, pretty_print=True):
        super(DrivenByDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='DrivenByDemand', mapping_=None):
        element = super(DrivenByDemand, self).to_etree(parent_element, name_, mapping_)
        if self.outPort is not None:
            element.set('outPort', self.gds_format_string(self.outPort))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('outPort', node)
        if value is not None and 'outPort' not in already_processed:
            already_processed.add('outPort')
            self.outPort = value
        super(DrivenByDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DrivenByDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DrivenByDemand


class GasStorage(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, minStoragePressure=None, maxStoragePressure=0.0, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasStorage, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
        self.minStoragePressure = _cast(float, minStoragePressure)
        self.maxStoragePressure = _cast(float, maxStoragePressure)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasStorage.subclass:
            return GasStorage.subclass(*args_, **kwargs_)
        else:
            return GasStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minStoragePressure(self):
        return self.minStoragePressure
    def set_minStoragePressure(self, minStoragePressure):
        self.minStoragePressure = minStoragePressure
    def get_maxStoragePressure(self):
        return self.maxStoragePressure
    def set_maxStoragePressure(self, maxStoragePressure):
        self.maxStoragePressure = maxStoragePressure
    def hasContent_(self):
        if (
            super(GasStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasStorage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasStorage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasStorage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasStorage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasStorage'):
        super(GasStorage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasStorage')
        if self.minStoragePressure is not None and 'minStoragePressure' not in already_processed:
            already_processed.add('minStoragePressure')
            outfile.write(' minStoragePressure="%s"' % self.gds_format_double(self.minStoragePressure, input_name='minStoragePressure'))
        if self.maxStoragePressure != 0.0 and 'maxStoragePressure' not in already_processed:
            already_processed.add('maxStoragePressure')
            outfile.write(' maxStoragePressure="%s"' % self.gds_format_double(self.maxStoragePressure, input_name='maxStoragePressure'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasStorage', fromsubclass_=False, pretty_print=True):
        super(GasStorage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GasStorage', mapping_=None):
        element = super(GasStorage, self).to_etree(parent_element, name_, mapping_)
        if self.minStoragePressure is not None:
            element.set('minStoragePressure', self.gds_format_double(self.minStoragePressure))
        if self.maxStoragePressure is not None:
            element.set('maxStoragePressure', self.gds_format_double(self.maxStoragePressure))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minStoragePressure', node)
        if value is not None and 'minStoragePressure' not in already_processed:
            already_processed.add('minStoragePressure')
            try:
                self.minStoragePressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minStoragePressure): %s' % exp)
        value = find_attr_value_('maxStoragePressure', node)
        if value is not None and 'maxStoragePressure' not in already_processed:
            already_processed.add('maxStoragePressure')
            try:
                self.maxStoragePressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxStoragePressure): %s' % exp)
        super(GasStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasStorage, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasStorage


class MobilityDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, fuelType=None, distance=None, efficiency=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(MobilityDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
        self.fuelType = _cast(None, fuelType)
        self.distance = _cast(int, distance)
        self.efficiency = _cast(float, efficiency)
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MobilityDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MobilityDemand.subclass:
            return MobilityDemand.subclass(*args_, **kwargs_)
        else:
            return MobilityDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def add_type(self, value):
        self.type_.append(value)
    def add_type(self, value):
        self.type_.append(value)
    def insert_type_at(self, index, value):
        self.type_.insert(index, value)
    def replace_type_at(self, index, value):
        self.type_[index] = value
    def get_fuelType(self):
        return self.fuelType
    def set_fuelType(self, fuelType):
        self.fuelType = fuelType
    def get_distance(self):
        return self.distance
    def set_distance(self, distance):
        self.distance = distance
    def get_efficiency(self):
        return self.efficiency
    def set_efficiency(self, efficiency):
        self.efficiency = efficiency
    def validate_VehicleTypeEnum(self, value):
        # Validate type VehicleTypeEnum, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['UNDEFINED', 'CAR', 'TRUCK', 'VAN', 'BUS', 'METRO', 'TRAM', 'TRAIN', 'PASSENGER_TRAIN', 'FREIGHT_TRAIN', 'SCOOTER', 'MOTOR_CYCLE', 'NONROAD_VEHICLE', 'AGRARIAN_VEHICLE', 'BARGE', 'INTERNATIONAL_SHIPPING', 'AIRCRAFT', 'OTHER', 'TOTAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VehicleTypeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ or
            super(MobilityDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MobilityDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MobilityDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='MobilityDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='MobilityDemand'):
        super(MobilityDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MobilityDemand')
        if self.fuelType is not None and 'fuelType' not in already_processed:
            already_processed.add('fuelType')
            outfile.write(' fuelType=%s' % (quote_attrib(self.fuelType), ))
        if self.distance is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            outfile.write(' distance="%s"' % self.gds_format_integer(self.distance, input_name='distance'))
        if self.efficiency is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            outfile.write(' efficiency="%s"' % self.gds_format_double(self.efficiency, input_name='efficiency'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='MobilityDemand', fromsubclass_=False, pretty_print=True):
        super(MobilityDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for type_ in self.type_:
            type_.export(outfile, level, namespaceprefix_, name_='type', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='MobilityDemand', mapping_=None):
        element = super(MobilityDemand, self).to_etree(parent_element, name_, mapping_)
        if self.fuelType is not None:
            element.set('fuelType', self.fuelType)
        if self.distance is not None:
            element.set('distance', self.gds_format_integer(self.distance))
        if self.efficiency is not None:
            element.set('efficiency', self.gds_format_double(self.efficiency))
        for type__ in self.type_:
            type__.to_etree(element, name_='type', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fuelType', node)
        if value is not None and 'fuelType' not in already_processed:
            already_processed.add('fuelType')
            self.fuelType = value
        value = find_attr_value_('distance', node)
        if value is not None and 'distance' not in already_processed:
            already_processed.add('distance')
            try:
                self.distance = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('efficiency', node)
        if value is not None and 'efficiency' not in already_processed:
            already_processed.add('efficiency')
            try:
                self.efficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (efficiency): %s' % exp)
        super(MobilityDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = None
            self.type_.append(obj_)
            obj_.original_tagname_ = 'type'
            # validate type VehicleTypeEnum
            self.validate_VehicleTypeEnum(self.type_[-1])
        super(MobilityDemand, self).buildChildren(child_, node, nodeName_, True)
# end class MobilityDemand


class FermentationPlant(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(FermentationPlant, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FermentationPlant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FermentationPlant.subclass:
            return FermentationPlant.subclass(*args_, **kwargs_)
        else:
            return FermentationPlant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FermentationPlant, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='FermentationPlant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FermentationPlant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FermentationPlant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='FermentationPlant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='FermentationPlant'):
        super(FermentationPlant, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FermentationPlant')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='FermentationPlant', fromsubclass_=False, pretty_print=True):
        super(FermentationPlant, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FermentationPlant', mapping_=None):
        element = super(FermentationPlant, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FermentationPlant, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FermentationPlant, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FermentationPlant


class ResidualHeatSource(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, type_=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ResidualHeatSource, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.residualHeatSourcePotential = _cast(None, residualHeatSourcePotential)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResidualHeatSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResidualHeatSource.subclass:
            return ResidualHeatSource.subclass(*args_, **kwargs_)
        else:
            return ResidualHeatSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_residualHeatSourcePotential(self):
        return self.residualHeatSourcePotential
    def set_residualHeatSourcePotential(self, residualHeatSourcePotential):
        self.residualHeatSourcePotential = residualHeatSourcePotential
    def hasContent_(self):
        if (
            super(ResidualHeatSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ResidualHeatSource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResidualHeatSource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidualHeatSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ResidualHeatSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ResidualHeatSource'):
        super(ResidualHeatSource, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResidualHeatSource')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.residualHeatSourcePotential is not None and 'residualHeatSourcePotential' not in already_processed:
            already_processed.add('residualHeatSourcePotential')
            outfile.write(' residualHeatSourcePotential=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.residualHeatSourcePotential), input_name='residualHeatSourcePotential')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ResidualHeatSource', fromsubclass_=False, pretty_print=True):
        super(ResidualHeatSource, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ResidualHeatSource', mapping_=None):
        element = super(ResidualHeatSource, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.residualHeatSourcePotential is not None:
            element.set('residualHeatSourcePotential', self.gds_format_string(self.residualHeatSourcePotential))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('residualHeatSourcePotential', node)
        if value is not None and 'residualHeatSourcePotential' not in already_processed:
            already_processed.add('residualHeatSourcePotential')
            self.residualHeatSourcePotential = value
        super(ResidualHeatSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResidualHeatSource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResidualHeatSource


class SolarCollector(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SolarCollector, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SolarCollector)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SolarCollector.subclass:
            return SolarCollector.subclass(*args_, **kwargs_)
        else:
            return SolarCollector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(SolarCollector, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SolarCollector', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SolarCollector')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolarCollector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SolarCollector', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SolarCollector'):
        super(SolarCollector, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SolarCollector')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SolarCollector', fromsubclass_=False, pretty_print=True):
        super(SolarCollector, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SolarCollector', mapping_=None):
        element = super(SolarCollector, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(SolarCollector, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SolarCollector, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SolarCollector


class EnergyDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EnergyDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnergyDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnergyDemand.subclass:
            return EnergyDemand.subclass(*args_, **kwargs_)
        else:
            return EnergyDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EnergyDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnergyDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EnergyDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EnergyDemand'):
        super(EnergyDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnergyDemand')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EnergyDemand', fromsubclass_=False, pretty_print=True):
        super(EnergyDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EnergyDemand', mapping_=None):
        element = super(EnergyDemand, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EnergyDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EnergyDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EnergyDemand


class Airco(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Airco, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Airco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Airco.subclass:
            return Airco.subclass(*args_, **kwargs_)
        else:
            return Airco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Airco, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Airco', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Airco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Airco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Airco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Airco'):
        super(Airco, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Airco')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Airco', fromsubclass_=False, pretty_print=True):
        super(Airco, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Airco', mapping_=None):
        element = super(Airco, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Airco, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Airco, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Airco


class CoolingDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, deviceType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CoolingDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
        self.deviceType = _cast(None, deviceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoolingDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoolingDemand.subclass:
            return CoolingDemand.subclass(*args_, **kwargs_)
        else:
            return CoolingDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceType(self):
        return self.deviceType
    def set_deviceType(self, deviceType):
        self.deviceType = deviceType
    def hasContent_(self):
        if (
            super(CoolingDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CoolingDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoolingDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoolingDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CoolingDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CoolingDemand'):
        super(CoolingDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoolingDemand')
        if self.deviceType is not None and 'deviceType' not in already_processed:
            already_processed.add('deviceType')
            outfile.write(' deviceType=%s' % (quote_attrib(self.deviceType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CoolingDemand', fromsubclass_=False, pretty_print=True):
        super(CoolingDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CoolingDemand', mapping_=None):
        element = super(CoolingDemand, self).to_etree(parent_element, name_, mapping_)
        if self.deviceType is not None:
            element.set('deviceType', self.deviceType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deviceType', node)
        if value is not None and 'deviceType' not in already_processed:
            already_processed.add('deviceType')
            self.deviceType = value
        super(CoolingDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CoolingDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CoolingDemand


class Valve(AbstractSwitch):
    subclass = None
    superclass = AbstractSwitch
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Valve, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Valve)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Valve.subclass:
            return Valve.subclass(*args_, **kwargs_)
        else:
            return Valve(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Valve, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Valve', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Valve')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Valve')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Valve', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Valve'):
        super(Valve, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Valve')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Valve', fromsubclass_=False, pretty_print=True):
        super(Valve, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Valve', mapping_=None):
        element = super(Valve, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Valve, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Valve, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Valve


class Pump(AbstractTransformer):
    subclass = None
    superclass = AbstractTransformer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Pump, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Pump)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Pump.subclass:
            return Pump.subclass(*args_, **kwargs_)
        else:
            return Pump(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Pump, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Pump', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Pump')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pump')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Pump', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Pump'):
        super(Pump, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pump')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Pump', fromsubclass_=False, pretty_print=True):
        super(Pump, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Pump', mapping_=None):
        element = super(Pump, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Pump, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Pump, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Pump


class XToPower(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(XToPower, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, XToPower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if XToPower.subclass:
            return XToPower.subclass(*args_, **kwargs_)
        else:
            return XToPower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(XToPower, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='XToPower', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('XToPower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XToPower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='XToPower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='XToPower'):
        super(XToPower, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='XToPower')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='XToPower', fromsubclass_=False, pretty_print=True):
        super(XToPower, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='XToPower', mapping_=None):
        element = super(XToPower, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(XToPower, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(XToPower, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class XToPower


class CCS(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CCS, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CCS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CCS.subclass:
            return CCS.subclass(*args_, **kwargs_)
        else:
            return CCS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CCS, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CCS', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CCS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CCS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CCS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CCS'):
        super(CCS, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CCS')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CCS', fromsubclass_=False, pretty_print=True):
        super(CCS, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CCS', mapping_=None):
        element = super(CCS, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CCS, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CCS, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CCS


class PowerToX(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PowerToX, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerToX)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerToX.subclass:
            return PowerToX.subclass(*args_, **kwargs_)
        else:
            return PowerToX(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PowerToX, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PowerToX', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerToX')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerToX')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PowerToX', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PowerToX'):
        super(PowerToX, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerToX')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PowerToX', fromsubclass_=False, pretty_print=True):
        super(PowerToX, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PowerToX', mapping_=None):
        element = super(PowerToX, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PowerToX, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PowerToX, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PowerToX


class Losses(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Losses, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Losses)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Losses.subclass:
            return Losses.subclass(*args_, **kwargs_)
        else:
            return Losses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Losses, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Losses', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Losses')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Losses')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Losses', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Losses'):
        super(Losses, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Losses')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Losses', fromsubclass_=False, pretty_print=True):
        super(Losses, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Losses', mapping_=None):
        element = super(Losses, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Losses, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Losses, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Losses


class AggregatedBuilding(AbstractBuilding):
    subclass = None
    superclass = AbstractBuilding
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, energyLabel=None, energyIndex=None, asset=None, numberOfBuildings=None, aggregationOf=None, energyLabelDistribution=None, buildingYearDistribution=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedBuilding, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, energyLabel, energyIndex, asset,  **kwargs_)
        self.numberOfBuildings = _cast(int, numberOfBuildings)
        self.aggregationOf = _cast(None, aggregationOf)
        self.energyLabelDistribution = energyLabelDistribution
        self.buildingYearDistribution = buildingYearDistribution
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedBuilding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedBuilding.subclass:
            return AggregatedBuilding.subclass(*args_, **kwargs_)
        else:
            return AggregatedBuilding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyLabelDistribution(self):
        return self.energyLabelDistribution
    def set_energyLabelDistribution(self, energyLabelDistribution):
        self.energyLabelDistribution = energyLabelDistribution
    def get_buildingYearDistribution(self):
        return self.buildingYearDistribution
    def set_buildingYearDistribution(self, buildingYearDistribution):
        self.buildingYearDistribution = buildingYearDistribution
    def get_numberOfBuildings(self):
        return self.numberOfBuildings
    def set_numberOfBuildings(self, numberOfBuildings):
        self.numberOfBuildings = numberOfBuildings
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            self.energyLabelDistribution is not None or
            self.buildingYearDistribution is not None or
            super(AggregatedBuilding, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedBuilding', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedBuilding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedBuilding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedBuilding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedBuilding'):
        super(AggregatedBuilding, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedBuilding')
        if self.numberOfBuildings is not None and 'numberOfBuildings' not in already_processed:
            already_processed.add('numberOfBuildings')
            outfile.write(' numberOfBuildings="%s"' % self.gds_format_integer(self.numberOfBuildings, input_name='numberOfBuildings'))
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedBuilding', fromsubclass_=False, pretty_print=True):
        super(AggregatedBuilding, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyLabelDistribution is not None:
            self.energyLabelDistribution.export(outfile, level, namespaceprefix_, name_='energyLabelDistribution', pretty_print=pretty_print)
        if self.buildingYearDistribution is not None:
            self.buildingYearDistribution.export(outfile, level, namespaceprefix_, name_='buildingYearDistribution', pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedBuilding', mapping_=None):
        element = super(AggregatedBuilding, self).to_etree(parent_element, name_, mapping_)
        if self.numberOfBuildings is not None:
            element.set('numberOfBuildings', self.gds_format_integer(self.numberOfBuildings))
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if self.energyLabelDistribution is not None:
            energyLabelDistribution_ = self.energyLabelDistribution
            energyLabelDistribution_.to_etree(element, name_='energyLabelDistribution', mapping_=mapping_)
        if self.buildingYearDistribution is not None:
            buildingYearDistribution_ = self.buildingYearDistribution
            buildingYearDistribution_.to_etree(element, name_='buildingYearDistribution', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfBuildings', node)
        if value is not None and 'numberOfBuildings' not in already_processed:
            already_processed.add('numberOfBuildings')
            try:
                self.numberOfBuildings = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedBuilding, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energyLabelDistribution':
            obj_ = EnergyLabelDistribution.factory(parent_object_=self)
            obj_.build(child_)
            self.energyLabelDistribution = obj_
            obj_.original_tagname_ = 'energyLabelDistribution'
        elif nodeName_ == 'buildingYearDistribution':
            obj_ = FromToDistribution.factory(parent_object_=self)
            obj_.build(child_)
            self.buildingYearDistribution = obj_
            obj_.original_tagname_ = 'buildingYearDistribution'
        super(AggregatedBuilding, self).buildChildren(child_, node, nodeName_, True)
# end class AggregatedBuilding


class EVChargingStation(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EVChargingStation, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EVChargingStation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EVChargingStation.subclass:
            return EVChargingStation.subclass(*args_, **kwargs_)
        else:
            return EVChargingStation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EVChargingStation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EVChargingStation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EVChargingStation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EVChargingStation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EVChargingStation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EVChargingStation'):
        super(EVChargingStation, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EVChargingStation')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EVChargingStation', fromsubclass_=False, pretty_print=True):
        super(EVChargingStation, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EVChargingStation', mapping_=None):
        element = super(EVChargingStation, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EVChargingStation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EVChargingStation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EVChargingStation


class PowerPlant(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, fuel=None, maxLoad=None, minLoad=None, effMaxLoad=None, effMinLoad=None, energyCarrier=None, mustRun=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PowerPlant, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.fuel = _cast(None, fuel)
        self.maxLoad = _cast(int, maxLoad)
        self.minLoad = _cast(int, minLoad)
        self.effMaxLoad = _cast(float, effMaxLoad)
        self.effMinLoad = _cast(float, effMinLoad)
        self.energyCarrier = _cast(None, energyCarrier)
        self.mustRun = mustRun
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerPlant)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerPlant.subclass:
            return PowerPlant.subclass(*args_, **kwargs_)
        else:
            return PowerPlant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mustRun(self):
        return self.mustRun
    def set_mustRun(self, mustRun):
        self.mustRun = mustRun
    def get_fuel(self):
        return self.fuel
    def set_fuel(self, fuel):
        self.fuel = fuel
    def get_maxLoad(self):
        return self.maxLoad
    def set_maxLoad(self, maxLoad):
        self.maxLoad = maxLoad
    def get_minLoad(self):
        return self.minLoad
    def set_minLoad(self, minLoad):
        self.minLoad = minLoad
    def get_effMaxLoad(self):
        return self.effMaxLoad
    def set_effMaxLoad(self, effMaxLoad):
        self.effMaxLoad = effMaxLoad
    def get_effMinLoad(self):
        return self.effMinLoad
    def set_effMinLoad(self, effMinLoad):
        self.effMinLoad = effMinLoad
    def get_energyCarrier(self):
        return self.energyCarrier
    def set_energyCarrier(self, energyCarrier):
        self.energyCarrier = energyCarrier
    def hasContent_(self):
        if (
            self.mustRun is not None or
            super(PowerPlant, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PowerPlant', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerPlant')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerPlant')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PowerPlant', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PowerPlant'):
        super(PowerPlant, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerPlant')
        if self.fuel is not None and 'fuel' not in already_processed:
            already_processed.add('fuel')
            outfile.write(' fuel=%s' % (quote_attrib(self.fuel), ))
        if self.maxLoad is not None and 'maxLoad' not in already_processed:
            already_processed.add('maxLoad')
            outfile.write(' maxLoad="%s"' % self.gds_format_integer(self.maxLoad, input_name='maxLoad'))
        if self.minLoad is not None and 'minLoad' not in already_processed:
            already_processed.add('minLoad')
            outfile.write(' minLoad="%s"' % self.gds_format_integer(self.minLoad, input_name='minLoad'))
        if self.effMaxLoad is not None and 'effMaxLoad' not in already_processed:
            already_processed.add('effMaxLoad')
            outfile.write(' effMaxLoad="%s"' % self.gds_format_double(self.effMaxLoad, input_name='effMaxLoad'))
        if self.effMinLoad is not None and 'effMinLoad' not in already_processed:
            already_processed.add('effMinLoad')
            outfile.write(' effMinLoad="%s"' % self.gds_format_double(self.effMinLoad, input_name='effMinLoad'))
        if self.energyCarrier is not None and 'energyCarrier' not in already_processed:
            already_processed.add('energyCarrier')
            outfile.write(' energyCarrier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.energyCarrier), input_name='energyCarrier')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PowerPlant', fromsubclass_=False, pretty_print=True):
        super(PowerPlant, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mustRun is not None:
            self.mustRun.export(outfile, level, namespaceprefix_, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PowerPlant', mapping_=None):
        element = super(PowerPlant, self).to_etree(parent_element, name_, mapping_)
        if self.fuel is not None:
            element.set('fuel', self.fuel)
        if self.maxLoad is not None:
            element.set('maxLoad', self.gds_format_integer(self.maxLoad))
        if self.minLoad is not None:
            element.set('minLoad', self.gds_format_integer(self.minLoad))
        if self.effMaxLoad is not None:
            element.set('effMaxLoad', self.gds_format_double(self.effMaxLoad))
        if self.effMinLoad is not None:
            element.set('effMinLoad', self.gds_format_double(self.effMinLoad))
        if self.energyCarrier is not None:
            element.set('energyCarrier', self.gds_format_string(self.energyCarrier))
        if self.mustRun is not None:
            mustRun_ = self.mustRun
            mustRun_.to_etree(element, name_='mustRun', mapping_=mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fuel', node)
        if value is not None and 'fuel' not in already_processed:
            already_processed.add('fuel')
            self.fuel = value
        value = find_attr_value_('maxLoad', node)
        if value is not None and 'maxLoad' not in already_processed:
            already_processed.add('maxLoad')
            try:
                self.maxLoad = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minLoad', node)
        if value is not None and 'minLoad' not in already_processed:
            already_processed.add('minLoad')
            try:
                self.minLoad = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('effMaxLoad', node)
        if value is not None and 'effMaxLoad' not in already_processed:
            already_processed.add('effMaxLoad')
            try:
                self.effMaxLoad = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (effMaxLoad): %s' % exp)
        value = find_attr_value_('effMinLoad', node)
        if value is not None and 'effMinLoad' not in already_processed:
            already_processed.add('effMinLoad')
            try:
                self.effMinLoad = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (effMinLoad): %s' % exp)
        value = find_attr_value_('energyCarrier', node)
        if value is not None and 'energyCarrier' not in already_processed:
            already_processed.add('energyCarrier')
            self.energyCarrier = value
        super(PowerPlant, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mustRun':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <mustRun> element')
            self.mustRun = obj_
            obj_.original_tagname_ = 'mustRun'
        super(PowerPlant, self).buildChildren(child_, node, nodeName_, True)
# end class PowerPlant


class GConnection(AbstractConnection):
    subclass = None
    superclass = AbstractConnection
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GConnection, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GConnection.subclass:
            return GConnection.subclass(*args_, **kwargs_)
        else:
            return GConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GConnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GConnection'):
        super(GConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GConnection')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GConnection', fromsubclass_=False, pretty_print=True):
        super(GConnection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GConnection', mapping_=None):
        element = super(GConnection, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GConnection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GConnection


class HConnection(AbstractConnection):
    subclass = None
    superclass = AbstractConnection
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HConnection, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HConnection.subclass:
            return HConnection.subclass(*args_, **kwargs_)
        else:
            return HConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HConnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HConnection'):
        super(HConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HConnection')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HConnection', fromsubclass_=False, pretty_print=True):
        super(HConnection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HConnection', mapping_=None):
        element = super(HConnection, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HConnection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HConnection


class EConnection(AbstractConnection):
    subclass = None
    superclass = AbstractConnection
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, EANCode=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(EConnection, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.EANCode = _cast(None, EANCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EConnection)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EConnection.subclass:
            return EConnection.subclass(*args_, **kwargs_)
        else:
            return EConnection(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EANCode(self):
        return self.EANCode
    def set_EANCode(self, EANCode):
        self.EANCode = EANCode
    def hasContent_(self):
        if (
            super(EConnection, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='EConnection', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EConnection')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EConnection')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='EConnection', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='EConnection'):
        super(EConnection, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EConnection')
        if self.EANCode is not None and 'EANCode' not in already_processed:
            already_processed.add('EANCode')
            outfile.write(' EANCode=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.EANCode), input_name='EANCode')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='EConnection', fromsubclass_=False, pretty_print=True):
        super(EConnection, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='EConnection', mapping_=None):
        element = super(EConnection, self).to_etree(parent_element, name_, mapping_)
        if self.EANCode is not None:
            element.set('EANCode', self.gds_format_string(self.EANCode))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('EANCode', node)
        if value is not None and 'EANCode' not in already_processed:
            already_processed.add('EANCode')
            self.EANCode = value
        super(EConnection, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EConnection, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EConnection


class HeatExchange(AbstractTransformer):
    subclass = None
    superclass = AbstractTransformer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, LossDeltaT=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatExchange, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.LossDeltaT = _cast(float, LossDeltaT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatExchange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatExchange.subclass:
            return HeatExchange.subclass(*args_, **kwargs_)
        else:
            return HeatExchange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LossDeltaT(self):
        return self.LossDeltaT
    def set_LossDeltaT(self, LossDeltaT):
        self.LossDeltaT = LossDeltaT
    def hasContent_(self):
        if (
            super(HeatExchange, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatExchange', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatExchange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatExchange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatExchange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatExchange'):
        super(HeatExchange, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatExchange')
        if self.LossDeltaT is not None and 'LossDeltaT' not in already_processed:
            already_processed.add('LossDeltaT')
            outfile.write(' LossDeltaT="%s"' % self.gds_format_double(self.LossDeltaT, input_name='LossDeltaT'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatExchange', fromsubclass_=False, pretty_print=True):
        super(HeatExchange, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HeatExchange', mapping_=None):
        element = super(HeatExchange, self).to_etree(parent_element, name_, mapping_)
        if self.LossDeltaT is not None:
            element.set('LossDeltaT', self.gds_format_double(self.LossDeltaT))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('LossDeltaT', node)
        if value is not None and 'LossDeltaT' not in already_processed:
            already_processed.add('LossDeltaT')
            try:
                self.LossDeltaT = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (LossDeltaT): %s' % exp)
        super(HeatExchange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatExchange, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatExchange


class Transformer(AbstractTransformer):
    subclass = None
    superclass = AbstractTransformer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, voltagePrimary=None, voltageSecundary=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Transformer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.voltagePrimary = _cast(float, voltagePrimary)
        self.voltageSecundary = _cast(float, voltageSecundary)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Transformer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Transformer.subclass:
            return Transformer.subclass(*args_, **kwargs_)
        else:
            return Transformer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voltagePrimary(self):
        return self.voltagePrimary
    def set_voltagePrimary(self, voltagePrimary):
        self.voltagePrimary = voltagePrimary
    def get_voltageSecundary(self):
        return self.voltageSecundary
    def set_voltageSecundary(self, voltageSecundary):
        self.voltageSecundary = voltageSecundary
    def hasContent_(self):
        if (
            super(Transformer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Transformer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Transformer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transformer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Transformer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Transformer'):
        super(Transformer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Transformer')
        if self.voltagePrimary is not None and 'voltagePrimary' not in already_processed:
            already_processed.add('voltagePrimary')
            outfile.write(' voltagePrimary="%s"' % self.gds_format_double(self.voltagePrimary, input_name='voltagePrimary'))
        if self.voltageSecundary is not None and 'voltageSecundary' not in already_processed:
            already_processed.add('voltageSecundary')
            outfile.write(' voltageSecundary="%s"' % self.gds_format_double(self.voltageSecundary, input_name='voltageSecundary'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Transformer', fromsubclass_=False, pretty_print=True):
        super(Transformer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Transformer', mapping_=None):
        element = super(Transformer, self).to_etree(parent_element, name_, mapping_)
        if self.voltagePrimary is not None:
            element.set('voltagePrimary', self.gds_format_double(self.voltagePrimary))
        if self.voltageSecundary is not None:
            element.set('voltageSecundary', self.gds_format_double(self.voltageSecundary))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('voltagePrimary', node)
        if value is not None and 'voltagePrimary' not in already_processed:
            already_processed.add('voltagePrimary')
            try:
                self.voltagePrimary = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (voltagePrimary): %s' % exp)
        value = find_attr_value_('voltageSecundary', node)
        if value is not None and 'voltageSecundary' not in already_processed:
            already_processed.add('voltageSecundary')
            try:
                self.voltageSecundary = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (voltageSecundary): %s' % exp)
        super(Transformer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Transformer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Transformer


class GasDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasDemand.subclass:
            return GasDemand.subclass(*args_, **kwargs_)
        else:
            return GasDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GasDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasDemand'):
        super(GasDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasDemand')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasDemand', fromsubclass_=False, pretty_print=True):
        super(GasDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GasDemand', mapping_=None):
        element = super(GasDemand, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GasDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasDemand


class ElectricityDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ElectricityDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityDemand.subclass:
            return ElectricityDemand.subclass(*args_, **kwargs_)
        else:
            return ElectricityDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ElectricityDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricityDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ElectricityDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ElectricityDemand'):
        super(ElectricityDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityDemand')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityDemand', fromsubclass_=False, pretty_print=True):
        super(ElectricityDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ElectricityDemand', mapping_=None):
        element = super(ElectricityDemand, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ElectricityDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ElectricityDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ElectricityDemand


class HeatingDemand(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, type_=None, deviceType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatingDemand, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
        self.type_ = _cast(None, type_)
        self.deviceType = _cast(None, deviceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatingDemand)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatingDemand.subclass:
            return HeatingDemand.subclass(*args_, **kwargs_)
        else:
            return HeatingDemand(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_deviceType(self):
        return self.deviceType
    def set_deviceType(self, deviceType):
        self.deviceType = deviceType
    def hasContent_(self):
        if (
            super(HeatingDemand, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatingDemand', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatingDemand')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatingDemand')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatingDemand', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatingDemand'):
        super(HeatingDemand, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatingDemand')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.deviceType is not None and 'deviceType' not in already_processed:
            already_processed.add('deviceType')
            outfile.write(' deviceType=%s' % (quote_attrib(self.deviceType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatingDemand', fromsubclass_=False, pretty_print=True):
        super(HeatingDemand, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HeatingDemand', mapping_=None):
        element = super(HeatingDemand, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.deviceType is not None:
            element.set('deviceType', self.deviceType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('deviceType', node)
        if value is not None and 'deviceType' not in already_processed:
            already_processed.add('deviceType')
            self.deviceType = value
        super(HeatingDemand, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatingDemand, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatingDemand


class HeatPump(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, source=None, stages=1, COP=None, additionalHeatingSourceType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatPump, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.source = _cast(None, source)
        self.stages = _cast(int, stages)
        self.COP = _cast(float, COP)
        self.additionalHeatingSourceType = _cast(None, additionalHeatingSourceType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatPump)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatPump.subclass:
            return HeatPump.subclass(*args_, **kwargs_)
        else:
            return HeatPump(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self):
        return self.source
    def set_source(self, source):
        self.source = source
    def get_stages(self):
        return self.stages
    def set_stages(self, stages):
        self.stages = stages
    def get_COP(self):
        return self.COP
    def set_COP(self, COP):
        self.COP = COP
    def get_additionalHeatingSourceType(self):
        return self.additionalHeatingSourceType
    def set_additionalHeatingSourceType(self, additionalHeatingSourceType):
        self.additionalHeatingSourceType = additionalHeatingSourceType
    def hasContent_(self):
        if (
            super(HeatPump, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatPump', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatPump')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatPump')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatPump', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatPump'):
        super(HeatPump, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatPump')
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (quote_attrib(self.source), ))
        if self.stages != 1 and 'stages' not in already_processed:
            already_processed.add('stages')
            outfile.write(' stages="%s"' % self.gds_format_integer(self.stages, input_name='stages'))
        if self.COP is not None and 'COP' not in already_processed:
            already_processed.add('COP')
            outfile.write(' COP="%s"' % self.gds_format_double(self.COP, input_name='COP'))
        if self.additionalHeatingSourceType is not None and 'additionalHeatingSourceType' not in already_processed:
            already_processed.add('additionalHeatingSourceType')
            outfile.write(' additionalHeatingSourceType=%s' % (quote_attrib(self.additionalHeatingSourceType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatPump', fromsubclass_=False, pretty_print=True):
        super(HeatPump, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HeatPump', mapping_=None):
        element = super(HeatPump, self).to_etree(parent_element, name_, mapping_)
        if self.source is not None:
            element.set('source', self.source)
        if self.stages is not None:
            element.set('stages', self.gds_format_integer(self.stages))
        if self.COP is not None:
            element.set('COP', self.gds_format_double(self.COP))
        if self.additionalHeatingSourceType is not None:
            element.set('additionalHeatingSourceType', self.additionalHeatingSourceType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        value = find_attr_value_('stages', node)
        if value is not None and 'stages' not in already_processed:
            already_processed.add('stages')
            try:
                self.stages = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('COP', node)
        if value is not None and 'COP' not in already_processed:
            already_processed.add('COP')
            try:
                self.COP = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (COP): %s' % exp)
        value = find_attr_value_('additionalHeatingSourceType', node)
        if value is not None and 'additionalHeatingSourceType' not in already_processed:
            already_processed.add('additionalHeatingSourceType')
            self.additionalHeatingSourceType = value
        super(HeatPump, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatPump, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatPump


class CoGeneration(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, heatEfficiency=0.0, electricalEfficiency=0.0, HERatio=None, fuelType=None, leadCommodity=None, energyCarrier=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CoGeneration, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential, extensiontype_,  **kwargs_)
        self.heatEfficiency = _cast(float, heatEfficiency)
        self.electricalEfficiency = _cast(float, electricalEfficiency)
        self.HERatio = _cast(float, HERatio)
        self.fuelType = _cast(None, fuelType)
        self.leadCommodity = _cast(None, leadCommodity)
        self.energyCarrier = _cast(None, energyCarrier)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CoGeneration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CoGeneration.subclass:
            return CoGeneration.subclass(*args_, **kwargs_)
        else:
            return CoGeneration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_heatEfficiency(self):
        return self.heatEfficiency
    def set_heatEfficiency(self, heatEfficiency):
        self.heatEfficiency = heatEfficiency
    def get_electricalEfficiency(self):
        return self.electricalEfficiency
    def set_electricalEfficiency(self, electricalEfficiency):
        self.electricalEfficiency = electricalEfficiency
    def get_HERatio(self):
        return self.HERatio
    def set_HERatio(self, HERatio):
        self.HERatio = HERatio
    def get_fuelType(self):
        return self.fuelType
    def set_fuelType(self, fuelType):
        self.fuelType = fuelType
    def get_leadCommodity(self):
        return self.leadCommodity
    def set_leadCommodity(self, leadCommodity):
        self.leadCommodity = leadCommodity
    def get_energyCarrier(self):
        return self.energyCarrier
    def set_energyCarrier(self, energyCarrier):
        self.energyCarrier = energyCarrier
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(CoGeneration, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CoGeneration', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CoGeneration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoGeneration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CoGeneration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CoGeneration'):
        super(CoGeneration, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CoGeneration')
        if self.heatEfficiency != 0.0 and 'heatEfficiency' not in already_processed:
            already_processed.add('heatEfficiency')
            outfile.write(' heatEfficiency="%s"' % self.gds_format_double(self.heatEfficiency, input_name='heatEfficiency'))
        if self.electricalEfficiency != 0.0 and 'electricalEfficiency' not in already_processed:
            already_processed.add('electricalEfficiency')
            outfile.write(' electricalEfficiency="%s"' % self.gds_format_double(self.electricalEfficiency, input_name='electricalEfficiency'))
        if self.HERatio is not None and 'HERatio' not in already_processed:
            already_processed.add('HERatio')
            outfile.write(' HERatio="%s"' % self.gds_format_double(self.HERatio, input_name='HERatio'))
        if self.fuelType is not None and 'fuelType' not in already_processed:
            already_processed.add('fuelType')
            outfile.write(' fuelType=%s' % (quote_attrib(self.fuelType), ))
        if self.leadCommodity is not None and 'leadCommodity' not in already_processed:
            already_processed.add('leadCommodity')
            outfile.write(' leadCommodity=%s' % (quote_attrib(self.leadCommodity), ))
        if self.energyCarrier is not None and 'energyCarrier' not in already_processed:
            already_processed.add('energyCarrier')
            outfile.write(' energyCarrier=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.energyCarrier), input_name='energyCarrier')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if namespaceprefix_ not in self.extensiontype_:
                outfile.write(' xsi:type="%s%s"' % (namespaceprefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CoGeneration', fromsubclass_=False, pretty_print=True):
        super(CoGeneration, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CoGeneration', mapping_=None):
        element = super(CoGeneration, self).to_etree(parent_element, name_, mapping_)
        if self.extensiontype_ is not None:
            element.set('{http://www.w3.org/2001/XMLSchema-instance}type', self.extensiontype_)
        if self.heatEfficiency is not None:
            element.set('heatEfficiency', self.gds_format_double(self.heatEfficiency))
        if self.electricalEfficiency is not None:
            element.set('electricalEfficiency', self.gds_format_double(self.electricalEfficiency))
        if self.HERatio is not None:
            element.set('HERatio', self.gds_format_double(self.HERatio))
        if self.fuelType is not None:
            element.set('fuelType', self.fuelType)
        if self.leadCommodity is not None:
            element.set('leadCommodity', self.leadCommodity)
        if self.energyCarrier is not None:
            element.set('energyCarrier', self.gds_format_string(self.energyCarrier))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('heatEfficiency', node)
        if value is not None and 'heatEfficiency' not in already_processed:
            already_processed.add('heatEfficiency')
            try:
                self.heatEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (heatEfficiency): %s' % exp)
        value = find_attr_value_('electricalEfficiency', node)
        if value is not None and 'electricalEfficiency' not in already_processed:
            already_processed.add('electricalEfficiency')
            try:
                self.electricalEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (electricalEfficiency): %s' % exp)
        value = find_attr_value_('HERatio', node)
        if value is not None and 'HERatio' not in already_processed:
            already_processed.add('HERatio')
            try:
                self.HERatio = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (HERatio): %s' % exp)
        value = find_attr_value_('fuelType', node)
        if value is not None and 'fuelType' not in already_processed:
            already_processed.add('fuelType')
            self.fuelType = value
        value = find_attr_value_('leadCommodity', node)
        if value is not None and 'leadCommodity' not in already_processed:
            already_processed.add('leadCommodity')
            self.leadCommodity = value
        value = find_attr_value_('energyCarrier', node)
        if value is not None and 'energyCarrier' not in already_processed:
            already_processed.add('energyCarrier')
            self.energyCarrier = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CoGeneration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CoGeneration, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CoGeneration


class GeothermalSource(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, wellDepth=None, geothermalSourceType=None, COP=None, aquiferTemperature=None, flowRate=None, pumpPower=None, geothermalPotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GeothermalSource, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.wellDepth = _cast(float, wellDepth)
        self.geothermalSourceType = _cast(None, geothermalSourceType)
        self.COP = _cast(float, COP)
        self.aquiferTemperature = _cast(float, aquiferTemperature)
        self.flowRate = _cast(float, flowRate)
        self.pumpPower = _cast(float, pumpPower)
        self.geothermalPotential = _cast(None, geothermalPotential)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GeothermalSource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GeothermalSource.subclass:
            return GeothermalSource.subclass(*args_, **kwargs_)
        else:
            return GeothermalSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_wellDepth(self):
        return self.wellDepth
    def set_wellDepth(self, wellDepth):
        self.wellDepth = wellDepth
    def get_geothermalSourceType(self):
        return self.geothermalSourceType
    def set_geothermalSourceType(self, geothermalSourceType):
        self.geothermalSourceType = geothermalSourceType
    def get_COP(self):
        return self.COP
    def set_COP(self, COP):
        self.COP = COP
    def get_aquiferTemperature(self):
        return self.aquiferTemperature
    def set_aquiferTemperature(self, aquiferTemperature):
        self.aquiferTemperature = aquiferTemperature
    def get_flowRate(self):
        return self.flowRate
    def set_flowRate(self, flowRate):
        self.flowRate = flowRate
    def get_pumpPower(self):
        return self.pumpPower
    def set_pumpPower(self, pumpPower):
        self.pumpPower = pumpPower
    def get_geothermalPotential(self):
        return self.geothermalPotential
    def set_geothermalPotential(self, geothermalPotential):
        self.geothermalPotential = geothermalPotential
    def hasContent_(self):
        if (
            super(GeothermalSource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalSource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GeothermalSource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalSource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GeothermalSource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GeothermalSource'):
        super(GeothermalSource, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GeothermalSource')
        if self.wellDepth is not None and 'wellDepth' not in already_processed:
            already_processed.add('wellDepth')
            outfile.write(' wellDepth="%s"' % self.gds_format_double(self.wellDepth, input_name='wellDepth'))
        if self.geothermalSourceType is not None and 'geothermalSourceType' not in already_processed:
            already_processed.add('geothermalSourceType')
            outfile.write(' geothermalSourceType=%s' % (quote_attrib(self.geothermalSourceType), ))
        if self.COP is not None and 'COP' not in already_processed:
            already_processed.add('COP')
            outfile.write(' COP="%s"' % self.gds_format_double(self.COP, input_name='COP'))
        if self.aquiferTemperature is not None and 'aquiferTemperature' not in already_processed:
            already_processed.add('aquiferTemperature')
            outfile.write(' aquiferTemperature="%s"' % self.gds_format_double(self.aquiferTemperature, input_name='aquiferTemperature'))
        if self.flowRate is not None and 'flowRate' not in already_processed:
            already_processed.add('flowRate')
            outfile.write(' flowRate="%s"' % self.gds_format_double(self.flowRate, input_name='flowRate'))
        if self.pumpPower is not None and 'pumpPower' not in already_processed:
            already_processed.add('pumpPower')
            outfile.write(' pumpPower="%s"' % self.gds_format_double(self.pumpPower, input_name='pumpPower'))
        if self.geothermalPotential is not None and 'geothermalPotential' not in already_processed:
            already_processed.add('geothermalPotential')
            outfile.write(' geothermalPotential=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.geothermalPotential), input_name='geothermalPotential')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GeothermalSource', fromsubclass_=False, pretty_print=True):
        super(GeothermalSource, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GeothermalSource', mapping_=None):
        element = super(GeothermalSource, self).to_etree(parent_element, name_, mapping_)
        if self.wellDepth is not None:
            element.set('wellDepth', self.gds_format_double(self.wellDepth))
        if self.geothermalSourceType is not None:
            element.set('geothermalSourceType', self.geothermalSourceType)
        if self.COP is not None:
            element.set('COP', self.gds_format_double(self.COP))
        if self.aquiferTemperature is not None:
            element.set('aquiferTemperature', self.gds_format_double(self.aquiferTemperature))
        if self.flowRate is not None:
            element.set('flowRate', self.gds_format_double(self.flowRate))
        if self.pumpPower is not None:
            element.set('pumpPower', self.gds_format_double(self.pumpPower))
        if self.geothermalPotential is not None:
            element.set('geothermalPotential', self.gds_format_string(self.geothermalPotential))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('wellDepth', node)
        if value is not None and 'wellDepth' not in already_processed:
            already_processed.add('wellDepth')
            try:
                self.wellDepth = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (wellDepth): %s' % exp)
        value = find_attr_value_('geothermalSourceType', node)
        if value is not None and 'geothermalSourceType' not in already_processed:
            already_processed.add('geothermalSourceType')
            self.geothermalSourceType = value
        value = find_attr_value_('COP', node)
        if value is not None and 'COP' not in already_processed:
            already_processed.add('COP')
            try:
                self.COP = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (COP): %s' % exp)
        value = find_attr_value_('aquiferTemperature', node)
        if value is not None and 'aquiferTemperature' not in already_processed:
            already_processed.add('aquiferTemperature')
            try:
                self.aquiferTemperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (aquiferTemperature): %s' % exp)
        value = find_attr_value_('flowRate', node)
        if value is not None and 'flowRate' not in already_processed:
            already_processed.add('flowRate')
            try:
                self.flowRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (flowRate): %s' % exp)
        value = find_attr_value_('pumpPower', node)
        if value is not None and 'pumpPower' not in already_processed:
            already_processed.add('pumpPower')
            try:
                self.pumpPower = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pumpPower): %s' % exp)
        value = find_attr_value_('geothermalPotential', node)
        if value is not None and 'geothermalPotential' not in already_processed:
            already_processed.add('geothermalPotential')
            self.geothermalPotential = value
        super(GeothermalSource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GeothermalSource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GeothermalSource


class Pipe(AbstractConductor):
    subclass = None
    superclass = AbstractConductor
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, diameter=None, length=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Pipe, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.diameter = _cast(float, diameter)
        self.length = _cast(float, length)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Pipe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Pipe.subclass:
            return Pipe.subclass(*args_, **kwargs_)
        else:
            return Pipe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_diameter(self):
        return self.diameter
    def set_diameter(self, diameter):
        self.diameter = diameter
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def hasContent_(self):
        if (
            super(Pipe, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Pipe', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Pipe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pipe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Pipe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Pipe'):
        super(Pipe, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Pipe')
        if self.diameter is not None and 'diameter' not in already_processed:
            already_processed.add('diameter')
            outfile.write(' diameter="%s"' % self.gds_format_double(self.diameter, input_name='diameter'))
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Pipe', fromsubclass_=False, pretty_print=True):
        super(Pipe, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Pipe', mapping_=None):
        element = super(Pipe, self).to_etree(parent_element, name_, mapping_)
        if self.diameter is not None:
            element.set('diameter', self.gds_format_double(self.diameter))
        if self.length is not None:
            element.set('length', self.gds_format_double(self.length))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('diameter', node)
        if value is not None and 'diameter' not in already_processed:
            already_processed.add('diameter')
            try:
                self.diameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (diameter): %s' % exp)
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        super(Pipe, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Pipe, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Pipe


class SinkConsumer(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SinkConsumer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SinkConsumer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SinkConsumer.subclass:
            return SinkConsumer.subclass(*args_, **kwargs_)
        else:
            return SinkConsumer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SinkConsumer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SinkConsumer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SinkConsumer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SinkConsumer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SinkConsumer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SinkConsumer'):
        super(SinkConsumer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SinkConsumer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SinkConsumer', fromsubclass_=False, pretty_print=True):
        super(SinkConsumer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SinkConsumer', mapping_=None):
        element = super(SinkConsumer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SinkConsumer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SinkConsumer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SinkConsumer


class SourceProducer(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(SourceProducer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SourceProducer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SourceProducer.subclass:
            return SourceProducer.subclass(*args_, **kwargs_)
        else:
            return SourceProducer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SourceProducer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='SourceProducer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SourceProducer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SourceProducer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='SourceProducer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='SourceProducer'):
        super(SourceProducer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SourceProducer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='SourceProducer', fromsubclass_=False, pretty_print=True):
        super(SourceProducer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='SourceProducer', mapping_=None):
        element = super(SourceProducer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SourceProducer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SourceProducer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SourceProducer


class GasNetwork(EnergyNetwork):
    subclass = None
    superclass = EnergyNetwork
    def __init__(self, pressure=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasNetwork, self).__init__( **kwargs_)
        self.pressure = _cast(float, pressure)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasNetwork.subclass:
            return GasNetwork.subclass(*args_, **kwargs_)
        else:
            return GasNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pressure(self):
        return self.pressure
    def set_pressure(self, pressure):
        self.pressure = pressure
    def hasContent_(self):
        if (
            super(GasNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasNetwork', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasNetwork', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasNetwork'):
        super(GasNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasNetwork')
        if self.pressure is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            outfile.write(' pressure="%s"' % self.gds_format_double(self.pressure, input_name='pressure'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasNetwork', fromsubclass_=False, pretty_print=True):
        super(GasNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='GasNetwork', mapping_=None):
        element = super(GasNetwork, self).to_etree(parent_element, name_, mapping_)
        if self.pressure is not None:
            element.set('pressure', self.gds_format_double(self.pressure))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pressure', node)
        if value is not None and 'pressure' not in already_processed:
            already_processed.add('pressure')
            try:
                self.pressure = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (pressure): %s' % exp)
        super(GasNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasNetwork, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasNetwork


class HeatNetwork(EnergyNetwork):
    subclass = None
    superclass = EnergyNetwork
    def __init__(self, temperature=None, temperatureMin=None, temperatureMax=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatNetwork, self).__init__( **kwargs_)
        self.temperature = _cast(float, temperature)
        self.temperatureMin = _cast(float, temperatureMin)
        self.temperatureMax = _cast(float, temperatureMax)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatNetwork.subclass:
            return HeatNetwork.subclass(*args_, **kwargs_)
        else:
            return HeatNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_temperature(self):
        return self.temperature
    def set_temperature(self, temperature):
        self.temperature = temperature
    def get_temperatureMin(self):
        return self.temperatureMin
    def set_temperatureMin(self, temperatureMin):
        self.temperatureMin = temperatureMin
    def get_temperatureMax(self):
        return self.temperatureMax
    def set_temperatureMax(self, temperatureMax):
        self.temperatureMax = temperatureMax
    def hasContent_(self):
        if (
            super(HeatNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatNetwork', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatNetwork', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatNetwork'):
        super(HeatNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatNetwork')
        if self.temperature is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            outfile.write(' temperature="%s"' % self.gds_format_double(self.temperature, input_name='temperature'))
        if self.temperatureMin is not None and 'temperatureMin' not in already_processed:
            already_processed.add('temperatureMin')
            outfile.write(' temperatureMin="%s"' % self.gds_format_double(self.temperatureMin, input_name='temperatureMin'))
        if self.temperatureMax is not None and 'temperatureMax' not in already_processed:
            already_processed.add('temperatureMax')
            outfile.write(' temperatureMax="%s"' % self.gds_format_double(self.temperatureMax, input_name='temperatureMax'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatNetwork', fromsubclass_=False, pretty_print=True):
        super(HeatNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='HeatNetwork', mapping_=None):
        element = super(HeatNetwork, self).to_etree(parent_element, name_, mapping_)
        if self.temperature is not None:
            element.set('temperature', self.gds_format_double(self.temperature))
        if self.temperatureMin is not None:
            element.set('temperatureMin', self.gds_format_double(self.temperatureMin))
        if self.temperatureMax is not None:
            element.set('temperatureMax', self.gds_format_double(self.temperatureMax))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('temperature', node)
        if value is not None and 'temperature' not in already_processed:
            already_processed.add('temperature')
            try:
                self.temperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temperature): %s' % exp)
        value = find_attr_value_('temperatureMin', node)
        if value is not None and 'temperatureMin' not in already_processed:
            already_processed.add('temperatureMin')
            try:
                self.temperatureMin = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temperatureMin): %s' % exp)
        value = find_attr_value_('temperatureMax', node)
        if value is not None and 'temperatureMax' not in already_processed:
            already_processed.add('temperatureMax')
            try:
                self.temperatureMax = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (temperatureMax): %s' % exp)
        super(HeatNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatNetwork, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatNetwork


class GasHeater(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, minimumBurnRate=0.0, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GasHeater, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.minimumBurnRate = _cast(float, minimumBurnRate)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GasHeater)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GasHeater.subclass:
            return GasHeater.subclass(*args_, **kwargs_)
        else:
            return GasHeater(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minimumBurnRate(self):
        return self.minimumBurnRate
    def set_minimumBurnRate(self, minimumBurnRate):
        self.minimumBurnRate = minimumBurnRate
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(GasHeater, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GasHeater', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GasHeater')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasHeater')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GasHeater', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GasHeater'):
        super(GasHeater, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GasHeater')
        if self.minimumBurnRate != 0.0 and 'minimumBurnRate' not in already_processed:
            already_processed.add('minimumBurnRate')
            outfile.write(' minimumBurnRate="%s"' % self.gds_format_double(self.minimumBurnRate, input_name='minimumBurnRate'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GasHeater', fromsubclass_=False, pretty_print=True):
        super(GasHeater, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GasHeater', mapping_=None):
        element = super(GasHeater, self).to_etree(parent_element, name_, mapping_)
        if self.minimumBurnRate is not None:
            element.set('minimumBurnRate', self.gds_format_double(self.minimumBurnRate))
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minimumBurnRate', node)
        if value is not None and 'minimumBurnRate' not in already_processed:
            already_processed.add('minimumBurnRate')
            try:
                self.minimumBurnRate = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minimumBurnRate): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(GasHeater, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GasHeater, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GasHeater


class HeatStorage(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, minStorageTemperature=None, maxStorageTemperature=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(HeatStorage, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
        self.minStorageTemperature = _cast(float, minStorageTemperature)
        self.maxStorageTemperature = _cast(float, maxStorageTemperature)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HeatStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HeatStorage.subclass:
            return HeatStorage.subclass(*args_, **kwargs_)
        else:
            return HeatStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_minStorageTemperature(self):
        return self.minStorageTemperature
    def set_minStorageTemperature(self, minStorageTemperature):
        self.minStorageTemperature = minStorageTemperature
    def get_maxStorageTemperature(self):
        return self.maxStorageTemperature
    def set_maxStorageTemperature(self, maxStorageTemperature):
        self.maxStorageTemperature = maxStorageTemperature
    def hasContent_(self):
        if (
            super(HeatStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='HeatStorage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HeatStorage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatStorage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='HeatStorage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='HeatStorage'):
        super(HeatStorage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HeatStorage')
        if self.minStorageTemperature is not None and 'minStorageTemperature' not in already_processed:
            already_processed.add('minStorageTemperature')
            outfile.write(' minStorageTemperature="%s"' % self.gds_format_double(self.minStorageTemperature, input_name='minStorageTemperature'))
        if self.maxStorageTemperature is not None and 'maxStorageTemperature' not in already_processed:
            already_processed.add('maxStorageTemperature')
            outfile.write(' maxStorageTemperature="%s"' % self.gds_format_double(self.maxStorageTemperature, input_name='maxStorageTemperature'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='HeatStorage', fromsubclass_=False, pretty_print=True):
        super(HeatStorage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='HeatStorage', mapping_=None):
        element = super(HeatStorage, self).to_etree(parent_element, name_, mapping_)
        if self.minStorageTemperature is not None:
            element.set('minStorageTemperature', self.gds_format_double(self.minStorageTemperature))
        if self.maxStorageTemperature is not None:
            element.set('maxStorageTemperature', self.gds_format_double(self.maxStorageTemperature))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('minStorageTemperature', node)
        if value is not None and 'minStorageTemperature' not in already_processed:
            already_processed.add('minStorageTemperature')
            try:
                self.minStorageTemperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (minStorageTemperature): %s' % exp)
        value = find_attr_value_('maxStorageTemperature', node)
        if value is not None and 'maxStorageTemperature' not in already_processed:
            already_processed.add('maxStorageTemperature')
            try:
                self.maxStorageTemperature = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (maxStorageTemperature): %s' % exp)
        super(HeatStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HeatStorage, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HeatStorage


class AggregatedStorage(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, aggregationOf=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedStorage, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
        self.aggregationOf = _cast(None, aggregationOf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedStorage.subclass:
            return AggregatedStorage.subclass(*args_, **kwargs_)
        else:
            return AggregatedStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            super(AggregatedStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedStorage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedStorage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedStorage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedStorage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedStorage'):
        super(AggregatedStorage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedStorage')
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedStorage', fromsubclass_=False, pretty_print=True):
        super(AggregatedStorage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedStorage', mapping_=None):
        element = super(AggregatedStorage, self).to_etree(parent_element, name_, mapping_)
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatedStorage, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatedStorage


class AggregatedConversion(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, aggregationOf=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedConversion, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
        self.aggregationOf = _cast(None, aggregationOf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedConversion.subclass:
            return AggregatedConversion.subclass(*args_, **kwargs_)
        else:
            return AggregatedConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            super(AggregatedConversion, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedConversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedConversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedConversion'):
        super(AggregatedConversion, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedConversion')
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedConversion', fromsubclass_=False, pretty_print=True):
        super(AggregatedConversion, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedConversion', mapping_=None):
        element = super(AggregatedConversion, self).to_etree(parent_element, name_, mapping_)
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedConversion, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatedConversion, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatedConversion


class AggregatedTransport(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, aggregationOf=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedTransport, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.aggregationOf = _cast(None, aggregationOf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedTransport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedTransport.subclass:
            return AggregatedTransport.subclass(*args_, **kwargs_)
        else:
            return AggregatedTransport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            super(AggregatedTransport, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedTransport', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedTransport')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedTransport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedTransport', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedTransport'):
        super(AggregatedTransport, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedTransport')
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedTransport', fromsubclass_=False, pretty_print=True):
        super(AggregatedTransport, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedTransport', mapping_=None):
        element = super(AggregatedTransport, self).to_etree(parent_element, name_, mapping_)
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedTransport, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatedTransport, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatedTransport


class GenericConversion(Conversion):
    subclass = None
    superclass = Conversion
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GenericConversion, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericConversion)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericConversion.subclass:
            return GenericConversion.subclass(*args_, **kwargs_)
        else:
            return GenericConversion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GenericConversion, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericConversion', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericConversion')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericConversion')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericConversion', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericConversion'):
        super(GenericConversion, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericConversion')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericConversion', fromsubclass_=False, pretty_print=True):
        super(GenericConversion, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericConversion', mapping_=None):
        element = super(GenericConversion, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericConversion, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericConversion, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericConversion


class GenericTransport(Transport):
    subclass = None
    superclass = Transport
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GenericTransport, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericTransport)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericTransport.subclass:
            return GenericTransport.subclass(*args_, **kwargs_)
        else:
            return GenericTransport(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GenericTransport, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericTransport', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericTransport')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericTransport')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericTransport', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericTransport'):
        super(GenericTransport, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericTransport')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericTransport', fromsubclass_=False, pretty_print=True):
        super(GenericTransport, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericTransport', mapping_=None):
        element = super(GenericTransport, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericTransport, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericTransport, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericTransport


class GenericStorage(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GenericStorage, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericStorage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericStorage.subclass:
            return GenericStorage.subclass(*args_, **kwargs_)
        else:
            return GenericStorage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GenericStorage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericStorage', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericStorage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericStorage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericStorage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericStorage'):
        super(GenericStorage, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericStorage')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericStorage', fromsubclass_=False, pretty_print=True):
        super(GenericStorage, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericStorage', mapping_=None):
        element = super(GenericStorage, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericStorage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericStorage, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericStorage


class GenericProducer(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GenericProducer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericProducer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericProducer.subclass:
            return GenericProducer.subclass(*args_, **kwargs_)
        else:
            return GenericProducer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GenericProducer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericProducer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericProducer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericProducer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericProducer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericProducer'):
        super(GenericProducer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericProducer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericProducer', fromsubclass_=False, pretty_print=True):
        super(GenericProducer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericProducer', mapping_=None):
        element = super(GenericProducer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericProducer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericProducer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericProducer


class GenericConsumer(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(GenericConsumer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GenericConsumer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GenericConsumer.subclass:
            return GenericConsumer.subclass(*args_, **kwargs_)
        else:
            return GenericConsumer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(GenericConsumer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='GenericConsumer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GenericConsumer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericConsumer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='GenericConsumer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='GenericConsumer'):
        super(GenericConsumer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GenericConsumer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='GenericConsumer', fromsubclass_=False, pretty_print=True):
        super(GenericConsumer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='GenericConsumer', mapping_=None):
        element = super(GenericConsumer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericConsumer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GenericConsumer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GenericConsumer


class AggregatedProducer(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, aggregationOf=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedProducer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.aggregationOf = _cast(None, aggregationOf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedProducer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedProducer.subclass:
            return AggregatedProducer.subclass(*args_, **kwargs_)
        else:
            return AggregatedProducer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            super(AggregatedProducer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedProducer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedProducer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedProducer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedProducer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedProducer'):
        super(AggregatedProducer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedProducer')
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedProducer', fromsubclass_=False, pretty_print=True):
        super(AggregatedProducer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedProducer', mapping_=None):
        element = super(AggregatedProducer, self).to_etree(parent_element, name_, mapping_)
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedProducer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatedProducer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatedProducer


class AggregatedConsumer(Consumer):
    subclass = None
    superclass = Consumer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, consType='PRIMARY', power=None, aggregationOf=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(AggregatedConsumer, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, consType, power,  **kwargs_)
        self.aggregationOf = _cast(None, aggregationOf)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AggregatedConsumer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AggregatedConsumer.subclass:
            return AggregatedConsumer.subclass(*args_, **kwargs_)
        else:
            return AggregatedConsumer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_aggregationOf(self):
        return self.aggregationOf
    def set_aggregationOf(self, aggregationOf):
        self.aggregationOf = aggregationOf
    def hasContent_(self):
        if (
            super(AggregatedConsumer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedConsumer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AggregatedConsumer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedConsumer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='AggregatedConsumer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='AggregatedConsumer'):
        super(AggregatedConsumer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AggregatedConsumer')
        if self.aggregationOf is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            outfile.write(' aggregationOf=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.aggregationOf), input_name='aggregationOf')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='AggregatedConsumer', fromsubclass_=False, pretty_print=True):
        super(AggregatedConsumer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='AggregatedConsumer', mapping_=None):
        element = super(AggregatedConsumer, self).to_etree(parent_element, name_, mapping_)
        if self.aggregationOf is not None:
            element.set('aggregationOf', self.gds_format_string(self.aggregationOf))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('aggregationOf', node)
        if value is not None and 'aggregationOf' not in already_processed:
            already_processed.add('aggregationOf')
            self.aggregationOf = value
        super(AggregatedConsumer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AggregatedConsumer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AggregatedConsumer


class ElectricityCable(AbstractConductor):
    subclass = None
    superclass = AbstractConductor
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, length=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ElectricityCable, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
        self.length = _cast(float, length)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityCable)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityCable.subclass:
            return ElectricityCable.subclass(*args_, **kwargs_)
        else:
            return ElectricityCable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_length(self):
        return self.length
    def set_length(self, length):
        self.length = length
    def hasContent_(self):
        if (
            super(ElectricityCable, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityCable', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricityCable')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityCable')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ElectricityCable', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ElectricityCable'):
        super(ElectricityCable, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityCable')
        if self.length is not None and 'length' not in already_processed:
            already_processed.add('length')
            outfile.write(' length="%s"' % self.gds_format_double(self.length, input_name='length'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityCable', fromsubclass_=False, pretty_print=True):
        super(ElectricityCable, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='ElectricityCable', mapping_=None):
        element = super(ElectricityCable, self).to_etree(parent_element, name_, mapping_)
        if self.length is not None:
            element.set('length', self.gds_format_double(self.length))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.add('length')
            try:
                self.length = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (length): %s' % exp)
        super(ElectricityCable, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ElectricityCable, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ElectricityCable


class ElectricityNetwork(EnergyNetwork):
    subclass = None
    superclass = EnergyNetwork
    def __init__(self, voltage=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(ElectricityNetwork, self).__init__( **kwargs_)
        self.voltage = _cast(float, voltage)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ElectricityNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ElectricityNetwork.subclass:
            return ElectricityNetwork.subclass(*args_, **kwargs_)
        else:
            return ElectricityNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_voltage(self):
        return self.voltage
    def set_voltage(self, voltage):
        self.voltage = voltage
    def hasContent_(self):
        if (
            super(ElectricityNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityNetwork', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ElectricityNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='ElectricityNetwork', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='ElectricityNetwork'):
        super(ElectricityNetwork, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ElectricityNetwork')
        if self.voltage is not None and 'voltage' not in already_processed:
            already_processed.add('voltage')
            outfile.write(' voltage="%s"' % self.gds_format_double(self.voltage, input_name='voltage'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='ElectricityNetwork', fromsubclass_=False, pretty_print=True):
        super(ElectricityNetwork, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='ElectricityNetwork', mapping_=None):
        element = super(ElectricityNetwork, self).to_etree(parent_element, name_, mapping_)
        if self.voltage is not None:
            element.set('voltage', self.gds_format_double(self.voltage))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('voltage', node)
        if value is not None and 'voltage' not in already_processed:
            already_processed.add('voltage')
            try:
                self.voltage = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (voltage): %s' % exp)
        super(ElectricityNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ElectricityNetwork, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ElectricityNetwork


class Battery(Storage):
    subclass = None
    superclass = Storage
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, chargeEfficiency=0.0, dischargeEfficiency=0.0, selfDischargeRate=0.0, fillLevel=None, maxChargeRate=0.0, maxDischargeRate=0.0, profile=None, maxChargeDischargeCycles=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Battery, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, chargeEfficiency, dischargeEfficiency, selfDischargeRate, fillLevel, maxChargeRate, maxDischargeRate, profile,  **kwargs_)
        self.maxChargeDischargeCycles = _cast(int, maxChargeDischargeCycles)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Battery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Battery.subclass:
            return Battery.subclass(*args_, **kwargs_)
        else:
            return Battery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxChargeDischargeCycles(self):
        return self.maxChargeDischargeCycles
    def set_maxChargeDischargeCycles(self, maxChargeDischargeCycles):
        self.maxChargeDischargeCycles = maxChargeDischargeCycles
    def hasContent_(self):
        if (
            super(Battery, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Battery', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Battery')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Battery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Battery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Battery'):
        super(Battery, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Battery')
        if self.maxChargeDischargeCycles is not None and 'maxChargeDischargeCycles' not in already_processed:
            already_processed.add('maxChargeDischargeCycles')
            outfile.write(' maxChargeDischargeCycles="%s"' % self.gds_format_integer(self.maxChargeDischargeCycles, input_name='maxChargeDischargeCycles'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Battery', fromsubclass_=False, pretty_print=True):
        super(Battery, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Battery', mapping_=None):
        element = super(Battery, self).to_etree(parent_element, name_, mapping_)
        if self.maxChargeDischargeCycles is not None:
            element.set('maxChargeDischargeCycles', self.gds_format_integer(self.maxChargeDischargeCycles))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxChargeDischargeCycles', node)
        if value is not None and 'maxChargeDischargeCycles' not in already_processed:
            already_processed.add('maxChargeDischargeCycles')
            try:
                self.maxChargeDischargeCycles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(Battery, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Battery, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Battery


class PVPanel(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, panelEfficiency=None, inverterEfficiency=None, angle=None, orientation=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PVPanel, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.panelEfficiency = _cast(float, panelEfficiency)
        self.inverterEfficiency = _cast(float, inverterEfficiency)
        self.angle = _cast(int, angle)
        self.orientation = _cast(int, orientation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PVPanel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PVPanel.subclass:
            return PVPanel.subclass(*args_, **kwargs_)
        else:
            return PVPanel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_panelEfficiency(self):
        return self.panelEfficiency
    def set_panelEfficiency(self, panelEfficiency):
        self.panelEfficiency = panelEfficiency
    def get_inverterEfficiency(self):
        return self.inverterEfficiency
    def set_inverterEfficiency(self, inverterEfficiency):
        self.inverterEfficiency = inverterEfficiency
    def get_angle(self):
        return self.angle
    def set_angle(self, angle):
        self.angle = angle
    def get_orientation(self):
        return self.orientation
    def set_orientation(self, orientation):
        self.orientation = orientation
    def hasContent_(self):
        if (
            super(PVPanel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PVPanel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PVPanel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVPanel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PVPanel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PVPanel'):
        super(PVPanel, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVPanel')
        if self.panelEfficiency is not None and 'panelEfficiency' not in already_processed:
            already_processed.add('panelEfficiency')
            outfile.write(' panelEfficiency="%s"' % self.gds_format_double(self.panelEfficiency, input_name='panelEfficiency'))
        if self.inverterEfficiency is not None and 'inverterEfficiency' not in already_processed:
            already_processed.add('inverterEfficiency')
            outfile.write(' inverterEfficiency="%s"' % self.gds_format_double(self.inverterEfficiency, input_name='inverterEfficiency'))
        if self.angle is not None and 'angle' not in already_processed:
            already_processed.add('angle')
            outfile.write(' angle="%s"' % self.gds_format_integer(self.angle, input_name='angle'))
        if self.orientation is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            outfile.write(' orientation="%s"' % self.gds_format_integer(self.orientation, input_name='orientation'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PVPanel', fromsubclass_=False, pretty_print=True):
        super(PVPanel, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='PVPanel', mapping_=None):
        element = super(PVPanel, self).to_etree(parent_element, name_, mapping_)
        if self.panelEfficiency is not None:
            element.set('panelEfficiency', self.gds_format_double(self.panelEfficiency))
        if self.inverterEfficiency is not None:
            element.set('inverterEfficiency', self.gds_format_double(self.inverterEfficiency))
        if self.angle is not None:
            element.set('angle', self.gds_format_integer(self.angle))
        if self.orientation is not None:
            element.set('orientation', self.gds_format_integer(self.orientation))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('panelEfficiency', node)
        if value is not None and 'panelEfficiency' not in already_processed:
            already_processed.add('panelEfficiency')
            try:
                self.panelEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (panelEfficiency): %s' % exp)
        value = find_attr_value_('inverterEfficiency', node)
        if value is not None and 'inverterEfficiency' not in already_processed:
            already_processed.add('inverterEfficiency')
            try:
                self.inverterEfficiency = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (inverterEfficiency): %s' % exp)
        value = find_attr_value_('angle', node)
        if value is not None and 'angle' not in already_processed:
            already_processed.add('angle')
            try:
                self.angle = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('orientation', node)
        if value is not None and 'orientation' not in already_processed:
            already_processed.add('orientation')
            try:
                self.orientation = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(PVPanel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PVPanel, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PVPanel


class WindTurbine(Producer):
    subclass = None
    superclass = Producer
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, prodType='RENEWABLE', operationalHours=None, fullLoadHours=None, power=None, rotorDiameter=None, height=None, type_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WindTurbine, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, prodType, operationalHours, fullLoadHours, power,  **kwargs_)
        self.rotorDiameter = _cast(float, rotorDiameter)
        self.height = _cast(float, height)
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindTurbine)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindTurbine.subclass:
            return WindTurbine.subclass(*args_, **kwargs_)
        else:
            return WindTurbine(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rotorDiameter(self):
        return self.rotorDiameter
    def set_rotorDiameter(self, rotorDiameter):
        self.rotorDiameter = rotorDiameter
    def get_height(self):
        return self.height
    def set_height(self, height):
        self.height = height
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def hasContent_(self):
        if (
            super(WindTurbine, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WindTurbine', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WindTurbine')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindTurbine')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WindTurbine', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WindTurbine'):
        super(WindTurbine, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindTurbine')
        if self.rotorDiameter is not None and 'rotorDiameter' not in already_processed:
            already_processed.add('rotorDiameter')
            outfile.write(' rotorDiameter="%s"' % self.gds_format_double(self.rotorDiameter, input_name='rotorDiameter'))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_double(self.height, input_name='height'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WindTurbine', fromsubclass_=False, pretty_print=True):
        super(WindTurbine, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='WindTurbine', mapping_=None):
        element = super(WindTurbine, self).to_etree(parent_element, name_, mapping_)
        if self.rotorDiameter is not None:
            element.set('rotorDiameter', self.gds_format_double(self.rotorDiameter))
        if self.height is not None:
            element.set('height', self.gds_format_double(self.height))
        if self.type_ is not None:
            element.set('type', self.type_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rotorDiameter', node)
        if value is not None and 'rotorDiameter' not in already_processed:
            already_processed.add('rotorDiameter')
            try:
                self.rotorDiameter = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (rotorDiameter): %s' % exp)
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (height): %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(WindTurbine, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WindTurbine, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WindTurbine


class Joint(AbstractConductor):
    """A Joint is a means to connect AbstractConductors. This helps when
    these conductors have opposite Ports."""
    subclass = None
    superclass = AbstractConductor
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, capacity=None, efficiency=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Joint, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, capacity, efficiency,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Joint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Joint.subclass:
            return Joint.subclass(*args_, **kwargs_)
        else:
            return Joint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Joint, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Joint', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Joint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Joint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Joint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Joint'):
        super(Joint, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Joint')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Joint', fromsubclass_=False, pretty_print=True):
        super(Joint, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='Joint', mapping_=None):
        element = super(Joint, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Joint, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Joint, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Joint


class WaterBuffer(HeatStorage):
    subclass = None
    superclass = HeatStorage
    def __init__(self, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WaterBuffer, self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WaterBuffer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WaterBuffer.subclass:
            return WaterBuffer.subclass(*args_, **kwargs_)
        else:
            return WaterBuffer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(WaterBuffer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WaterBuffer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WaterBuffer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WaterBuffer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WaterBuffer', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WaterBuffer'):
        super(WaterBuffer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WaterBuffer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WaterBuffer', fromsubclass_=False, pretty_print=True):
        super(WaterBuffer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='WaterBuffer', mapping_=None):
        element = super(WaterBuffer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WaterBuffer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WaterBuffer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WaterBuffer


class UTES(HeatStorage):
    subclass = None
    superclass = HeatStorage
    def __init__(self, type_=None, UTESPotential=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(UTES, self).__init__( **kwargs_)
        self.type_ = _cast(None, type_)
        self.UTESPotential = _cast(None, UTESPotential)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UTES)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UTES.subclass:
            return UTES.subclass(*args_, **kwargs_)
        else:
            return UTES(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_UTESPotential(self):
        return self.UTESPotential
    def set_UTESPotential(self, UTESPotential):
        self.UTESPotential = UTESPotential
    def hasContent_(self):
        if (
            super(UTES, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='UTES', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UTES')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UTES')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='UTES', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='UTES'):
        super(UTES, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UTES')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.UTESPotential is not None and 'UTESPotential' not in already_processed:
            already_processed.add('UTESPotential')
            outfile.write(' UTESPotential=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.UTESPotential), input_name='UTESPotential')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='UTES', fromsubclass_=False, pretty_print=True):
        super(UTES, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='UTES', mapping_=None):
        element = super(UTES, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.UTESPotential is not None:
            element.set('UTESPotential', self.gds_format_string(self.UTESPotential))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('UTESPotential', node)
        if value is not None and 'UTESPotential' not in already_processed:
            already_processed.add('UTESPotential')
            self.UTESPotential = value
        super(UTES, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UTES, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UTES


class PVInstallation(PVPanel):
    subclass = None
    superclass = PVPanel
    def __init__(self, type_=None, numberOfPanels=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PVInstallation, self).__init__( **kwargs_)
        self.type_ = _cast(None, type_)
        self.numberOfPanels = _cast(int, numberOfPanels)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PVInstallation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PVInstallation.subclass:
            return PVInstallation.subclass(*args_, **kwargs_)
        else:
            return PVInstallation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_numberOfPanels(self):
        return self.numberOfPanels
    def set_numberOfPanels(self, numberOfPanels):
        self.numberOfPanels = numberOfPanels
    def hasContent_(self):
        if (
            super(PVInstallation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PVInstallation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PVInstallation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVInstallation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PVInstallation', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PVInstallation'):
        super(PVInstallation, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVInstallation')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.numberOfPanels is not None and 'numberOfPanels' not in already_processed:
            already_processed.add('numberOfPanels')
            outfile.write(' numberOfPanels="%s"' % self.gds_format_integer(self.numberOfPanels, input_name='numberOfPanels'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PVInstallation', fromsubclass_=False, pretty_print=True):
        super(PVInstallation, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='PVInstallation', mapping_=None):
        element = super(PVInstallation, self).to_etree(parent_element, name_, mapping_)
        if self.type_ is not None:
            element.set('type', self.type_)
        if self.numberOfPanels is not None:
            element.set('numberOfPanels', self.gds_format_integer(self.numberOfPanels))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('numberOfPanels', node)
        if value is not None and 'numberOfPanels' not in already_processed:
            already_processed.add('numberOfPanels')
            try:
                self.numberOfPanels = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(PVInstallation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PVInstallation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PVInstallation


class Electrolyzer(PowerToX):
    subclass = None
    superclass = PowerToX
    def __init__(self, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Electrolyzer, self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Electrolyzer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Electrolyzer.subclass:
            return Electrolyzer.subclass(*args_, **kwargs_)
        else:
            return Electrolyzer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Electrolyzer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='Electrolyzer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Electrolyzer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Electrolyzer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='Electrolyzer', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='Electrolyzer'):
        super(Electrolyzer, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Electrolyzer')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='Electrolyzer', fromsubclass_=False, pretty_print=True):
        super(Electrolyzer, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='Electrolyzer', mapping_=None):
        element = super(Electrolyzer, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Electrolyzer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Electrolyzer, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Electrolyzer


class CHP(CoGeneration):
    subclass = None
    superclass = CoGeneration
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, heatEfficiency=0.0, electricalEfficiency=0.0, HERatio=None, fuelType=None, leadCommodity=None, energyCarrier=None, CHPType=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(CHP, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential, heatEfficiency, electricalEfficiency, HERatio, fuelType, leadCommodity, energyCarrier,  **kwargs_)
        self.CHPType = _cast(None, CHPType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CHP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CHP.subclass:
            return CHP.subclass(*args_, **kwargs_)
        else:
            return CHP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CHPType(self):
        return self.CHPType
    def set_CHPType(self, CHPType):
        self.CHPType = CHPType
    def hasContent_(self):
        if (
            super(CHP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='CHP', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CHP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CHP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='CHP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='CHP'):
        super(CHP, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CHP')
        if self.CHPType is not None and 'CHPType' not in already_processed:
            already_processed.add('CHPType')
            outfile.write(' CHPType=%s' % (quote_attrib(self.CHPType), ))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='CHP', fromsubclass_=False, pretty_print=True):
        super(CHP, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='CHP', mapping_=None):
        element = super(CHP, self).to_etree(parent_element, name_, mapping_)
        if self.CHPType is not None:
            element.set('CHPType', self.CHPType)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CHPType', node)
        if value is not None and 'CHPType' not in already_processed:
            already_processed.add('CHPType')
            self.CHPType = value
        super(CHP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CHP, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CHP


class PVParc(PVPanel):
    subclass = None
    superclass = PVPanel
    def __init__(self, numberOfPanels=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(PVParc, self).__init__( **kwargs_)
        self.numberOfPanels = _cast(int, numberOfPanels)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PVParc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PVParc.subclass:
            return PVParc.subclass(*args_, **kwargs_)
        else:
            return PVParc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfPanels(self):
        return self.numberOfPanels
    def set_numberOfPanels(self, numberOfPanels):
        self.numberOfPanels = numberOfPanels
    def hasContent_(self):
        if (
            super(PVParc, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='PVParc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PVParc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVParc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='PVParc', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='PVParc'):
        super(PVParc, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PVParc')
        if self.numberOfPanels is not None and 'numberOfPanels' not in already_processed:
            already_processed.add('numberOfPanels')
            outfile.write(' numberOfPanels="%s"' % self.gds_format_integer(self.numberOfPanels, input_name='numberOfPanels'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='PVParc', fromsubclass_=False, pretty_print=True):
        super(PVParc, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='PVParc', mapping_=None):
        element = super(PVParc, self).to_etree(parent_element, name_, mapping_)
        if self.numberOfPanels is not None:
            element.set('numberOfPanels', self.gds_format_integer(self.numberOfPanels))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfPanels', node)
        if value is not None and 'numberOfPanels' not in already_processed:
            already_processed.add('numberOfPanels')
            try:
                self.numberOfPanels = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(PVParc, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PVParc, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PVParc


class WindParc(WindTurbine):
    subclass = None
    superclass = WindTurbine
    def __init__(self, numberOfTurbines=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WindParc, self).__init__( **kwargs_)
        self.numberOfTurbines = _cast(int, numberOfTurbines)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WindParc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WindParc.subclass:
            return WindParc.subclass(*args_, **kwargs_)
        else:
            return WindParc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfTurbines(self):
        return self.numberOfTurbines
    def set_numberOfTurbines(self, numberOfTurbines):
        self.numberOfTurbines = numberOfTurbines
    def hasContent_(self):
        if (
            super(WindParc, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='WindParc', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WindParc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindParc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='WindParc', pretty_print=pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='WindParc'):
        super(WindParc, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WindParc')
        if self.numberOfTurbines is not None and 'numberOfTurbines' not in already_processed:
            already_processed.add('numberOfTurbines')
            outfile.write(' numberOfTurbines="%s"' % self.gds_format_integer(self.numberOfTurbines, input_name='numberOfTurbines'))
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='WindParc', fromsubclass_=False, pretty_print=True):
        super(WindParc, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def to_etree(self, parent_element=None, name_='WindParc', mapping_=None):
        element = super(WindParc, self).to_etree(parent_element, name_, mapping_)
        if self.numberOfTurbines is not None:
            element.set('numberOfTurbines', self.gds_format_integer(self.numberOfTurbines))
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfTurbines', node)
        if value is not None and 'numberOfTurbines' not in already_processed:
            already_processed.add('numberOfTurbines')
            try:
                self.numberOfTurbines = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(WindParc, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(WindParc, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class WindParc


class FuelCell(CoGeneration):
    subclass = None
    superclass = CoGeneration
    def __init__(self, id=None, name=None, shortName=None, description=None, originalIdInSource=None, isOwnedBy=None, sector=None, dataSource=None, surfaceArea=None, commissioningDate=None, decommissioningDate=None, owner=None, technicalLifetime=None, aggregated=None, aggregationCount=1, area=None, containingBuilding=None, geometry=None, costInformation=None, controlStrategy=None, port=None, efficiency=None, operationalHours=None, fullLoadHours=None, power=None, residualHeatSourcePotential=None, heatEfficiency=0.0, electricalEfficiency=0.0, HERatio=None, fuelType=None, leadCommodity=None, energyCarrier=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(FuelCell, self).__init__(id, name, shortName, description, originalIdInSource, isOwnedBy, sector, dataSource, surfaceArea, commissioningDate, decommissioningDate, owner, technicalLifetime, aggregated, aggregationCount, area, containingBuilding, geometry, costInformation, controlStrategy, port, efficiency, operationalHours, fullLoadHours, power, residualHeatSourcePotential, heatEfficiency, electricalEfficiency, HERatio, fuelType, leadCommodity, energyCarrier,  **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FuelCell)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FuelCell.subclass:
            return FuelCell.subclass(*args_, **kwargs_)
        else:
            return FuelCell(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FuelCell, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='esdl:', name_='FuelCell', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FuelCell')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s' % (name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FuelCell')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_='esdl:', name_='FuelCell', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s>%s' % (name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='esdl:', name_='FuelCell'):
        super(FuelCell, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FuelCell')
    def exportChildren(self, outfile, level, namespaceprefix_='esdl:', name_='FuelCell', fromsubclass_=False, pretty_print=True):
        super(FuelCell, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
    def to_etree(self, parent_element=None, name_='FuelCell', mapping_=None):
        element = super(FuelCell, self).to_etree(parent_element, name_, mapping_)
        if mapping_ is not None:
            mapping_[id(self)] = element
        return element
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FuelCell, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FuelCell, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FuelCell


GDSClassesMapping = {
    'AggregatedBuilding': AggregatedBuilding,
    'AggregatedConsumer': AggregatedConsumer,
    'AggregatedConversion': AggregatedConversion,
    'AggregatedProducer': AggregatedProducer,
    'AggregatedStorage': AggregatedStorage,
    'AggregatedTransport': AggregatedTransport,
    'AggregatorService': AggregatorService,
    'Airco': Airco,
    'Area': Area,
    'AssymetricVariance': AssymetricVariance,
    'Battery': Battery,
    'BiomassHeater': BiomassHeater,
    'BiomassPotential': BiomassPotential,
    'BooleanParameter': BooleanParameter,
    'Building': Building,
    'BuildingUnit': BuildingUnit,
    'CCS': CCS,
    'CHP': CHP,
    'Carriers': Carriers,
    'CircuitBraker': CircuitBraker,
    'CoolingDemand': CoolingDemand,
    'CostInformation': CostInformation,
    'DataSource': DataSource,
    'DataSourceReference': DataSourceReference,
    'DataSources': DataSources,
    'DateTimeProfile': DateTimeProfile,
    'DemandResponseService': DemandResponseService,
    'DoubleAssymetricVariance': DoubleAssymetricVariance,
    'DoubleParameter': DoubleParameter,
    'DrivenByDemand': DrivenByDemand,
    'DrivenByProfile': DrivenByProfile,
    'DrivenBySupply': DrivenBySupply,
    'Duration': Duration,
    'EConnection': EConnection,
    'EVChargingStation': EVChargingStation,
    'EconomicProperties': EconomicProperties,
    'ElectricityCable': ElectricityCable,
    'ElectricityCommodity': ElectricityCommodity,
    'ElectricityDemand': ElectricityDemand,
    'ElectricityNetwork': ElectricityNetwork,
    'Electrolyzer': Electrolyzer,
    'EnergyCarrier': EnergyCarrier,
    'EnergyCommodity': EnergyCommodity,
    'EnergyDemand': EnergyDemand,
    'EnergyLabelDistribution': EnergyLabelDistribution,
    'EnergyLabelPerc': EnergyLabelPerc,
    'EnergyMarket': EnergyMarket,
    'EnergyNetwork': EnergyNetwork,
    'EnergySystem': EnergySystem,
    'EnergySystemInformation': EnergySystemInformation,
    'FermentationPlant': FermentationPlant,
    'FromToDistribution': FromToDistribution,
    'FromToPerc': FromToPerc,
    'FuelCell': FuelCell,
    'GConnection': GConnection,
    'GasCommodity': GasCommodity,
    'GasConversion': GasConversion,
    'GasDemand': GasDemand,
    'GasHeater': GasHeater,
    'GasNetwork': GasNetwork,
    'GasStorage': GasStorage,
    'GenericConsumer': GenericConsumer,
    'GenericConversion': GenericConversion,
    'GenericProducer': GenericProducer,
    'GenericStorage': GenericStorage,
    'GenericTransport': GenericTransport,
    'GeothermalEnergyPotential': GeothermalEnergyPotential,
    'GeothermalPotential': GeothermalPotential,
    'GeothermalSource': GeothermalSource,
    'Glass': Glass,
    'HConnection': HConnection,
    'HeatCommodity': HeatCommodity,
    'HeatExchange': HeatExchange,
    'HeatNetwork': HeatNetwork,
    'HeatPump': HeatPump,
    'HeatStorage': HeatStorage,
    'HeatingDemand': HeatingDemand,
    'InPort': InPort,
    'InfluxDBProfile': InfluxDBProfile,
    'Instance': Instance,
    'InstanceDate': InstanceDate,
    'InstancePeriod': InstancePeriod,
    'Insulation': Insulation,
    'IntegerParameter': IntegerParameter,
    'Joint': Joint,
    'KPI': KPI,
    'KPIs': KPIs,
    'LegalArea': LegalArea,
    'Line': Line,
    'Losses': Losses,
    'Measures': Measures,
    'MeasuresCollection': MeasuresCollection,
    'MobilityDemand': MobilityDemand,
    'MobilityFuelInformation': MobilityFuelInformation,
    'MobilityProperties': MobilityProperties,
    'MultiLine': MultiLine,
    'MultiPolygon': MultiPolygon,
    'NumberOfVehicles': NumberOfVehicles,
    'OutPort': OutPort,
    'PItemStat': PItemStat,
    'PVInstallation': PVInstallation,
    'PVPanel': PVPanel,
    'PVParc': PVParc,
    'Parties': Parties,
    'Party': Party,
    'Percentile': Percentile,
    'PercentileDistribution': PercentileDistribution,
    'Pipe': Pipe,
    'Point': Point,
    'Polygon': Polygon,
    'PowerPlant': PowerPlant,
    'PowerToX': PowerToX,
    'ProfileElement': ProfileElement,
    'ProfileReference': ProfileReference,
    'Profiles': Profiles,
    'Pump': Pump,
    'QuantityAndUnitReference': QuantityAndUnitReference,
    'QuantityAndUnitType': QuantityAndUnitType,
    'QuantityAndUnits': QuantityAndUnits,
    'Range': Range,
    'ResidualHeatSource': ResidualHeatSource,
    'ResidualHeatSourcePotential': ResidualHeatSourcePotential,
    'RoomHeater': RoomHeater,
    'SearchAreaSolar': SearchAreaSolar,
    'SearchAreaWind': SearchAreaWind,
    'Sector': Sector,
    'Sectors': Sectors,
    'Services': Services,
    'SingleValue': SingleValue,
    'SinkConsumer': SinkConsumer,
    'SocialProperties': SocialProperties,
    'SolarCollector': SolarCollector,
    'SolarFieldPotential': SolarFieldPotential,
    'SourceProducer': SourceProducer,
    'StringLabelDistribution': StringLabelDistribution,
    'StringParameter': StringParameter,
    'StringPerc': StringPerc,
    'SubPolygon': SubPolygon,
    'SymetricVariance': SymetricVariance,
    'Transformer': Transformer,
    'URIProfile': URIProfile,
    'UTES': UTES,
    'UTESPotential': UTESPotential,
    'Valve': Valve,
    'VehicleCount': VehicleCount,
    'VehicleFuelEfficiency': VehicleFuelEfficiency,
    'WKB': WKB,
    'WKT': WKT,
    'WaterBuffer': WaterBuffer,
    'WaterToPower': WaterToPower,
    'WindParc': WindParc,
    'WindPotential': WindPotential,
    'WindTurbine': WindTurbine,
    'XToPower': XToPower,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EnergySystem'
        rootClass = EnergySystem
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:esdl="http://www.tno.nl/esdl"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EnergySystem'
        rootClass = EnergySystem
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EnergySystem'
        rootClass = EnergySystem
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:esdl="http://www.tno.nl/esdl"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'EnergySystem'
        rootClass = EnergySystem
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from esdl_sup import *\n\n')
        sys.stdout.write('import esdl_sup as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractBuilding",
    "AbstractConductor",
    "AbstractConnection",
    "AbstractDataSource",
    "AbstractGTPotential",
    "AbstractInstanceDate",
    "AbstractQuantityAndUnit",
    "AbstractSwitch",
    "AbstractTransformer",
    "AbstractVariance",
    "AggregatedBuilding",
    "AggregatedConsumer",
    "AggregatedConversion",
    "AggregatedProducer",
    "AggregatedStorage",
    "AggregatedTransport",
    "AggregatorService",
    "Airco",
    "Area",
    "Asset",
    "AssymetricVariance",
    "Battery",
    "BiomassHeater",
    "BiomassPotential",
    "BooleanParameter",
    "Building",
    "BuildingUnit",
    "CCS",
    "CHP",
    "Carrier",
    "Carriers",
    "CircuitBraker",
    "CoGeneration",
    "Commodity",
    "Consumer",
    "ControlStrategy",
    "Conversion",
    "CoolingDemand",
    "CostInformation",
    "DataSource",
    "DataSourceReference",
    "DataSources",
    "DatabaseProfile",
    "DateTimeProfile",
    "DemandResponseService",
    "DoubleAssymetricVariance",
    "DoubleParameter",
    "DrivenByDemand",
    "DrivenByProfile",
    "DrivenBySupply",
    "Duration",
    "EConnection",
    "EVChargingStation",
    "EconomicProperties",
    "ElectricityCable",
    "ElectricityCommodity",
    "ElectricityDemand",
    "ElectricityNetwork",
    "Electrolyzer",
    "EnergyAsset",
    "EnergyCarrier",
    "EnergyCommodity",
    "EnergyDemand",
    "EnergyLabelDistribution",
    "EnergyLabelPerc",
    "EnergyMarket",
    "EnergyNetwork",
    "EnergyService",
    "EnergySystem",
    "EnergySystemInformation",
    "ExternalProfile",
    "FermentationPlant",
    "FromToDistribution",
    "FromToPerc",
    "FuelCell",
    "GConnection",
    "GasCommodity",
    "GasConversion",
    "GasDemand",
    "GasHeater",
    "GasNetwork",
    "GasStorage",
    "GenericConsumer",
    "GenericConversion",
    "GenericDistribution",
    "GenericProducer",
    "GenericProfile",
    "GenericStorage",
    "GenericTransport",
    "Geometry",
    "GeothermalEnergyPotential",
    "GeothermalPotential",
    "GeothermalSource",
    "Glass",
    "HConnection",
    "HeatCommodity",
    "HeatExchange",
    "HeatNetwork",
    "HeatPump",
    "HeatStorage",
    "HeatingDemand",
    "InPort",
    "InfluxDBProfile",
    "Instance",
    "InstanceDate",
    "InstancePeriod",
    "Insulation",
    "IntegerParameter",
    "Item",
    "Joint",
    "KPI",
    "KPIs",
    "LabelDistribution",
    "LegalArea",
    "Line",
    "Losses",
    "Measures",
    "MeasuresCollection",
    "MobilityDemand",
    "MobilityFuelInformation",
    "MobilityProperties",
    "MultiLine",
    "MultiPolygon",
    "NumberOfVehicles",
    "OutPort",
    "PItemStat",
    "PVInstallation",
    "PVPanel",
    "PVParc",
    "Parameters",
    "Parties",
    "Party",
    "Percentile",
    "PercentileDistribution",
    "Pipe",
    "Point",
    "Polygon",
    "Port",
    "Potential",
    "PowerPlant",
    "PowerToX",
    "Producer",
    "ProfileElement",
    "ProfileReference",
    "Profiles",
    "Pump",
    "QuantityAndUnitReference",
    "QuantityAndUnitType",
    "QuantityAndUnits",
    "Range",
    "ResidualHeatSource",
    "ResidualHeatSourcePotential",
    "RoomHeater",
    "SearchAreaSolar",
    "SearchAreaWind",
    "Sector",
    "Sectors",
    "Service",
    "Services",
    "SingleValue",
    "SinkConsumer",
    "SocialProperties",
    "SolarCollector",
    "SolarFieldPotential",
    "SourceProducer",
    "StaticProfile",
    "Storage",
    "StringLabelDistribution",
    "StringParameter",
    "StringPerc",
    "SubPolygon",
    "SymetricVariance",
    "Transformer",
    "Transport",
    "URIProfile",
    "UTES",
    "UTESPotential",
    "Valve",
    "VehicleCount",
    "VehicleFuelEfficiency",
    "WKB",
    "WKT",
    "WaterBuffer",
    "WaterToPower",
    "WindParc",
    "WindPotential",
    "WindTurbine",
    "XToPower"
]
